//! # The Loom of Fate
//!
//! The harmony-based scheduler of AethelOS.
//! The Loom does not preempt; it negotiates.
//! It does not kill greedy processes; it soothes them.
//!
//! ## Philosophy
//! Every thread is a thread of fate, weaving its purpose into the tapestry
//! of the system. The Loom's role is to maintain harmony, ensuring that
//! no thread dominates while all threads progress toward their destiny.
//!
//! ## Architecture
//! - Cooperative scheduling with implicit yielding
//! - Thread states: Weaving, Resting, Tangled, Fading
//! - Resource negotiation based on system-wide harmony
//! - Parasite detection and throttling (not killing)

pub mod context;
pub mod scheduler;
pub mod stack;
pub mod system_threads;
pub mod thread;
pub mod harmony;

pub use scheduler::{Scheduler, SchedulerStats};
pub use thread::{Thread, ThreadId, ThreadState, ThreadPriority};
pub use harmony::{HarmonyAnalyzer, HarmonyMetrics};

use spin::Mutex;
use core::mem::MaybeUninit;
use alloc::boxed::Box;

// Manual static initialization using MaybeUninit
// LOOM stores a Box<Scheduler> - a small pointer to heap-allocated Scheduler
static mut LOOM: MaybeUninit<Mutex<Box<Scheduler>>> = MaybeUninit::uninit();
static mut LOOM_INITIALIZED: bool = false;

/// Helper to write to serial for debugging
unsafe fn serial_out(c: u8) {
    core::arch::asm!(
        "out dx, al",
        in("dx") 0x3f8u16,
        in("al") c,
        options(nomem, nostack, preserves_flags)
    );
}

/// Initialize the Loom of Fate and create system threads
///
/// This creates the scheduler and spawns the three system threads:
/// - Idle thread (will be the first to run)
/// - Keyboard thread
/// - Shell thread
///
/// Note: This does NOT start the threads or enable interrupts.
/// That happens during the Great Hand-Off.
pub fn init() {
    unsafe {
        serial_out(b'1'); // Before init

        serial_out(b'A'); // About to call Scheduler::new_boxed
        let scheduler_on_heap = Scheduler::new_boxed();
        serial_out(b'B'); // Scheduler::new_boxed returned

        // Create a mutex around the small Box pointer
        serial_out(b'C'); // About to create Mutex
        let mutex = Mutex::new(scheduler_on_heap);
        serial_out(b'D'); // Mutex created

        // Write the small Mutex<Box<Scheduler>> to static
        core::ptr::write(LOOM.as_mut_ptr(), mutex);
        serial_out(b'y'); // Written to MaybeUninit

        LOOM_INITIALIZED = true;
        serial_out(b'3'); // Marked as initialized
    }

    // Now create the system threads (but don't start them yet)
    crate::println!("◈ Forging the system threads...");

    // Spawn the idle thread (lowest priority - will be first to run)
    spawn(system_threads::idle_thread, ThreadPriority::Idle)
        .expect("Failed to spawn idle thread");

    // Spawn the keyboard handler thread
    spawn(system_threads::keyboard_thread, ThreadPriority::High)
        .expect("Failed to spawn keyboard thread");

    // Spawn the shell thread
    spawn(system_threads::shell_thread, ThreadPriority::Normal)
        .expect("Failed to spawn shell thread");

    // Debug: Verify thread contexts are correct
    unsafe {
        let loom = get_loom().lock();
        for tid in 1..=3 {
            if let Some(ctx) = loom.get_thread_context(ThreadId(tid)) {
                crate::println!("  Thread {}: context@{:p}, rsp={:#x}, rip={:#x}",
                               tid, ctx, (*ctx).rsp, (*ctx).rip);
            }
        }
    }

    crate::println!("◈ System threads forged. Ready for the Great Hand-Off.");
}

/// Get reference to LOOM (assumes initialized)
unsafe fn get_loom() -> &'static Mutex<Box<Scheduler>> {
    LOOM.assume_init_ref()
}

/// Spawn a new thread
pub fn spawn(entry_point: fn() -> !, priority: ThreadPriority) -> Result<ThreadId, LoomError> {
    unsafe { get_loom().lock().spawn(entry_point, priority) }
}

/// Yield the current thread
pub fn yield_now() {
    unsafe {
        let mut loom = get_loom().lock();
        // Only yield if we actually have a current thread
        // (prevents deadlock if timer interrupt fires before Great Hand-Off)
        if loom.current_thread_id().is_some() {
            loom.yield_current();
        }
    }
}

/// Get the current thread ID
pub fn current_thread() -> Option<ThreadId> {
    unsafe { get_loom().lock().current_thread_id() }
}

/// Get scheduler statistics
pub fn stats() -> SchedulerStats {
    unsafe { get_loom().lock().stats() }
}

/// Get a pointer to the idle thread's context for the Great Hand-Off
///
/// This is called once during bootstrap to get the entry point
/// for the first thread (idle thread).
///
/// # Safety
/// Returns a raw pointer to the idle thread's context structure
pub unsafe fn get_idle_thread_context() -> *const context::ThreadContext {
    let loom = get_loom().lock();

    // The idle thread should be thread ID 1 (first spawned)
    let idle_thread_id = ThreadId(1);

    loom.get_thread_context(idle_thread_id)
        .expect("Idle thread not found!")
}

/// Prepare for the Great Hand-Off by setting the idle thread as current
///
/// This MUST be called before context_switch_first to ensure the scheduler
/// knows which thread is running after the hand-off.
pub unsafe fn prepare_great_handoff() {
    let mut loom = get_loom().lock();
    let idle_thread_id = ThreadId(1);

    // Remove idle thread from ready queue since it's about to become current
    loom.ready_queue.retain(|&id| id != idle_thread_id);

    // Set it as the current thread
    loom.current_thread = Some(idle_thread_id);

    // Mark it as Weaving (running)
    if let Some(thread) = loom.find_thread_mut(idle_thread_id) {
        thread.set_state(ThreadState::Weaving);
    }
}

/// Begin multitasking - The Sacred First Weave (DEPRECATED)
///
/// This performs the one-time transition from bootstrap code to the first
/// real thread. Unlike normal context switches, this is a one-way journey.
///
/// This function never returns - control passes to the threading system forever.
pub fn begin_weaving() -> ! {
    crate::println!("◈ The Loom begins to weave...");
    crate::println!();

    // CRITICAL: Ensure interrupts are enabled before launching threads
    unsafe {
        core::arch::asm!("sti", options(nomem, nostack, preserves_flags));
    }

    // Perform the sacred first weave - a one-way journey from bootstrap to threads
    // This will never return - we hand over control to the Loom forever
    unsafe {
        get_loom().lock().start_weaving();
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LoomError {
    OutOfThreads,
    ThreadNotFound,
    InvalidPriority,
    StackAllocationFailed,
}
