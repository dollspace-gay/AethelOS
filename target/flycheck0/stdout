{"reason":"compiler-artifact","package_id":"path+file:///C:/Users/admin/.rustup/toolchains/nightly-x86_64-pc-windows-msvc/lib/rustlib/src/rust/library/compiler-builtins/compiler-builtins#compiler_builtins@0.1.160","manifest_path":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\compiler-builtins\\compiler-builtins\\Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\compiler-builtins\\compiler-builtins\\build.rs","edition":"2024","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["compiler-builtins","default","mem","rustc-dep-of-std"],"filenames":["F:\\OS\\target\\debug\\build\\compiler_builtins-c470886b7765e4b0\\build-script-build.exe","F:\\OS\\target\\debug\\build\\compiler_builtins-c470886b7765e4b0\\build_script_build.pdb"],"executable":null,"fresh":true}
{"reason":"build-script-executed","package_id":"path+file:///C:/Users/admin/.rustup/toolchains/nightly-x86_64-pc-windows-msvc/lib/rustlib/src/rust/library/compiler-builtins/compiler-builtins#compiler_builtins@0.1.160","linked_libs":[],"linked_paths":[],"cfgs":["f16_enabled","f128_enabled","intrinsics_enabled","arch_enabled","feature=\"unstable-intrinsics\"","feature=\"mem-unaligned\""],"env":[["CFG_CARGO_FEATURES","[\"compiler-builtins\", \"default\", \"mem\", \"rustc-dep-of-std\"]"],["CFG_OPT_LEVEL","0"],["CFG_TARGET_FEATURES","[\"sse\", \"sse2\", \"x87\"]"]],"out_dir":"F:\\OS\\target\\x86_64-aethelos\\debug\\build\\compiler_builtins-9b8308c1866a2032\\out"}
{"reason":"compiler-artifact","package_id":"path+file:///C:/Users/admin/.rustup/toolchains/nightly-x86_64-pc-windows-msvc/lib/rustlib/src/rust/library/core#0.0.0","manifest_path":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"core","src_path":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\lib.rs","edition":"2024","doc":true,"doctest":true,"test":false},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libcore-f0d8acb400d41be5.rlib","F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libcore-f0d8acb400d41be5.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#libm@0.2.15","manifest_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\libm-0.2.15\\Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\libm-0.2.15\\build.rs","edition":"2021","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["F:\\OS\\target\\debug\\build\\libm-312229032915035a\\build-script-build.exe","F:\\OS\\target\\debug\\build\\libm-312229032915035a\\build_script_build.pdb"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#rustversion@1.0.22","manifest_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rustversion-1.0.22\\Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rustversion-1.0.22\\build\\build.rs","edition":"2018","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["F:\\OS\\target\\debug\\build\\rustversion-4988a90f4f1c4911\\build-script-build.exe","F:\\OS\\target\\debug\\build\\rustversion-4988a90f4f1c4911\\build_script_build.pdb"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"path+file:///C:/Users/admin/.rustup/toolchains/nightly-x86_64-pc-windows-msvc/lib/rustlib/src/rust/library/compiler-builtins/compiler-builtins#compiler_builtins@0.1.160","manifest_path":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\compiler-builtins\\compiler-builtins\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"compiler_builtins","src_path":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\compiler-builtins\\compiler-builtins\\src\\lib.rs","edition":"2024","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["compiler-builtins","default","mem","rustc-dep-of-std"],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libcompiler_builtins-0ff14bd04d1febb5.rlib","F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libcompiler_builtins-0ff14bd04d1febb5.rmeta"],"executable":null,"fresh":true}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#libm@0.2.15","linked_libs":[],"linked_paths":[],"cfgs":[],"env":[["CFG_CARGO_FEATURES","[]"],["CFG_OPT_LEVEL","0"],["CFG_TARGET_FEATURES","[\"sse\", \"sse2\", \"x87\"]"]],"out_dir":"F:\\OS\\target\\x86_64-aethelos\\debug\\build\\libm-7983b7e7e3f204cf\\out"}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#rustversion@1.0.22","linked_libs":[],"linked_paths":[],"cfgs":["host_os=\"windows\""],"env":[],"out_dir":"F:\\OS\\target\\debug\\build\\rustversion-632d73f23cf86a63\\out"}
{"reason":"compiler-artifact","package_id":"path+file:///C:/Users/admin/.rustup/toolchains/nightly-x86_64-pc-windows-msvc/lib/rustlib/src/rust/library/alloc#0.0.0","manifest_path":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\alloc\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"alloc","src_path":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\alloc\\src\\lib.rs","edition":"2024","doc":true,"doctest":true,"test":false},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["compiler-builtins-mem"],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\liballoc-d2c161e8e72bc326.rlib","F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\liballoc-d2c161e8e72bc326.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#rustversion@1.0.22","manifest_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rustversion-1.0.22\\Cargo.toml","target":{"kind":["proc-macro"],"crate_types":["proc-macro"],"name":"rustversion","src_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\rustversion-1.0.22\\src\\lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["F:\\OS\\target\\debug\\deps\\rustversion-3a23980d12dc218f.dll","F:\\OS\\target\\debug\\deps\\rustversion-3a23980d12dc218f.dll.lib","F:\\OS\\target\\debug\\deps\\rustversion-3a23980d12dc218f.dll.exp","F:\\OS\\target\\debug\\deps\\rustversion-3a23980d12dc218f.pdb"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#scopeguard@1.2.0","manifest_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\scopeguard-1.2.0\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"scopeguard","src_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\scopeguard-1.2.0\\src\\lib.rs","edition":"2015","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libscopeguard-ce771ee027c41653.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#libm@0.2.15","manifest_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\libm-0.2.15\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"libm","src_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\libm-0.2.15\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\liblibm-a8d54bb7e8ca9e7b.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#bit_field@0.10.3","manifest_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bit_field-0.10.3\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"bit_field","src_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bit_field-0.10.3\\src\\lib.rs","edition":"2015","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libbit_field-fa6e7aab334bda26.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#bitflags@2.10.0","manifest_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bitflags-2.10.0\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"bitflags","src_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bitflags-2.10.0\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libbitflags-d481ac16c9f702a2.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#volatile@0.4.6","manifest_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\volatile-0.4.6\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"volatile","src_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\volatile-0.4.6\\src\\lib.rs","edition":"2015","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libvolatile-9dcd6b1bdeb65d9a.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#scopeguard@1.2.0","manifest_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\scopeguard-1.2.0\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"scopeguard","src_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\scopeguard-1.2.0\\src\\lib.rs","edition":"2015","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libscopeguard-2ec7279c564e72c9.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#bit_field@0.10.3","manifest_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bit_field-0.10.3\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"bit_field","src_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bit_field-0.10.3\\src\\lib.rs","edition":"2015","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libbit_field-bfa924c96dce44e8.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#bitflags@2.10.0","manifest_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bitflags-2.10.0\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"bitflags","src_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bitflags-2.10.0\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libbitflags-edfe659ba36086f9.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#lock_api@0.4.14","manifest_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\lock_api-0.4.14\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"lock_api","src_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\lock_api-0.4.14\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["atomic_usize","default"],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\liblock_api-5654c6d76983740b.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#x86_64@0.14.13","manifest_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\x86_64-0.14.13\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"x86_64","src_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\x86_64-0.14.13\\src\\lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["abi_x86_interrupt","const_fn","default","inline_asm","instructions","nightly","step_trait"],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libx86_64-eaa48977eb413c75.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused imports: `String` and `ToString`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":1436,"byte_end":1442,"line_start":35,"line_end":35,"column_start":21,"column_end":27,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":21,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":1444,"byte_end":1452,"line_start":35,"line_end":35,"column_start":29,"column_end":37,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":29,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":1416,"byte_end":1455,"line_start":35,"line_end":36,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":39},{"text":"use alloc::vec::Vec;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused imports: `String` and `ToString`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\elf.rs:35:21\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m35\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use alloc::string::{String, ToString};\n   \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[93m^^^^^^\u001b[0m  \u001b[1m\u001b[93m^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `c`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11230,"byte_end":11231,"line_start":397,"line_end":397,"column_start":18,"column_end":19,"is_primary":true,"text":[{"text":"            Some(c) => {","highlight_start":18,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11230,"byte_end":11231,"line_start":397,"line_end":397,"column_start":18,"column_end":19,"is_primary":true,"text":[{"text":"            Some(c) => {","highlight_start":18,"highlight_end":19}],"label":null,"suggested_replacement":"_c","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `c`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:397:18\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m397\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(c) => {\n    \u001b[1m\u001b[96m|\u001b[0m                  \u001b[1m\u001b[93m^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_c`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `null_name`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":11932,"byte_end":11941,"line_start":373,"line_end":373,"column_start":13,"column_end":22,"is_primary":true,"text":[{"text":"        let null_name = self.shstring_table.add(\"\");","highlight_start":13,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":11932,"byte_end":11941,"line_start":373,"line_end":373,"column_start":13,"column_end":22,"is_primary":true,"text":[{"text":"        let null_name = self.shstring_table.add(\"\");","highlight_start":13,"highlight_end":22}],"label":null,"suggested_replacement":"_null_name","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `null_name`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\elf.rs:373:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m373\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let null_name = self.shstring_table.add(\"\");\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[93m^^^^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_null_name`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `cond_type`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":13249,"byte_end":13258,"line_start":439,"line_end":439,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"                let cond_type = self.analyze_node(condition);","highlight_start":21,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":13249,"byte_end":13258,"line_start":439,"line_end":439,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"                let cond_type = self.analyze_node(condition);","highlight_start":21,"highlight_end":30}],"label":null,"suggested_replacement":"_cond_type","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `cond_type`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:439:21\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m439\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 let cond_type = self.analyze_node(condition);\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[93m^^^^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_cond_type`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `elem_types`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":20727,"byte_end":20737,"line_start":620,"line_end":620,"column_start":21,"column_end":31,"is_primary":true,"text":[{"text":"                let elem_types: Vec<Type> = elements.iter()","highlight_start":21,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":20727,"byte_end":20737,"line_start":620,"line_end":620,"column_start":21,"column_end":31,"is_primary":true,"text":[{"text":"                let elem_types: Vec<Type> = elements.iter()","highlight_start":21,"highlight_end":31}],"label":null,"suggested_replacement":"_elem_types","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `elem_types`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:620:21\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m620\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 let elem_types: Vec<Type> = elements.iter()\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[93m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_elem_types`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type `Symbol` is more private than the item `SymbolTable::lookup`","code":{"code":"private_interfaces","explanation":null},"level":"warning","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":5593,"byte_end":5644,"line_start":198,"line_end":198,"column_start":5,"column_end":56,"is_primary":true,"text":[{"text":"    pub fn lookup(&self, name: &str) -> Option<&Symbol> {","highlight_start":5,"highlight_end":56}],"label":"method `SymbolTable::lookup` is reachable at visibility `pub`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"but type `Symbol` is only usable at visibility `pub(self)`","code":null,"level":"note","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":3623,"byte_end":3636,"line_start":121,"line_end":121,"column_start":1,"column_end":14,"is_primary":true,"text":[{"text":"struct Symbol {","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"`#[warn(private_interfaces)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: type `Symbol` is more private than the item `SymbolTable::lookup`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:198:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m198\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn lookup(&self, name: &str) -> Option<&Symbol> {\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[93mmethod `SymbolTable::lookup` is reachable at visibility `pub`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: but type `Symbol` is only usable at visibility `pub(self)`\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:121:1\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m121\u001b[0m \u001b[1m\u001b[96m|\u001b[0m struct Symbol {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(private_interfaces)]` on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"method `peek` is never used","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":610,"byte_end":621,"line_start":29,"line_end":29,"column_start":1,"column_end":12,"is_primary":false,"text":[{"text":"impl Parser {","highlight_start":1,"highlight_end":12}],"label":"method in this implementation","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":930,"byte_end":934,"line_start":41,"line_end":41,"column_start":8,"column_end":12,"is_primary":true,"text":[{"text":"    fn peek(&self) -> &Token {","highlight_start":8,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: method `peek` is never used\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:41:8\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m29\u001b[0m \u001b[1m\u001b[96m|\u001b[0m impl Parser {\n   \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m-----------\u001b[0m \u001b[1m\u001b[96mmethod in this implementation\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m41\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn peek(&self) -> &Token {\n   \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[93m^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"field `label_counter` is never read","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":5024,"byte_end":5031,"line_start":169,"line_end":169,"column_start":12,"column_end":19,"is_primary":false,"text":[{"text":"pub struct CodeGen {","highlight_start":12,"highlight_end":19}],"label":"field in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":5159,"byte_end":5172,"line_start":174,"line_end":174,"column_start":5,"column_end":18,"is_primary":true,"text":[{"text":"    label_counter: usize,","highlight_start":5,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: field `label_counter` is never read\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:174:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m169\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub struct CodeGen {\n    \u001b[1m\u001b[96m|\u001b[0m            \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96mfield in this struct\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m174\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     label_counter: usize,\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"method `gen_label` is never used","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":5357,"byte_end":5369,"line_start":183,"line_end":183,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"impl CodeGen {","highlight_start":1,"highlight_end":13}],"label":"method in this implementation","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":5641,"byte_end":5650,"line_start":195,"line_end":195,"column_start":8,"column_end":17,"is_primary":true,"text":[{"text":"    fn gen_label(&mut self, prefix: &str) -> String {","highlight_start":8,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: method `gen_label` is never used\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:195:8\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m183\u001b[0m \u001b[1m\u001b[96m|\u001b[0m impl CodeGen {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m------------\u001b[0m \u001b[1m\u001b[96mmethod in this implementation\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m195\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn gen_label(&mut self, prefix: &str) -> String {\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[93m^^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"fields `name` and `defined` are never read","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":3630,"byte_end":3636,"line_start":121,"line_end":121,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"struct Symbol {","highlight_start":8,"highlight_end":14}],"label":"fields in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":3643,"byte_end":3647,"line_start":122,"line_end":122,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    name: String,","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":3695,"byte_end":3702,"line_start":125,"line_end":125,"column_start":5,"column_end":12,"is_primary":true,"text":[{"text":"    defined: bool,  // For forward declarations","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`Symbol` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: fields `name` and `defined` are never read\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:122:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m121\u001b[0m \u001b[1m\u001b[96m|\u001b[0m struct Symbol {\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mfields in this struct\u001b[0m\n\u001b[1m\u001b[96m122\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     name: String,\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m125\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     defined: bool,  // For forward declarations\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `Symbol` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis\n\n"}}
{"reason":"compiler-artifact","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libglimmer_weave-d42d5aa692e12947.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#lock_api@0.4.14","manifest_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\lock_api-0.4.14\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"lock_api","src_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\lock_api-0.4.14\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["atomic_usize","default"],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\liblock_api-8bc0828c34539e44.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"path+file:///F:/OS/ancient-runes/corelib#0.1.0","manifest_path":"F:\\OS\\ancient-runes\\corelib\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"corelib","src_path":"F:\\OS\\ancient-runes\\corelib\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libcorelib-3d47f00948a002ed.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"path+file:///F:/OS/ancient-runes/corelib#0.1.0","manifest_path":"F:\\OS\\ancient-runes\\corelib\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"corelib","src_path":"F:\\OS\\ancient-runes\\corelib\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libcorelib-137cb34e61421a70.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#volatile@0.4.6","manifest_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\volatile-0.4.6\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"volatile","src_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\volatile-0.4.6\\src\\lib.rs","edition":"2015","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libvolatile-b3efad3f896a7004.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#bitflags@1.3.2","manifest_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bitflags-1.3.2\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"bitflags","src_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bitflags-1.3.2\\src\\lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default"],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libbitflags-0c9550cf74acc638.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#spin@0.9.8","manifest_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\spin-0.9.8\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"spin","src_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\spin-0.9.8\\src\\lib.rs","edition":"2015","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["barrier","default","lazy","lock_api","lock_api_crate","mutex","once","rwlock","spin_mutex"],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libspin-edcd9affdcbd1ce7.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#spin@0.9.8","manifest_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\spin-0.9.8\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"spin","src_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\spin-0.9.8\\src\\lib.rs","edition":"2015","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["barrier","default","lazy","lock_api","lock_api_crate","mutex","once","rwlock","spin_mutex"],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libspin-dfd3005a4ffdd5df.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#x86_64@0.14.13","manifest_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\x86_64-0.14.13\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"x86_64","src_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\x86_64-0.14.13\\src\\lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["abi_x86_interrupt","const_fn","default","inline_asm","instructions","nightly","step_trait"],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libx86_64-04442dafeee619ef.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#pic8259@0.10.4","manifest_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pic8259-0.10.4\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"pic8259","src_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pic8259-0.10.4\\src\\lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","nightly"],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libpic8259-48af19e4175ac3b3.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#hmac-sha256@1.1.12","manifest_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\hmac-sha256-1.1.12\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"hmac_sha256","src_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\hmac-sha256-1.1.12\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["opt_size"],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libhmac_sha256-15e500652cbb2108.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#libm@0.2.15","manifest_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\libm-0.2.15\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"libm","src_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\libm-0.2.15\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\liblibm-1b3dd43683ecc4b1.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#hmac-sha256@1.1.12","manifest_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\hmac-sha256-1.1.12\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"hmac_sha256","src_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\hmac-sha256-1.1.12\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["opt_size"],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libhmac_sha256-1020e7538ae0da1b.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#bitflags@1.3.2","manifest_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bitflags-1.3.2\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"bitflags","src_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bitflags-1.3.2\\src\\lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default"],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libbitflags-2f9d350bf886b12f.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#lazy_static@1.5.0","manifest_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\lazy_static-1.5.0\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"lazy_static","src_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\lazy_static-1.5.0\\src\\lib.rs","edition":"2015","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["spin","spin_no_std"],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\liblazy_static-288babff26f28b9b.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused imports: `String` and `ToString`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":1436,"byte_end":1442,"line_start":35,"line_end":35,"column_start":21,"column_end":27,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":21,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":1444,"byte_end":1452,"line_start":35,"line_end":35,"column_start":29,"column_end":37,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":29,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":1416,"byte_end":1455,"line_start":35,"line_end":36,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":39},{"text":"use alloc::vec::Vec;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused imports: `String` and `ToString`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\elf.rs:35:21\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m35\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use alloc::string::{String, ToString};\n   \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[93m^^^^^^\u001b[0m  \u001b[1m\u001b[93m^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `c`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11230,"byte_end":11231,"line_start":397,"line_end":397,"column_start":18,"column_end":19,"is_primary":true,"text":[{"text":"            Some(c) => {","highlight_start":18,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11230,"byte_end":11231,"line_start":397,"line_end":397,"column_start":18,"column_end":19,"is_primary":true,"text":[{"text":"            Some(c) => {","highlight_start":18,"highlight_end":19}],"label":null,"suggested_replacement":"_c","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `c`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:397:18\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m397\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(c) => {\n    \u001b[1m\u001b[96m|\u001b[0m                  \u001b[1m\u001b[93m^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_c`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `null_name`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":11932,"byte_end":11941,"line_start":373,"line_end":373,"column_start":13,"column_end":22,"is_primary":true,"text":[{"text":"        let null_name = self.shstring_table.add(\"\");","highlight_start":13,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":11932,"byte_end":11941,"line_start":373,"line_end":373,"column_start":13,"column_end":22,"is_primary":true,"text":[{"text":"        let null_name = self.shstring_table.add(\"\");","highlight_start":13,"highlight_end":22}],"label":null,"suggested_replacement":"_null_name","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `null_name`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\elf.rs:373:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m373\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let null_name = self.shstring_table.add(\"\");\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[93m^^^^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_null_name`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `cond_type`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":13249,"byte_end":13258,"line_start":439,"line_end":439,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"                let cond_type = self.analyze_node(condition);","highlight_start":21,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":13249,"byte_end":13258,"line_start":439,"line_end":439,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"                let cond_type = self.analyze_node(condition);","highlight_start":21,"highlight_end":30}],"label":null,"suggested_replacement":"_cond_type","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `cond_type`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:439:21\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m439\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 let cond_type = self.analyze_node(condition);\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[93m^^^^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_cond_type`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `elem_types`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":20727,"byte_end":20737,"line_start":620,"line_end":620,"column_start":21,"column_end":31,"is_primary":true,"text":[{"text":"                let elem_types: Vec<Type> = elements.iter()","highlight_start":21,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":20727,"byte_end":20737,"line_start":620,"line_end":620,"column_start":21,"column_end":31,"is_primary":true,"text":[{"text":"                let elem_types: Vec<Type> = elements.iter()","highlight_start":21,"highlight_end":31}],"label":null,"suggested_replacement":"_elem_types","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `elem_types`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:620:21\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m620\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 let elem_types: Vec<Type> = elements.iter()\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[93m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_elem_types`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"type `Symbol` is more private than the item `SymbolTable::lookup`","code":{"code":"private_interfaces","explanation":null},"level":"warning","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":5593,"byte_end":5644,"line_start":198,"line_end":198,"column_start":5,"column_end":56,"is_primary":true,"text":[{"text":"    pub fn lookup(&self, name: &str) -> Option<&Symbol> {","highlight_start":5,"highlight_end":56}],"label":"method `SymbolTable::lookup` is reachable at visibility `pub`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"but type `Symbol` is only usable at visibility `pub(self)`","code":null,"level":"note","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":3623,"byte_end":3636,"line_start":121,"line_end":121,"column_start":1,"column_end":14,"is_primary":true,"text":[{"text":"struct Symbol {","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"`#[warn(private_interfaces)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: type `Symbol` is more private than the item `SymbolTable::lookup`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:198:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m198\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn lookup(&self, name: &str) -> Option<&Symbol> {\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[93mmethod `SymbolTable::lookup` is reachable at visibility `pub`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: but type `Symbol` is only usable at visibility `pub(self)`\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:121:1\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m121\u001b[0m \u001b[1m\u001b[96m|\u001b[0m struct Symbol {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(private_interfaces)]` on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"method `peek` is never used","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":610,"byte_end":621,"line_start":29,"line_end":29,"column_start":1,"column_end":12,"is_primary":false,"text":[{"text":"impl Parser {","highlight_start":1,"highlight_end":12}],"label":"method in this implementation","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":930,"byte_end":934,"line_start":41,"line_end":41,"column_start":8,"column_end":12,"is_primary":true,"text":[{"text":"    fn peek(&self) -> &Token {","highlight_start":8,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: method `peek` is never used\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:41:8\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m29\u001b[0m \u001b[1m\u001b[96m|\u001b[0m impl Parser {\n   \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m-----------\u001b[0m \u001b[1m\u001b[96mmethod in this implementation\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m41\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn peek(&self) -> &Token {\n   \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[93m^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"field `label_counter` is never read","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":5024,"byte_end":5031,"line_start":169,"line_end":169,"column_start":12,"column_end":19,"is_primary":false,"text":[{"text":"pub struct CodeGen {","highlight_start":12,"highlight_end":19}],"label":"field in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":5159,"byte_end":5172,"line_start":174,"line_end":174,"column_start":5,"column_end":18,"is_primary":true,"text":[{"text":"    label_counter: usize,","highlight_start":5,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: field `label_counter` is never read\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:174:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m169\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub struct CodeGen {\n    \u001b[1m\u001b[96m|\u001b[0m            \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96mfield in this struct\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m174\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     label_counter: usize,\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"method `gen_label` is never used","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":5357,"byte_end":5369,"line_start":183,"line_end":183,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"impl CodeGen {","highlight_start":1,"highlight_end":13}],"label":"method in this implementation","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":5641,"byte_end":5650,"line_start":195,"line_end":195,"column_start":8,"column_end":17,"is_primary":true,"text":[{"text":"    fn gen_label(&mut self, prefix: &str) -> String {","highlight_start":8,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: method `gen_label` is never used\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:195:8\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m183\u001b[0m \u001b[1m\u001b[96m|\u001b[0m impl CodeGen {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m------------\u001b[0m \u001b[1m\u001b[96mmethod in this implementation\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m195\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn gen_label(&mut self, prefix: &str) -> String {\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[93m^^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"fields `name` and `defined` are never read","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":3630,"byte_end":3636,"line_start":121,"line_end":121,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"struct Symbol {","highlight_start":8,"highlight_end":14}],"label":"fields in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":3643,"byte_end":3647,"line_start":122,"line_end":122,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    name: String,","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":3695,"byte_end":3702,"line_start":125,"line_end":125,"column_start":5,"column_end":12,"is_primary":true,"text":[{"text":"    defined: bool,  // For forward declarations","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`Symbol` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: fields `name` and `defined` are never read\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:122:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m121\u001b[0m \u001b[1m\u001b[96m|\u001b[0m struct Symbol {\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mfields in this struct\u001b[0m\n\u001b[1m\u001b[96m122\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     name: String,\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m125\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     defined: bool,  // For forward declarations\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `Symbol` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis\n\n"}}
{"reason":"compiler-artifact","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libglimmer_weave-3824e357db369d86.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#lazy_static@1.5.0","manifest_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\lazy_static-1.5.0\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"lazy_static","src_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\lazy_static-1.5.0\\src\\lib.rs","edition":"2015","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["spin","spin_no_std"],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\liblazy_static-fabd84e1a0962305.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#pic8259@0.10.4","manifest_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pic8259-0.10.4\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"pic8259","src_path":"C:\\Users\\admin\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pic8259-0.10.4\\src\\lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","nightly"],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libpic8259-e169870364dce2d9.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/ancient-runes/script#0.1.0","manifest_path":"F:\\OS\\ancient-runes\\script\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"script","src_path":"F:\\OS\\ancient-runes\\script\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `command`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"ancient-runes\\script\\src\\lib.rs","byte_start":404,"byte_end":411,"line_start":17,"line_end":17,"column_start":16,"column_end":23,"is_primary":true,"text":[{"text":"pub fn execute(command: &str) -> Result<CommandResult, ScriptError> {","highlight_start":16,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"ancient-runes\\script\\src\\lib.rs","byte_start":404,"byte_end":411,"line_start":17,"line_end":17,"column_start":16,"column_end":23,"is_primary":true,"text":[{"text":"pub fn execute(command: &str) -> Result<CommandResult, ScriptError> {","highlight_start":16,"highlight_end":23}],"label":null,"suggested_replacement":"_command","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `command`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mancient-runes\\script\\src\\lib.rs:17:16\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m17\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn execute(command: &str) -> Result<CommandResult, ScriptError> {\n   \u001b[1m\u001b[96m|\u001b[0m                \u001b[1m\u001b[93m^^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_command`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/ancient-runes/script#0.1.0","manifest_path":"F:\\OS\\ancient-runes\\script\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"script","src_path":"F:\\OS\\ancient-runes\\script\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `text`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"ancient-runes\\script\\src\\lib.rs","byte_start":1080,"byte_end":1084,"line_start":46,"line_end":46,"column_start":14,"column_end":18,"is_primary":true,"text":[{"text":"pub fn print(text: &str) {","highlight_start":14,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"ancient-runes\\script\\src\\lib.rs","byte_start":1080,"byte_end":1084,"line_start":46,"line_end":46,"column_start":14,"column_end":18,"is_primary":true,"text":[{"text":"pub fn print(text: &str) {","highlight_start":14,"highlight_end":18}],"label":null,"suggested_replacement":"_text","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `text`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mancient-runes\\script\\src\\lib.rs:46:14\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m46\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn print(text: &str) {\n   \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[93m^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_text`\u001b[0m\n\n"}}
{"reason":"compiler-artifact","package_id":"path+file:///F:/OS/ancient-runes/script#0.1.0","manifest_path":"F:\\OS\\ancient-runes\\script\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"script","src_path":"F:\\OS\\ancient-runes\\script\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libscript-34970569e1d55353.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"path+file:///F:/OS/user_programs/hello#0.1.0","manifest_path":"F:\\OS\\user_programs\\hello\\Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"hello","src_path":"F:\\OS\\user_programs\\hello\\src\\main.rs","edition":"2021","doc":true,"doctest":false,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libhello-830217ded5d8e979.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"path+file:///F:/OS/user_programs/test_service#0.1.0","manifest_path":"F:\\OS\\user_programs\\test_service\\Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"test_service","src_path":"F:\\OS\\user_programs\\test_service\\src\\main.rs","edition":"2021","doc":true,"doctest":false,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libtest_service-16b19402073dd20d.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"path+file:///F:/OS/ancient-runes/weaving#0.1.0","manifest_path":"F:\\OS\\ancient-runes\\weaving\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"weaving","src_path":"F:\\OS\\ancient-runes\\weaving\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libweaving-86bd147acc6f1f81.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/ancient-runes/script#0.1.0","manifest_path":"F:\\OS\\ancient-runes\\script\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"script","src_path":"F:\\OS\\ancient-runes\\script\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"ancient-runes\\script\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/ancient-runes/script#0.1.0","manifest_path":"F:\\OS\\ancient-runes\\script\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"script","src_path":"F:\\OS\\ancient-runes\\script\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/ancient-runes/script#0.1.0","manifest_path":"F:\\OS\\ancient-runes\\script\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"script","src_path":"F:\\OS\\ancient-runes\\script\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"`#[panic_handler]` function required, but not found","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: `#[panic_handler]` function required, but not found\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/user_programs/hello#0.1.0","manifest_path":"F:\\OS\\user_programs\\hello\\Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"hello","src_path":"F:\\OS\\user_programs\\hello\\src\\main.rs","edition":"2021","doc":true,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"user_programs\\hello\\src\\main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/ancient-runes/script#0.1.0","manifest_path":"F:\\OS\\ancient-runes\\script\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"script","src_path":"F:\\OS\\ancient-runes\\script\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `command`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"ancient-runes\\script\\src\\lib.rs","byte_start":404,"byte_end":411,"line_start":17,"line_end":17,"column_start":16,"column_end":23,"is_primary":true,"text":[{"text":"pub fn execute(command: &str) -> Result<CommandResult, ScriptError> {","highlight_start":16,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"ancient-runes\\script\\src\\lib.rs","byte_start":404,"byte_end":411,"line_start":17,"line_end":17,"column_start":16,"column_end":23,"is_primary":true,"text":[{"text":"pub fn execute(command: &str) -> Result<CommandResult, ScriptError> {","highlight_start":16,"highlight_end":23}],"label":null,"suggested_replacement":"_command","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `command`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mancient-runes\\script\\src\\lib.rs:17:16\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m17\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn execute(command: &str) -> Result<CommandResult, ScriptError> {\n   \u001b[1m\u001b[96m|\u001b[0m                \u001b[1m\u001b[93m^^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_command`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `std`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the `x86_64-aethelos` target may not support the standard library","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`std` is required by `interpreter_tests` because it does not declare `#![no_std]`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider building the standard library from source with `cargo build -Zbuild-std`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `std`\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: the `x86_64-aethelos` target may not support the standard library\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `std` is required by `interpreter_tests` because it does not declare `#![no_std]`\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: consider building the standard library from source with `cargo build -Zbuild-std`\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot resolve a prelude import","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot resolve a prelude import\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/ancient-runes/script#0.1.0","manifest_path":"F:\\OS\\ancient-runes\\script\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"script","src_path":"F:\\OS\\ancient-runes\\script\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `text`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"ancient-runes\\script\\src\\lib.rs","byte_start":1080,"byte_end":1084,"line_start":46,"line_end":46,"column_start":14,"column_end":18,"is_primary":true,"text":[{"text":"pub fn print(text: &str) {","highlight_start":14,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"ancient-runes\\script\\src\\lib.rs","byte_start":1080,"byte_end":1084,"line_start":46,"line_end":46,"column_start":14,"column_end":18,"is_primary":true,"text":[{"text":"pub fn print(text: &str) {","highlight_start":14,"highlight_end":18}],"label":null,"suggested_replacement":"_text","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `text`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mancient-runes\\script\\src\\lib.rs:46:14\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m46\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn print(text: &str) {\n   \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[93m^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_text`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/ancient-runes/script#0.1.0","manifest_path":"F:\\OS\\ancient-runes\\script\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"script","src_path":"F:\\OS\\ancient-runes\\script\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0463`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mFor more information about this error, try `rustc --explain E0463`.\u001b[0m\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/ancient-runes/weaving#0.1.0","manifest_path":"F:\\OS\\ancient-runes\\weaving\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"weaving","src_path":"F:\\OS\\ancient-runes\\weaving\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"ancient-runes\\weaving\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/ancient-runes/weaving#0.1.0","manifest_path":"F:\\OS\\ancient-runes\\weaving\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"weaving","src_path":"F:\\OS\\ancient-runes\\weaving\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/ancient-runes/weaving#0.1.0","manifest_path":"F:\\OS\\ancient-runes\\weaving\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"weaving","src_path":"F:\\OS\\ancient-runes\\weaving\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"`#[panic_handler]` function required, but not found","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: `#[panic_handler]` function required, but not found\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/user_programs/hello#0.1.0","manifest_path":"F:\\OS\\user_programs\\hello\\Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"hello","src_path":"F:\\OS\\user_programs\\hello\\src\\main.rs","edition":"2021","doc":true,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0463`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mFor more information about this error, try `rustc --explain E0463`.\u001b[0m\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/user_programs/test_service#0.1.0","manifest_path":"F:\\OS\\user_programs\\test_service\\Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"test_service","src_path":"F:\\OS\\user_programs\\test_service\\src\\main.rs","edition":"2021","doc":true,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"user_programs\\test_service\\src\\main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":8023,"byte_end":8027,"line_start":391,"line_end":391,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:391:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m391\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":8162,"byte_end":8168,"line_start":401,"line_end":401,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    assert!(result.is_err(), \"Should fail with arity mismatch\");","highlight_start":5,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::assert;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:401:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m401\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     assert!(result.is_err(), \"Should fail with arity mismatch\");\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::assert;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":7879,"byte_end":7883,"line_start":385,"line_end":385,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:385:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m385\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/user_programs/test_service#0.1.0","manifest_path":"F:\\OS\\user_programs\\test_service\\Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"test_service","src_path":"F:\\OS\\user_programs\\test_service\\src\\main.rs","edition":"2021","doc":true,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0463`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mFor more information about this error, try `rustc --explain E0463`.\u001b[0m\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":7961,"byte_end":7967,"line_start":388,"line_end":388,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    assert!(result.is_err(), \"Should fail with type error\");","highlight_start":5,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::assert;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:388:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m388\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     assert!(result.is_err(), \"Should fail with type error\");\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::assert;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/ancient-runes/weaving#0.1.0","manifest_path":"F:\\OS\\ancient-runes\\weaving\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"weaving","src_path":"F:\\OS\\ancient-runes\\weaving\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0463`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mFor more information about this error, try `rustc --explain E0463`.\u001b[0m\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":7679,"byte_end":7683,"line_start":375,"line_end":375,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:375:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m375\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":7808,"byte_end":7814,"line_start":382,"line_end":382,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    assert!(result.is_err(), \"Should fail with index out of bounds\");","highlight_start":5,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::assert;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:382:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m382\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     assert!(result.is_err(), \"Should fail with index out of bounds\");\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::assert;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":7540,"byte_end":7544,"line_start":369,"line_end":369,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:369:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m369\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":7611,"byte_end":7617,"line_start":372,"line_end":372,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    assert!(result.is_err(), \"Should fail with division by zero\");","highlight_start":5,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::assert;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:372:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m372\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     assert!(result.is_err(), \"Should fail with division by zero\");\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::assert;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":7340,"byte_end":7344,"line_start":359,"line_end":359,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:359:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m359\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":7467,"byte_end":7473,"line_start":366,"line_end":366,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    assert!(result.is_err(), \"Should fail mutating immutable binding\");","highlight_start":5,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::assert;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:366:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m366\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     assert!(result.is_err(), \"Should fail mutating immutable binding\");\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::assert;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":7184,"byte_end":7188,"line_start":353,"line_end":353,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:353:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m353\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\boot\\multiboot2.rs","byte_start":4492,"byte_end":4642,"line_start":170,"line_end":175,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_header_size() {","highlight_start":5,"highlight_end":28},{"text":"        assert_eq!(","highlight_start":1,"highlight_end":20},{"text":"            core::mem::size_of::<CompleteHeader>(),","highlight_start":1,"highlight_end":52},{"text":"            HEADER_SIZE as usize","highlight_start":1,"highlight_end":33},{"text":"        );","highlight_start":1,"highlight_end":11},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\boot\\multiboot2.rs","byte_start":4479,"byte_end":4486,"line_start":169,"line_end":169,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\boot\\multiboot2.rs:170:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m169\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m170\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_header_size() {\n\u001b[1m\u001b[96m171\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(\n\u001b[1m\u001b[96m172\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             core::mem::size_of::<CompleteHeader>(),\n\u001b[1m\u001b[96m173\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             HEADER_SIZE as usize\n\u001b[1m\u001b[96m174\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         );\n\u001b[1m\u001b[96m175\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\boot\\multiboot2.rs","byte_start":4663,"byte_end":4991,"line_start":178,"line_end":185,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_checksum() {","highlight_start":5,"highlight_end":25},{"text":"        let header = Multiboot2Header::new(HEADER_SIZE);","highlight_start":1,"highlight_end":57},{"text":"        let sum = header.magic","highlight_start":1,"highlight_end":31},{"text":"            .wrapping_add(header.architecture)","highlight_start":1,"highlight_end":47},{"text":"            .wrapping_add(header.header_length)","highlight_start":1,"highlight_end":48},{"text":"            .wrapping_add(header.checksum);","highlight_start":1,"highlight_end":44},{"text":"        assert_eq!(sum, 0, \"Checksum must make sum equal to zero\");","highlight_start":1,"highlight_end":68},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\boot\\multiboot2.rs","byte_start":4650,"byte_end":4657,"line_start":177,"line_end":177,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\boot\\multiboot2.rs:178:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m177\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m178\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_checksum() {\n\u001b[1m\u001b[96m179\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let header = Multiboot2Header::new(HEADER_SIZE);\n\u001b[1m\u001b[96m180\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let sum = header.magic\n\u001b[1m\u001b[96m181\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             .wrapping_add(header.architecture)\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m184\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(sum, 0, \"Checksum must make sum equal to zero\");\n\u001b[1m\u001b[96m185\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/the-weave_grove#0.1.0","manifest_path":"F:\\OS\\groves\\the-weave_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"the_weave_grove","src_path":"F:\\OS\\groves\\the-weave_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `amplitude`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":2130,"byte_end":2139,"line_start":85,"line_end":85,"column_start":36,"column_end":45,"is_primary":true,"text":[{"text":"    pub fn apply_ripple(&mut self, amplitude: f32, frequency: f32, time: f32) {","highlight_start":36,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":2130,"byte_end":2139,"line_start":85,"line_end":85,"column_start":36,"column_end":45,"is_primary":true,"text":[{"text":"    pub fn apply_ripple(&mut self, amplitude: f32, frequency: f32, time: f32) {","highlight_start":36,"highlight_end":45}],"label":null,"suggested_replacement":"_amplitude","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `amplitude`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\the-weave_grove\\src\\lib.rs:85:36\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m85\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn apply_ripple(&mut self, amplitude: f32, frequency: f32, time: f32) {\n   \u001b[1m\u001b[96m|\u001b[0m                                    \u001b[1m\u001b[93m^^^^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_amplitude`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/the-weave_grove#0.1.0","manifest_path":"F:\\OS\\groves\\the-weave_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"the_weave_grove","src_path":"F:\\OS\\groves\\the-weave_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `frequency`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":2146,"byte_end":2155,"line_start":85,"line_end":85,"column_start":52,"column_end":61,"is_primary":true,"text":[{"text":"    pub fn apply_ripple(&mut self, amplitude: f32, frequency: f32, time: f32) {","highlight_start":52,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":2146,"byte_end":2155,"line_start":85,"line_end":85,"column_start":52,"column_end":61,"is_primary":true,"text":[{"text":"    pub fn apply_ripple(&mut self, amplitude: f32, frequency: f32, time: f32) {","highlight_start":52,"highlight_end":61}],"label":null,"suggested_replacement":"_frequency","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `frequency`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\the-weave_grove\\src\\lib.rs:85:52\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m85\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn apply_ripple(&mut self, amplitude: f32, frequency: f32, time: f32) {\n   \u001b[1m\u001b[96m|\u001b[0m                                                    \u001b[1m\u001b[93m^^^^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_frequency`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/the-weave_grove#0.1.0","manifest_path":"F:\\OS\\groves\\the-weave_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"the_weave_grove","src_path":"F:\\OS\\groves\\the-weave_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `time`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":2162,"byte_end":2166,"line_start":85,"line_end":85,"column_start":68,"column_end":72,"is_primary":true,"text":[{"text":"    pub fn apply_ripple(&mut self, amplitude: f32, frequency: f32, time: f32) {","highlight_start":68,"highlight_end":72}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":2162,"byte_end":2166,"line_start":85,"line_end":85,"column_start":68,"column_end":72,"is_primary":true,"text":[{"text":"    pub fn apply_ripple(&mut self, amplitude: f32, frequency: f32, time: f32) {","highlight_start":68,"highlight_end":72}],"label":null,"suggested_replacement":"_time","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `time`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\the-weave_grove\\src\\lib.rs:85:68\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m85\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn apply_ripple(&mut self, amplitude: f32, frequency: f32, time: f32) {\n   \u001b[1m\u001b[96m|\u001b[0m                                                                    \u001b[1m\u001b[93m^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_time`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/the-weave_grove#0.1.0","manifest_path":"F:\\OS\\groves\\the-weave_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"the_weave_grove","src_path":"F:\\OS\\groves\\the-weave_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `parent`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":4028,"byte_end":4034,"line_start":166,"line_end":166,"column_start":32,"column_end":38,"is_primary":true,"text":[{"text":"    pub fn add_node(&mut self, parent: NodeId, node: SceneNode) -> NodeId {","highlight_start":32,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":4028,"byte_end":4034,"line_start":166,"line_end":166,"column_start":32,"column_end":38,"is_primary":true,"text":[{"text":"    pub fn add_node(&mut self, parent: NodeId, node: SceneNode) -> NodeId {","highlight_start":32,"highlight_end":38}],"label":null,"suggested_replacement":"_parent","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `parent`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\the-weave_grove\\src\\lib.rs:166:32\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m166\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn add_node(&mut self, parent: NodeId, node: SceneNode) -> NodeId {\n    \u001b[1m\u001b[96m|\u001b[0m                                \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_parent`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/the-weave_grove#0.1.0","manifest_path":"F:\\OS\\groves\\the-weave_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"the_weave_grove","src_path":"F:\\OS\\groves\\the-weave_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `node`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":4044,"byte_end":4048,"line_start":166,"line_end":166,"column_start":48,"column_end":52,"is_primary":true,"text":[{"text":"    pub fn add_node(&mut self, parent: NodeId, node: SceneNode) -> NodeId {","highlight_start":48,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":4044,"byte_end":4048,"line_start":166,"line_end":166,"column_start":48,"column_end":52,"is_primary":true,"text":[{"text":"    pub fn add_node(&mut self, parent: NodeId, node: SceneNode) -> NodeId {","highlight_start":48,"highlight_end":52}],"label":null,"suggested_replacement":"_node","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `node`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\the-weave_grove\\src\\lib.rs:166:48\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m166\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn add_node(&mut self, parent: NodeId, node: SceneNode) -> NodeId {\n    \u001b[1m\u001b[96m|\u001b[0m                                                \u001b[1m\u001b[93m^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_node`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/the-weave_grove#0.1.0","manifest_path":"F:\\OS\\groves\\the-weave_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"the_weave_grove","src_path":"F:\\OS\\groves\\the-weave_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `node`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":4600,"byte_end":4604,"line_start":182,"line_end":182,"column_start":36,"column_end":40,"is_primary":true,"text":[{"text":"    pub fn attach_glyph(&mut self, node: NodeId, glyph: Glyph) {","highlight_start":36,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":4600,"byte_end":4604,"line_start":182,"line_end":182,"column_start":36,"column_end":40,"is_primary":true,"text":[{"text":"    pub fn attach_glyph(&mut self, node: NodeId, glyph: Glyph) {","highlight_start":36,"highlight_end":40}],"label":null,"suggested_replacement":"_node","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `node`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\the-weave_grove\\src\\lib.rs:182:36\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m182\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn attach_glyph(&mut self, node: NodeId, glyph: Glyph) {\n    \u001b[1m\u001b[96m|\u001b[0m                                    \u001b[1m\u001b[93m^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_node`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/the-weave_grove#0.1.0","manifest_path":"F:\\OS\\groves\\the-weave_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"the_weave_grove","src_path":"F:\\OS\\groves\\the-weave_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `glyph`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":4614,"byte_end":4619,"line_start":182,"line_end":182,"column_start":50,"column_end":55,"is_primary":true,"text":[{"text":"    pub fn attach_glyph(&mut self, node: NodeId, glyph: Glyph) {","highlight_start":50,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":4614,"byte_end":4619,"line_start":182,"line_end":182,"column_start":50,"column_end":55,"is_primary":true,"text":[{"text":"    pub fn attach_glyph(&mut self, node: NodeId, glyph: Glyph) {","highlight_start":50,"highlight_end":55}],"label":null,"suggested_replacement":"_glyph","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `glyph`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\the-weave_grove\\src\\lib.rs:182:50\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m182\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn attach_glyph(&mut self, node: NodeId, glyph: Glyph) {\n    \u001b[1m\u001b[96m|\u001b[0m                                                  \u001b[1m\u001b[93m^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_glyph`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/the-weave_grove#0.1.0","manifest_path":"F:\\OS\\groves\\the-weave_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"the_weave_grove","src_path":"F:\\OS\\groves\\the-weave_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"field `root` is never read","code":{"code":"dead_code","explanation":null},"level":"warning","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":3217,"byte_end":3232,"line_start":134,"line_end":134,"column_start":12,"column_end":27,"is_primary":false,"text":[{"text":"pub struct WeaveCompositor {","highlight_start":12,"highlight_end":27}],"label":"field in this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":3240,"byte_end":3244,"line_start":135,"line_end":135,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    root: SceneNode,","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: field `root` is never read\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\the-weave_grove\\src\\lib.rs:135:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m134\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub struct WeaveCompositor {\n    \u001b[1m\u001b[96m|\u001b[0m            \u001b[1m\u001b[96m---------------\u001b[0m \u001b[1m\u001b[96mfield in this struct\u001b[0m\n\u001b[1m\u001b[96m135\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     root: SceneNode,\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-artifact","package_id":"path+file:///F:/OS/groves/the-weave_grove#0.1.0","manifest_path":"F:\\OS\\groves\\the-weave_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"the_weave_grove","src_path":"F:\\OS\\groves\\the-weave_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libthe_weave_grove-703465b433970e1e.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":7270,"byte_end":7276,"line_start":356,"line_end":356,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    assert!(result.is_err(), \"Should fail with undefined variable\");","highlight_start":5,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::assert;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:356:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m356\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     assert!(result.is_err(), \"Should fail with undefined variable\");\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::assert;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\boot\\multiboot2.rs","byte_start":5012,"byte_end":5188,"line_start":188,"line_end":194,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_alignment() {","highlight_start":5,"highlight_end":26},{"text":"        assert_eq!(","highlight_start":1,"highlight_end":20},{"text":"            core::mem::align_of::<CompleteHeader>(),","highlight_start":1,"highlight_end":53},{"text":"            8,","highlight_start":1,"highlight_end":15},{"text":"            \"Header must be 8-byte aligned\"","highlight_start":1,"highlight_end":44},{"text":"        );","highlight_start":1,"highlight_end":11},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\boot\\multiboot2.rs","byte_start":4999,"byte_end":5006,"line_start":187,"line_end":187,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\boot\\multiboot2.rs:188:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m187\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m188\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_alignment() {\n\u001b[1m\u001b[96m189\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(\n\u001b[1m\u001b[96m190\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             core::mem::align_of::<CompleteHeader>(),\n\u001b[1m\u001b[96m191\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             8,\n\u001b[1m\u001b[96m192\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             \"Header must be 8-byte aligned\"\n\u001b[1m\u001b[96m193\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         );\n\u001b[1m\u001b[96m194\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\boot\\multiboot2.rs","byte_start":5209,"byte_end":5344,"line_start":197,"line_end":200,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_magic() {","highlight_start":5,"highlight_end":22},{"text":"        let header = Multiboot2Header::new(HEADER_SIZE);","highlight_start":1,"highlight_end":57},{"text":"        assert_eq!(header.magic, MULTIBOOT2_MAGIC);","highlight_start":1,"highlight_end":52},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\boot\\multiboot2.rs","byte_start":5196,"byte_end":5203,"line_start":196,"line_end":196,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\boot\\multiboot2.rs:197:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m196\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m197\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_magic() {\n\u001b[1m\u001b[96m198\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let header = Multiboot2Header::new(HEADER_SIZE);\n\u001b[1m\u001b[96m199\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(header.magic, MULTIBOOT2_MAGIC);\n\u001b[1m\u001b[96m200\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":6917,"byte_end":6921,"line_start":335,"line_end":335,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:335:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m335\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\context.rs","byte_start":25786,"byte_end":26081,"line_start":764,"line_end":771,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_context_creation() {","highlight_start":5,"highlight_end":33},{"text":"        let ctx = ThreadContext::new(0x1000, 0x5000);","highlight_start":1,"highlight_end":54},{"text":"        assert_eq!(ctx.rip, 0x1000);","highlight_start":1,"highlight_end":37},{"text":"        assert_eq!(ctx.rsp, 0x5000);","highlight_start":1,"highlight_end":37},{"text":"        assert_eq!(ctx.cs, 0x08);","highlight_start":1,"highlight_end":34},{"text":"        assert_eq!(ctx.ss, 0x10);","highlight_start":1,"highlight_end":34},{"text":"        assert_ne!(ctx.rflags & 0x200, 0); // IF flag set","highlight_start":1,"highlight_end":58},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\loom_of_fate\\context.rs","byte_start":25773,"byte_end":25780,"line_start":763,"line_end":763,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\loom_of_fate\\context.rs:764:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m763\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m764\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_context_creation() {\n\u001b[1m\u001b[96m765\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let ctx = ThreadContext::new(0x1000, 0x5000);\n\u001b[1m\u001b[96m766\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(ctx.rip, 0x1000);\n\u001b[1m\u001b[96m767\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(ctx.rsp, 0x5000);\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m770\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_ne!(ctx.rflags & 0x200, 0); // IF flag set\n\u001b[1m\u001b[96m771\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\context.rs","byte_start":26102,"byte_end":26276,"line_start":774,"line_end":779,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_empty_context() {","highlight_start":5,"highlight_end":30},{"text":"        let ctx = ThreadContext::empty();","highlight_start":1,"highlight_end":42},{"text":"        assert_eq!(ctx.rip, 0);","highlight_start":1,"highlight_end":32},{"text":"        assert_eq!(ctx.rsp, 0);","highlight_start":1,"highlight_end":32},{"text":"        assert_eq!(ctx.rax, 0);","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\loom_of_fate\\context.rs","byte_start":26089,"byte_end":26096,"line_start":773,"line_end":773,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\loom_of_fate\\context.rs:774:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m773\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m774\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_empty_context() {\n\u001b[1m\u001b[96m775\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let ctx = ThreadContext::empty();\n\u001b[1m\u001b[96m776\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(ctx.rip, 0);\n\u001b[1m\u001b[96m777\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(ctx.rsp, 0);\n\u001b[1m\u001b[96m778\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(ctx.rax, 0);\n\u001b[1m\u001b[96m779\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\stack.rs","byte_start":4449,"byte_end":4735,"line_start":141,"line_end":146,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_stack_allocation() {","highlight_start":5,"highlight_end":33},{"text":"        let stack = Stack::new().expect(\"Failed to allocate stack\");","highlight_start":1,"highlight_end":69},{"text":"        assert_eq!(stack.size(), DEFAULT_STACK_SIZE);","highlight_start":1,"highlight_end":54},{"text":"        assert!(stack.top() > stack.bottom());","highlight_start":1,"highlight_end":47},{"text":"        assert_eq!(stack.top() - stack.bottom(), DEFAULT_STACK_SIZE as u64);","highlight_start":1,"highlight_end":77},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\loom_of_fate\\stack.rs","byte_start":4436,"byte_end":4443,"line_start":140,"line_end":140,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\loom_of_fate\\stack.rs:141:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m140\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m141\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_stack_allocation() {\n\u001b[1m\u001b[96m142\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let stack = Stack::new().expect(\"Failed to allocate stack\");\n\u001b[1m\u001b[96m143\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(stack.size(), DEFAULT_STACK_SIZE);\n\u001b[1m\u001b[96m144\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(stack.top() > stack.bottom());\n\u001b[1m\u001b[96m145\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(stack.top() - stack.bottom(), DEFAULT_STACK_SIZE as u64);\n\u001b[1m\u001b[96m146\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":6661,"byte_end":6665,"line_start":319,"line_end":319,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:319:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m319\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":6430,"byte_end":6434,"line_start":309,"line_end":309,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:309:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m309\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\stack.rs","byte_start":4756,"byte_end":4901,"line_start":149,"line_end":152,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_custom_size() {","highlight_start":5,"highlight_end":28},{"text":"        let stack = Stack::with_size(8192).expect(\"Failed to allocate\");","highlight_start":1,"highlight_end":73},{"text":"        assert_eq!(stack.size(), 8192);","highlight_start":1,"highlight_end":40},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\loom_of_fate\\stack.rs","byte_start":4743,"byte_end":4750,"line_start":148,"line_end":148,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\loom_of_fate\\stack.rs:149:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m148\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m149\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_custom_size() {\n\u001b[1m\u001b[96m150\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let stack = Stack::with_size(8192).expect(\"Failed to allocate\");\n\u001b[1m\u001b[96m151\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(stack.size(), 8192);\n\u001b[1m\u001b[96m152\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":6264,"byte_end":6268,"line_start":295,"line_end":295,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:295:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m295\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\stack.rs","byte_start":4922,"byte_end":5327,"line_start":155,"line_end":163,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_size_clamping() {","highlight_start":5,"highlight_end":30},{"text":"        // Too small - should clamp to MIN_STACK_SIZE","highlight_start":1,"highlight_end":54},{"text":"        let stack = Stack::with_size(100).expect(\"Failed to allocate\");","highlight_start":1,"highlight_end":72},{"text":"        assert_eq!(stack.size(), MIN_STACK_SIZE);","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Too large - should clamp to MAX_STACK_SIZE","highlight_start":1,"highlight_end":54},{"text":"        let stack = Stack::with_size(10 * 1024 * 1024).expect(\"Failed to allocate\");","highlight_start":1,"highlight_end":85},{"text":"        assert_eq!(stack.size(), MAX_STACK_SIZE);","highlight_start":1,"highlight_end":50},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\loom_of_fate\\stack.rs","byte_start":4909,"byte_end":4916,"line_start":154,"line_end":154,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\loom_of_fate\\stack.rs:155:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m154\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m155\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_size_clamping() {\n\u001b[1m\u001b[96m156\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         // Too small - should clamp to MIN_STACK_SIZE\n\u001b[1m\u001b[96m157\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let stack = Stack::with_size(100).expect(\"Failed to allocate\");\n\u001b[1m\u001b[96m158\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(stack.size(), MIN_STACK_SIZE);\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m162\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(stack.size(), MAX_STACK_SIZE);\n\u001b[1m\u001b[96m163\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\stack.rs","byte_start":5348,"byte_end":5731,"line_start":166,"line_end":176,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_contains() {","highlight_start":5,"highlight_end":25},{"text":"        let stack = Stack::new().expect(\"Failed to allocate\");","highlight_start":1,"highlight_end":63},{"text":"        let bottom = stack.bottom();","highlight_start":1,"highlight_end":37},{"text":"        let top = stack.top();","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        assert!(stack.contains(bottom));","highlight_start":1,"highlight_end":41},{"text":"        assert!(stack.contains(bottom + 100));","highlight_start":1,"highlight_end":47},{"text":"        assert!(stack.contains(top - 1));","highlight_start":1,"highlight_end":42},{"text":"        assert!(!stack.contains(top));","highlight_start":1,"highlight_end":39},{"text":"        assert!(!stack.contains(bottom - 1));","highlight_start":1,"highlight_end":46},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\loom_of_fate\\stack.rs","byte_start":5335,"byte_end":5342,"line_start":165,"line_end":165,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\loom_of_fate\\stack.rs:166:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m165\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m166\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_contains() {\n\u001b[1m\u001b[96m167\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let stack = Stack::new().expect(\"Failed to allocate\");\n\u001b[1m\u001b[96m168\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let bottom = stack.bottom();\n\u001b[1m\u001b[96m169\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let top = stack.top();\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m175\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(!stack.contains(bottom - 1));\n\u001b[1m\u001b[96m176\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"couldn't read `heartwood\\src\\../../target/x86_64-unknown-none/release/hello`: The system cannot find the path specified. (os error 3)","code":null,"level":"error","spans":[{"file_name":"heartwood\\src\\test_programs.rs","byte_start":108,"byte_end":172,"line_start":4,"line_end":4,"column_start":30,"column_end":94,"is_primary":true,"text":[{"text":"pub const HELLO_ELF: &[u8] = include_bytes!(\"../../target/x86_64-unknown-none/release/hello\");","highlight_start":30,"highlight_end":94}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\test_programs.rs","byte_start":108,"byte_end":172,"line_start":4,"line_end":4,"column_start":30,"column_end":94,"is_primary":false,"text":[{"text":"pub const HELLO_ELF: &[u8] = include_bytes!(\"../../target/x86_64-unknown-none/release/hello\");","highlight_start":30,"highlight_end":94}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"include_bytes!","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":48445,"byte_end":48471,"line_start":1360,"line_end":1360,"column_start":5,"column_end":31,"is_primary":false,"text":[{"text":"    macro_rules! include_bytes {","highlight_start":5,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: couldn't read `heartwood\\src\\../../target/x86_64-unknown-none/release/hello`: The system cannot find the path specified. (os error 3)\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\test_programs.rs:4:30\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m4\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub const HELLO_ELF: &[u8] = include_bytes!(\"../../target/x86_64-unknown-none/release/hello\");\n  \u001b[1m\u001b[96m|\u001b[0m                              \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\system_threads.rs","byte_start":8515,"byte_end":8756,"line_start":254,"line_end":259,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_thread_signatures() {","highlight_start":5,"highlight_end":34},{"text":"        // Just verify the function signatures are correct","highlight_start":1,"highlight_end":59},{"text":"        let _idle: fn() -> ! = idle_thread;","highlight_start":1,"highlight_end":44},{"text":"        let _keyboard: fn() -> ! = keyboard_thread;","highlight_start":1,"highlight_end":52},{"text":"        let _shell: fn() -> ! = shell_thread;","highlight_start":1,"highlight_end":46},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\loom_of_fate\\system_threads.rs","byte_start":8502,"byte_end":8509,"line_start":253,"line_end":253,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\loom_of_fate\\system_threads.rs:254:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m253\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m254\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_thread_signatures() {\n\u001b[1m\u001b[96m255\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         // Just verify the function signatures are correct\n\u001b[1m\u001b[96m256\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let _idle: fn() -> ! = idle_thread;\n\u001b[1m\u001b[96m257\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let _keyboard: fn() -> ! = keyboard_thread;\n\u001b[1m\u001b[96m258\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let _shell: fn() -> ! = shell_thread;\n\u001b[1m\u001b[96m259\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\elf_loader.rs","byte_start":14579,"byte_end":15197,"line_start":472,"line_end":487,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_elf_header_validation() {","highlight_start":5,"highlight_end":38},{"text":"        // Create a minimal valid ELF header","highlight_start":1,"highlight_end":45},{"text":"        let mut data = [0u8; size_of::<Elf64Ehdr>()];","highlight_start":1,"highlight_end":54},{"text":"        data[0..4].copy_from_slice(&ELF_MAGIC);","highlight_start":1,"highlight_end":48},{"text":"        data[4] = ELFCLASS64;","highlight_start":1,"highlight_end":30},{"text":"        data[5] = ELFDATA2LSB;","highlight_start":1,"highlight_end":31},{"text":"        data[6] = EV_CURRENT;","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Set e_type, e_machine, e_version (little-endian)","highlight_start":1,"highlight_end":60},{"text":"        data[16..18].copy_from_slice(&ET_EXEC.to_le_bytes());","highlight_start":1,"highlight_end":62},{"text":"        data[18..20].copy_from_slice(&EM_X86_64.to_le_bytes());","highlight_start":1,"highlight_end":64},{"text":"        data[20..24].copy_from_slice(&1u32.to_le_bytes());","highlight_start":1,"highlight_end":59},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let result = parse_elf_header(&data);","highlight_start":1,"highlight_end":46},{"text":"        assert!(result.is_ok());","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\loom_of_fate\\elf_loader.rs","byte_start":14566,"byte_end":14573,"line_start":471,"line_end":471,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\loom_of_fate\\elf_loader.rs:472:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m471\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m472\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_elf_header_validation() {\n\u001b[1m\u001b[96m473\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         // Create a minimal valid ELF header\n\u001b[1m\u001b[96m474\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let mut data = [0u8; size_of::<Elf64Ehdr>()];\n\u001b[1m\u001b[96m475\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         data[0..4].copy_from_slice(&ELF_MAGIC);\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m486\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(result.is_ok());\n\u001b[1m\u001b[96m487\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\elf_loader.rs","byte_start":15218,"byte_end":15406,"line_start":490,"line_end":494,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_invalid_magic() {","highlight_start":5,"highlight_end":30},{"text":"        let data = [0u8; size_of::<Elf64Ehdr>()];","highlight_start":1,"highlight_end":50},{"text":"        let result = parse_elf_header(&data);","highlight_start":1,"highlight_end":46},{"text":"        assert_eq!(result, Err(ElfError::InvalidMagic));","highlight_start":1,"highlight_end":57},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\loom_of_fate\\elf_loader.rs","byte_start":15205,"byte_end":15212,"line_start":489,"line_end":489,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\loom_of_fate\\elf_loader.rs:490:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m489\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m490\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_invalid_magic() {\n\u001b[1m\u001b[96m491\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let data = [0u8; size_of::<Elf64Ehdr>()];\n\u001b[1m\u001b[96m492\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let result = parse_elf_header(&data);\n\u001b[1m\u001b[96m493\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(result, Err(ElfError::InvalidMagic));\n\u001b[1m\u001b[96m494\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\capability.rs","byte_start":9032,"byte_end":9840,"line_start":294,"line_end":309,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_wx_validation() {","highlight_start":5,"highlight_end":30},{"text":"        // Valid combinations","highlight_start":1,"highlight_end":30},{"text":"        assert!(CapabilityRights::READ.validate_wx());","highlight_start":1,"highlight_end":55},{"text":"        assert!(CapabilityRights::read_only().validate_wx());","highlight_start":1,"highlight_end":62},{"text":"        assert!(CapabilityRights::read_write().validate_wx());","highlight_start":1,"highlight_end":63},{"text":"        assert!(CapabilityRights::read_execute().validate_wx());","highlight_start":1,"highlight_end":65},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // INVALID: Write + Execute","highlight_start":1,"highlight_end":36},{"text":"        let write_execute = CapabilityRights::WRITE | CapabilityRights::EXECUTE;","highlight_start":1,"highlight_end":81},{"text":"        assert!(!write_execute.validate_wx(), \"W+X should be rejected!\");","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // INVALID: Full rights including execute","highlight_start":1,"highlight_end":50},{"text":"        let all_rights = CapabilityRights::READ | CapabilityRights::WRITE |","highlight_start":1,"highlight_end":76},{"text":"                        CapabilityRights::EXECUTE | CapabilityRights::TRANSFER;","highlight_start":1,"highlight_end":80},{"text":"        assert!(!all_rights.validate_wx(), \"Full rights with W+X should be rejected!\");","highlight_start":1,"highlight_end":88},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\capability.rs","byte_start":9019,"byte_end":9026,"line_start":293,"line_end":293,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\capability.rs:294:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m293\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m294\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_wx_validation() {\n\u001b[1m\u001b[96m295\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         // Valid combinations\n\u001b[1m\u001b[96m296\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(CapabilityRights::READ.validate_wx());\n\u001b[1m\u001b[96m297\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(CapabilityRights::read_only().validate_wx());\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m308\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(!all_rights.validate_wx(), \"Full rights with W+X should be rejected!\");\n\u001b[1m\u001b[96m309\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\capability.rs","byte_start":9861,"byte_end":10199,"line_start":312,"line_end":318,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_safe_combinations() {","highlight_start":5,"highlight_end":34},{"text":"        // These should all be safe","highlight_start":1,"highlight_end":36},{"text":"        assert!(CapabilityRights::read_only().validate_wx());","highlight_start":1,"highlight_end":62},{"text":"        assert!(CapabilityRights::read_write().validate_wx());","highlight_start":1,"highlight_end":63},{"text":"        assert!(CapabilityRights::read_execute().validate_wx());","highlight_start":1,"highlight_end":65},{"text":"        assert!(CapabilityRights::code_with_transfer().validate_wx());","highlight_start":1,"highlight_end":71},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\capability.rs","byte_start":9848,"byte_end":9855,"line_start":311,"line_end":311,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\capability.rs:312:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m311\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m312\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_safe_combinations() {\n\u001b[1m\u001b[96m313\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         // These should all be safe\n\u001b[1m\u001b[96m314\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(CapabilityRights::read_only().validate_wx());\n\u001b[1m\u001b[96m315\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(CapabilityRights::read_write().validate_wx());\n\u001b[1m\u001b[96m316\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(CapabilityRights::read_execute().validate_wx());\n\u001b[1m\u001b[96m317\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(CapabilityRights::code_with_transfer().validate_wx());\n\u001b[1m\u001b[96m318\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\capability_table.rs","byte_start":7491,"byte_end":7964,"line_start":227,"line_end":239,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_insert_and_lookup() {","highlight_start":5,"highlight_end":34},{"text":"        let mut table = CapabilityTable::new();","highlight_start":1,"highlight_end":48},{"text":"        let handle = ObjectHandle(0x1000);","highlight_start":1,"highlight_end":43},{"text":"        let rights = CapabilityRights::READ;","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let cap = SealedCapability::new(handle, rights);","highlight_start":1,"highlight_end":57},{"text":"        let cap_id = table.insert(cap).unwrap();","highlight_start":1,"highlight_end":49},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Should be able to retrieve","highlight_start":1,"highlight_end":38},{"text":"        let retrieved = table.get(cap_id).unwrap();","highlight_start":1,"highlight_end":52},{"text":"        assert_eq!(retrieved.handle, handle);","highlight_start":1,"highlight_end":46},{"text":"        assert_eq!(retrieved.rights, rights);","highlight_start":1,"highlight_end":46},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\capability_table.rs","byte_start":7478,"byte_end":7485,"line_start":226,"line_end":226,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\capability_table.rs:227:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m226\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m227\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_insert_and_lookup() {\n\u001b[1m\u001b[96m228\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let mut table = CapabilityTable::new();\n\u001b[1m\u001b[96m229\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let handle = ObjectHandle(0x1000);\n\u001b[1m\u001b[96m230\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let rights = CapabilityRights::READ;\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m238\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(retrieved.rights, rights);\n\u001b[1m\u001b[96m239\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\capability_table.rs","byte_start":7985,"byte_end":8231,"line_start":242,"line_end":248,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_invalid_id() {","highlight_start":5,"highlight_end":27},{"text":"        let table = CapabilityTable::new();","highlight_start":1,"highlight_end":44},{"text":"        let invalid_id = CapabilityId::new(9999);","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Should fail - ID not in table","highlight_start":1,"highlight_end":41},{"text":"        assert_eq!(table.get(invalid_id), Err(CapabilityError::InvalidId));","highlight_start":1,"highlight_end":76},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\capability_table.rs","byte_start":7972,"byte_end":7979,"line_start":241,"line_end":241,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\capability_table.rs:242:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m241\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m242\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_invalid_id() {\n\u001b[1m\u001b[96m243\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let table = CapabilityTable::new();\n\u001b[1m\u001b[96m244\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let invalid_id = CapabilityId::new(9999);\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m247\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(table.get(invalid_id), Err(CapabilityError::InvalidId));\n\u001b[1m\u001b[96m248\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\capability_table.rs","byte_start":8252,"byte_end":8848,"line_start":251,"line_end":267,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_rights_check() {","highlight_start":5,"highlight_end":29},{"text":"        let mut table = CapabilityTable::new();","highlight_start":1,"highlight_end":48},{"text":"        let handle = ObjectHandle(0x1000);","highlight_start":1,"highlight_end":43},{"text":"        let rights = CapabilityRights::READ;","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let cap = SealedCapability::new(handle, rights);","highlight_start":1,"highlight_end":57},{"text":"        let cap_id = table.insert(cap).unwrap();","highlight_start":1,"highlight_end":49},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Should succeed - has READ","highlight_start":1,"highlight_end":37},{"text":"        assert!(table.check_rights(cap_id, CapabilityRights::READ).is_ok());","highlight_start":1,"highlight_end":77},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Should fail - doesn't have WRITE","highlight_start":1,"highlight_end":44},{"text":"        assert_eq!(","highlight_start":1,"highlight_end":20},{"text":"            table.check_rights(cap_id, CapabilityRights::WRITE),","highlight_start":1,"highlight_end":65},{"text":"            Err(CapabilityError::PermissionDenied)","highlight_start":1,"highlight_end":51},{"text":"        );","highlight_start":1,"highlight_end":11},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\capability_table.rs","byte_start":8239,"byte_end":8246,"line_start":250,"line_end":250,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\capability_table.rs:251:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m250\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m251\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_rights_check() {\n\u001b[1m\u001b[96m252\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let mut table = CapabilityTable::new();\n\u001b[1m\u001b[96m253\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let handle = ObjectHandle(0x1000);\n\u001b[1m\u001b[96m254\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let rights = CapabilityRights::READ;\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m266\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         );\n\u001b[1m\u001b[96m267\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\capability_table.rs","byte_start":8869,"byte_end":9558,"line_start":270,"line_end":285,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_derive_attenuation() {","highlight_start":5,"highlight_end":35},{"text":"        let mut table = CapabilityTable::new();","highlight_start":1,"highlight_end":48},{"text":"        let handle = ObjectHandle(0x1000);","highlight_start":1,"highlight_end":43},{"text":"        let parent_rights = CapabilityRights::READ | CapabilityRights::WRITE;","highlight_start":1,"highlight_end":78},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let parent = SealedCapability::new(handle, parent_rights);","highlight_start":1,"highlight_end":67},{"text":"        let parent_id = table.insert(parent).unwrap();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Derive read-only capability","highlight_start":1,"highlight_end":39},{"text":"        let child_id = table.derive(parent_id, CapabilityRights::READ).unwrap();","highlight_start":1,"highlight_end":81},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Child should have reduced rights","highlight_start":1,"highlight_end":44},{"text":"        let child = table.get(child_id).unwrap();","highlight_start":1,"highlight_end":50},{"text":"        assert!(child.rights.contains(CapabilityRights::READ));","highlight_start":1,"highlight_end":64},{"text":"        assert!(!child.rights.contains(CapabilityRights::WRITE));","highlight_start":1,"highlight_end":66},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\capability_table.rs","byte_start":8856,"byte_end":8863,"line_start":269,"line_end":269,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\capability_table.rs:270:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m269\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m270\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_derive_attenuation() {\n\u001b[1m\u001b[96m271\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let mut table = CapabilityTable::new();\n\u001b[1m\u001b[96m272\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let handle = ObjectHandle(0x1000);\n\u001b[1m\u001b[96m273\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let parent_rights = CapabilityRights::READ | CapabilityRights::WRITE;\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m284\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(!child.rights.contains(CapabilityRights::WRITE));\n\u001b[1m\u001b[96m285\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\capability_table.rs","byte_start":9636,"byte_end":10106,"line_start":289,"line_end":299,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_derive_amplification_panics() {","highlight_start":5,"highlight_end":44},{"text":"        let mut table = CapabilityTable::new();","highlight_start":1,"highlight_end":48},{"text":"        let handle = ObjectHandle(0x1000);","highlight_start":1,"highlight_end":43},{"text":"        let parent_rights = CapabilityRights::READ;","highlight_start":1,"highlight_end":52},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let parent = SealedCapability::new(handle, parent_rights);","highlight_start":1,"highlight_end":67},{"text":"        let parent_id = table.insert(parent).unwrap();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Try to derive with MORE rights (should panic)","highlight_start":1,"highlight_end":57},{"text":"        let _ = table.derive(parent_id, CapabilityRights::READ | CapabilityRights::WRITE);","highlight_start":1,"highlight_end":91},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\capability_table.rs","byte_start":9566,"byte_end":9573,"line_start":287,"line_end":287,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\capability_table.rs:289:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m287\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m288\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[should_panic(expected = \"Cannot amplify rights\")]\n\u001b[1m\u001b[96m289\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_derive_amplification_panics() {\n\u001b[1m\u001b[96m290\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let mut table = CapabilityTable::new();\n\u001b[1m\u001b[96m291\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let handle = ObjectHandle(0x1000);\n\u001b[1m\u001b[96m292\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let parent_rights = CapabilityRights::READ;\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m298\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let _ = table.derive(parent_id, CapabilityRights::READ | CapabilityRights::WRITE);\n\u001b[1m\u001b[96m299\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\capability_table.rs","byte_start":10127,"byte_end":10658,"line_start":302,"line_end":317,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_revocation() {","highlight_start":5,"highlight_end":27},{"text":"        let mut table = CapabilityTable::new();","highlight_start":1,"highlight_end":48},{"text":"        let handle = ObjectHandle(0x1000);","highlight_start":1,"highlight_end":43},{"text":"        let cap = SealedCapability::new(handle, CapabilityRights::READ);","highlight_start":1,"highlight_end":73},{"text":"        let cap_id = table.insert(cap).unwrap();","highlight_start":1,"highlight_end":49},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Should exist","highlight_start":1,"highlight_end":24},{"text":"        assert!(table.get(cap_id).is_ok());","highlight_start":1,"highlight_end":44},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Revoke","highlight_start":1,"highlight_end":18},{"text":"        let removed = table.remove(cap_id);","highlight_start":1,"highlight_end":44},{"text":"        assert!(removed.is_some());","highlight_start":1,"highlight_end":36},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Should no longer exist","highlight_start":1,"highlight_end":34},{"text":"        assert_eq!(table.get(cap_id), Err(CapabilityError::InvalidId));","highlight_start":1,"highlight_end":72},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\capability_table.rs","byte_start":10114,"byte_end":10121,"line_start":301,"line_end":301,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\capability_table.rs:302:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m301\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m302\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_revocation() {\n\u001b[1m\u001b[96m303\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let mut table = CapabilityTable::new();\n\u001b[1m\u001b[96m304\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let handle = ObjectHandle(0x1000);\n\u001b[1m\u001b[96m305\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let cap = SealedCapability::new(handle, CapabilityRights::READ);\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m316\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(table.get(cap_id), Err(CapabilityError::InvalidId));\n\u001b[1m\u001b[96m317\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\capability_table.rs","byte_start":10679,"byte_end":11221,"line_start":320,"line_end":333,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_table_full() {","highlight_start":5,"highlight_end":27},{"text":"        let mut table = CapabilityTable::new();","highlight_start":1,"highlight_end":48},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Fill table to capacity","highlight_start":1,"highlight_end":34},{"text":"        for i in 0..MAX_CAPABILITIES {","highlight_start":1,"highlight_end":39},{"text":"            let handle = ObjectHandle(i as u64);","highlight_start":1,"highlight_end":49},{"text":"            let cap = SealedCapability::new(handle, CapabilityRights::READ);","highlight_start":1,"highlight_end":77},{"text":"            assert!(table.insert(cap).is_ok());","highlight_start":1,"highlight_end":48},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Next insert should fail","highlight_start":1,"highlight_end":35},{"text":"        let cap = SealedCapability::new(ObjectHandle(0xFFFF), CapabilityRights::READ);","highlight_start":1,"highlight_end":87},{"text":"        assert_eq!(table.insert(cap), Err(CapabilityError::TableFull));","highlight_start":1,"highlight_end":72},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\capability_table.rs","byte_start":10666,"byte_end":10673,"line_start":319,"line_end":319,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\capability_table.rs:320:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m319\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m320\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_table_full() {\n\u001b[1m\u001b[96m321\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let mut table = CapabilityTable::new();\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m332\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(table.insert(cap), Err(CapabilityError::TableFull));\n\u001b[1m\u001b[96m333\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\interrupt_lock.rs","byte_start":10237,"byte_end":10473,"line_start":293,"line_end":300,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_lock_basic() {","highlight_start":5,"highlight_end":27},{"text":"        let lock = InterruptSafeLock::new(42, \"TEST\");","highlight_start":1,"highlight_end":55},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            let guard = lock.lock();","highlight_start":1,"highlight_end":37},{"text":"            assert_eq!(*guard, 42);","highlight_start":1,"highlight_end":36},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        // Lock should be released after guard drops","highlight_start":1,"highlight_end":53},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\interrupt_lock.rs","byte_start":10224,"byte_end":10231,"line_start":292,"line_end":292,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\interrupt_lock.rs:293:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m292\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m293\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_lock_basic() {\n\u001b[1m\u001b[96m294\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let lock = InterruptSafeLock::new(42, \"TEST\");\n\u001b[1m\u001b[96m295\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         {\n\u001b[1m\u001b[96m296\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             let guard = lock.lock();\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m300\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\buddy.rs","byte_start":18261,"byte_end":18800,"line_start":529,"line_end":538,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_size_to_order() {","highlight_start":5,"highlight_end":30},{"text":"        let allocator = BuddyAllocator::new();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // MIN_BLOCK_SIZE = 64","highlight_start":1,"highlight_end":31},{"text":"        assert_eq!(allocator.size_to_order(1), 0);    // 1 byte -> order 0 (64 bytes)","highlight_start":1,"highlight_end":86},{"text":"        assert_eq!(allocator.size_to_order(64), 0);   // 64 bytes -> order 0","highlight_start":1,"highlight_end":77},{"text":"        assert_eq!(allocator.size_to_order(65), 1);   // 65 bytes -> order 1 (128 bytes)","highlight_start":1,"highlight_end":89},{"text":"        assert_eq!(allocator.size_to_order(128), 1);  // 128 bytes -> order 1","highlight_start":1,"highlight_end":78},{"text":"        assert_eq!(allocator.size_to_order(129), 2);  // 129 bytes -> order 2 (256 bytes)","highlight_start":1,"highlight_end":90},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\buddy.rs","byte_start":18248,"byte_end":18255,"line_start":528,"line_end":528,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\buddy.rs:529:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m528\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m529\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_size_to_order() {\n\u001b[1m\u001b[96m530\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let allocator = BuddyAllocator::new();\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m537\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(allocator.size_to_order(129), 2);  // 129 bytes -> order 2 (256 bytes)\n\u001b[1m\u001b[96m538\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\buddy.rs","byte_start":18821,"byte_end":19187,"line_start":541,"line_end":548,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_order_to_size() {","highlight_start":5,"highlight_end":30},{"text":"        let allocator = BuddyAllocator::new();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        assert_eq!(allocator.order_to_size(0), 64);     // 64 * 2^0","highlight_start":1,"highlight_end":68},{"text":"        assert_eq!(allocator.order_to_size(1), 128);    // 64 * 2^1","highlight_start":1,"highlight_end":68},{"text":"        assert_eq!(allocator.order_to_size(2), 256);    // 64 * 2^2","highlight_start":1,"highlight_end":68},{"text":"        assert_eq!(allocator.order_to_size(10), 65536); // 64 * 2^10 = 64KB","highlight_start":1,"highlight_end":76},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\buddy.rs","byte_start":18808,"byte_end":18815,"line_start":540,"line_end":540,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\buddy.rs:541:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m540\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m541\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_order_to_size() {\n\u001b[1m\u001b[96m542\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let allocator = BuddyAllocator::new();\n\u001b[1m\u001b[96m543\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m544\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(allocator.order_to_size(0), 64);     // 64 * 2^0\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m547\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(allocator.order_to_size(10), 65536); // 64 * 2^10 = 64KB\n\u001b[1m\u001b[96m548\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\buddy.rs","byte_start":19208,"byte_end":19549,"line_start":551,"line_end":559,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_buddy_address() {","highlight_start":5,"highlight_end":30},{"text":"        let allocator = BuddyAllocator::new();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // For order 0 (64 bytes), buddies differ by 64","highlight_start":1,"highlight_end":56},{"text":"        assert_eq!(allocator.buddy_address(0x1000, 0), 0x1000 ^ 64);","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // For order 1 (128 bytes), buddies differ by 128","highlight_start":1,"highlight_end":58},{"text":"        assert_eq!(allocator.buddy_address(0x1000, 1), 0x1000 ^ 128);","highlight_start":1,"highlight_end":70},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\buddy.rs","byte_start":19195,"byte_end":19202,"line_start":550,"line_end":550,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\buddy.rs:551:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m550\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m551\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_buddy_address() {\n\u001b[1m\u001b[96m552\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let allocator = BuddyAllocator::new();\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m558\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(allocator.buddy_address(0x1000, 1), 0x1000 ^ 128);\n\u001b[1m\u001b[96m559\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\entropy.rs","byte_start":6873,"byte_end":7090,"line_start":213,"line_end":218,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_hardware_rng() {","highlight_start":5,"highlight_end":29},{"text":"        let val1 = HardwareRng::u64();","highlight_start":1,"highlight_end":39},{"text":"        let val2 = HardwareRng::u64();","highlight_start":1,"highlight_end":39},{"text":"        // Should be different (probability of collision is negligible)","highlight_start":1,"highlight_end":72},{"text":"        assert_ne!(val1, val2);","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\entropy.rs","byte_start":6860,"byte_end":6867,"line_start":212,"line_end":212,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\entropy.rs:213:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m212\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m213\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_hardware_rng() {\n\u001b[1m\u001b[96m214\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let val1 = HardwareRng::u64();\n\u001b[1m\u001b[96m215\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let val2 = HardwareRng::u64();\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m218\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\entropy.rs","byte_start":7111,"byte_end":7409,"line_start":221,"line_end":229,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_chacha8_deterministic() {","highlight_start":5,"highlight_end":38},{"text":"        let mut rng1 = ChaCha8Rng::from_seed(12345);","highlight_start":1,"highlight_end":53},{"text":"        let mut rng2 = ChaCha8Rng::from_seed(12345);","highlight_start":1,"highlight_end":53},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Same seed should produce same sequence","highlight_start":1,"highlight_end":50},{"text":"        for _ in 0..100 {","highlight_start":1,"highlight_end":26},{"text":"            assert_eq!(rng1.next_u64(), rng2.next_u64());","highlight_start":1,"highlight_end":58},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\entropy.rs","byte_start":7098,"byte_end":7105,"line_start":220,"line_end":220,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\entropy.rs:221:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m220\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m221\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_chacha8_deterministic() {\n\u001b[1m\u001b[96m222\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let mut rng1 = ChaCha8Rng::from_seed(12345);\n\u001b[1m\u001b[96m223\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let mut rng2 = ChaCha8Rng::from_seed(12345);\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m229\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\entropy.rs","byte_start":7430,"byte_end":7697,"line_start":232,"line_end":238,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_chacha8_different_seeds() {","highlight_start":5,"highlight_end":40},{"text":"        let mut rng1 = ChaCha8Rng::from_seed(12345);","highlight_start":1,"highlight_end":53},{"text":"        let mut rng2 = ChaCha8Rng::from_seed(54321);","highlight_start":1,"highlight_end":53},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Different seeds should produce different values","highlight_start":1,"highlight_end":59},{"text":"        assert_ne!(rng1.next_u64(), rng2.next_u64());","highlight_start":1,"highlight_end":54},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\entropy.rs","byte_start":7417,"byte_end":7424,"line_start":231,"line_end":231,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\entropy.rs:232:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m231\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m232\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_chacha8_different_seeds() {\n\u001b[1m\u001b[96m233\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let mut rng1 = ChaCha8Rng::from_seed(12345);\n\u001b[1m\u001b[96m234\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let mut rng2 = ChaCha8Rng::from_seed(54321);\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m237\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_ne!(rng1.next_u64(), rng2.next_u64());\n\u001b[1m\u001b[96m238\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\entropy.rs","byte_start":7718,"byte_end":7923,"line_start":241,"line_end":248,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_range() {","highlight_start":5,"highlight_end":22},{"text":"        let mut rng = ChaCha8Rng::from_seed(42);","highlight_start":1,"highlight_end":49},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        for _ in 0..100 {","highlight_start":1,"highlight_end":26},{"text":"            let val = rng.range(100, 200);","highlight_start":1,"highlight_end":43},{"text":"            assert!(val >= 100 && val < 200);","highlight_start":1,"highlight_end":46},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\entropy.rs","byte_start":7705,"byte_end":7712,"line_start":240,"line_end":240,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\entropy.rs:241:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m240\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m241\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_range() {\n\u001b[1m\u001b[96m242\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let mut rng = ChaCha8Rng::from_seed(42);\n\u001b[1m\u001b[96m243\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m244\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         for _ in 0..100 {\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m248\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":6070,"byte_end":6074,"line_start":283,"line_end":283,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:283:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m283\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\aslr.rs","byte_start":6889,"byte_end":7232,"line_start":204,"line_end":211,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_randomized_layouts_differ() {","highlight_start":5,"highlight_end":42},{"text":"        let layout1 = RandomizedLayout::new();","highlight_start":1,"highlight_end":47},{"text":"        let layout2 = RandomizedLayout::new();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Layouts should be different (probability of collision is negligible)","highlight_start":1,"highlight_end":80},{"text":"        assert_ne!(layout1.code_base, layout2.code_base);","highlight_start":1,"highlight_end":58},{"text":"        assert_ne!(layout1.stack_base, layout2.stack_base);","highlight_start":1,"highlight_end":60},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\aslr.rs","byte_start":6876,"byte_end":6883,"line_start":203,"line_end":203,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\aslr.rs:204:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m203\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m204\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_randomized_layouts_differ() {\n\u001b[1m\u001b[96m205\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let layout1 = RandomizedLayout::new();\n\u001b[1m\u001b[96m206\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let layout2 = RandomizedLayout::new();\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m210\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_ne!(layout1.stack_base, layout2.stack_base);\n\u001b[1m\u001b[96m211\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\aslr.rs","byte_start":7253,"byte_end":7701,"line_start":214,"line_end":227,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_code_base_in_valid_range() {","highlight_start":5,"highlight_end":41},{"text":"        let mut rng = ChaCha8Rng::from_seed(42);","highlight_start":1,"highlight_end":49},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        for _ in 0..100 {","highlight_start":1,"highlight_end":26},{"text":"            let layout = RandomizedLayout::from_rng(&mut rng);","highlight_start":1,"highlight_end":63},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Code should be in valid range","highlight_start":1,"highlight_end":45},{"text":"            assert!(layout.code_base >= 0x00400000);","highlight_start":1,"highlight_end":53},{"text":"            assert!(layout.code_base < 0x01400000);","highlight_start":1,"highlight_end":52},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Should be page-aligned","highlight_start":1,"highlight_end":38},{"text":"            assert_eq!(layout.code_base % 0x1000, 0);","highlight_start":1,"highlight_end":54},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\aslr.rs","byte_start":7240,"byte_end":7247,"line_start":213,"line_end":213,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\aslr.rs:214:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m213\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m214\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_code_base_in_valid_range() {\n\u001b[1m\u001b[96m215\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let mut rng = ChaCha8Rng::from_seed(42);\n\u001b[1m\u001b[96m216\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m217\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         for _ in 0..100 {\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m227\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\aslr.rs","byte_start":7722,"byte_end":8175,"line_start":230,"line_end":243,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_stack_base_in_valid_range() {","highlight_start":5,"highlight_end":42},{"text":"        let mut rng = ChaCha8Rng::from_seed(42);","highlight_start":1,"highlight_end":49},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        for _ in 0..100 {","highlight_start":1,"highlight_end":26},{"text":"            let layout = RandomizedLayout::from_rng(&mut rng);","highlight_start":1,"highlight_end":63},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Stack should be in valid range","highlight_start":1,"highlight_end":46},{"text":"            assert!(layout.stack_base >= 0x70000000);","highlight_start":1,"highlight_end":54},{"text":"            assert!(layout.stack_base < 0x80000000);","highlight_start":1,"highlight_end":53},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Should be page-aligned","highlight_start":1,"highlight_end":38},{"text":"            assert_eq!(layout.stack_base % 0x1000, 0);","highlight_start":1,"highlight_end":55},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\aslr.rs","byte_start":7709,"byte_end":7716,"line_start":229,"line_end":229,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\aslr.rs:230:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m229\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m230\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_stack_base_in_valid_range() {\n\u001b[1m\u001b[96m231\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let mut rng = ChaCha8Rng::from_seed(42);\n\u001b[1m\u001b[96m232\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m233\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         for _ in 0..100 {\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m243\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\aslr.rs","byte_start":8196,"byte_end":8444,"line_start":246,"line_end":252,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_deterministic_layout() {","highlight_start":5,"highlight_end":37},{"text":"        let layout = AslrManager::deterministic_layout();","highlight_start":1,"highlight_end":58},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        assert_eq!(layout.code_base, 0x00400000);","highlight_start":1,"highlight_end":50},{"text":"        assert_eq!(layout.stack_base, 0x70000000);","highlight_start":1,"highlight_end":51},{"text":"        assert_eq!(layout.entropy_bits, 0);","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\aslr.rs","byte_start":8183,"byte_end":8190,"line_start":245,"line_end":245,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\aslr.rs:246:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m245\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m246\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_deterministic_layout() {\n\u001b[1m\u001b[96m247\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let layout = AslrManager::deterministic_layout();\n\u001b[1m\u001b[96m248\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m249\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(layout.code_base, 0x00400000);\n\u001b[1m\u001b[96m250\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(layout.stack_base, 0x70000000);\n\u001b[1m\u001b[96m251\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(layout.entropy_bits, 0);\n\u001b[1m\u001b[96m252\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\aslr.rs","byte_start":8465,"byte_end":8796,"line_start":255,"line_end":265,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_aslr_manager_toggle() {","highlight_start":5,"highlight_end":36},{"text":"        let mut manager = AslrManager::new();","highlight_start":1,"highlight_end":46},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        assert!(manager.is_enabled());","highlight_start":1,"highlight_end":39},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        manager.set_enabled(false);","highlight_start":1,"highlight_end":36},{"text":"        assert!(!manager.is_enabled());","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let layout = manager.generate_layout();","highlight_start":1,"highlight_end":48},{"text":"        assert_eq!(layout.entropy_bits, 0);  // Should be deterministic","highlight_start":1,"highlight_end":72},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\aslr.rs","byte_start":8452,"byte_end":8459,"line_start":254,"line_end":254,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\aslr.rs:255:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m254\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m255\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_aslr_manager_toggle() {\n\u001b[1m\u001b[96m256\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let mut manager = AslrManager::new();\n\u001b[1m\u001b[96m257\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m258\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(manager.is_enabled());\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m264\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(layout.entropy_bits, 0);  // Should be deterministic\n\u001b[1m\u001b[96m265\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\sealing.rs","byte_start":4270,"byte_end":4568,"line_start":126,"line_end":135,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_seal_generation() {","highlight_start":5,"highlight_end":32},{"text":"        let sealer = CapabilitySealer::new();","highlight_start":1,"highlight_end":46},{"text":"        let data = b\"test capability data\";","highlight_start":1,"highlight_end":44},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let seal = sealer.seal(data);","highlight_start":1,"highlight_end":38},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Seal should be deterministic for same data","highlight_start":1,"highlight_end":54},{"text":"        let seal2 = sealer.seal(data);","highlight_start":1,"highlight_end":39},{"text":"        assert_eq!(seal, seal2);","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\sealing.rs","byte_start":4257,"byte_end":4264,"line_start":125,"line_end":125,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\sealing.rs:126:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m125\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m126\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_seal_generation() {\n\u001b[1m\u001b[96m127\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let sealer = CapabilitySealer::new();\n\u001b[1m\u001b[96m128\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let data = b\"test capability data\";\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m134\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(seal, seal2);\n\u001b[1m\u001b[96m135\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":5894,"byte_end":5898,"line_start":274,"line_end":274,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:274:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m274\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\sealing.rs","byte_start":4589,"byte_end":4843,"line_start":138,"line_end":146,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_seal_verification() {","highlight_start":5,"highlight_end":34},{"text":"        let sealer = CapabilitySealer::new();","highlight_start":1,"highlight_end":46},{"text":"        let data = b\"test capability data\";","highlight_start":1,"highlight_end":44},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let seal = sealer.seal(data);","highlight_start":1,"highlight_end":38},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Valid seal should verify","highlight_start":1,"highlight_end":36},{"text":"        assert!(sealer.verify(data, &seal));","highlight_start":1,"highlight_end":45},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\sealing.rs","byte_start":4576,"byte_end":4583,"line_start":137,"line_end":137,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\sealing.rs:138:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m137\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m138\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_seal_verification() {\n\u001b[1m\u001b[96m139\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let sealer = CapabilitySealer::new();\n\u001b[1m\u001b[96m140\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let data = b\"test capability data\";\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m145\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(sealer.verify(data, &seal));\n\u001b[1m\u001b[96m146\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\sealing.rs","byte_start":4864,"byte_end":5192,"line_start":149,"line_end":158,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_tampered_data_fails() {","highlight_start":5,"highlight_end":36},{"text":"        let sealer = CapabilitySealer::new();","highlight_start":1,"highlight_end":46},{"text":"        let data = b\"test capability data\";","highlight_start":1,"highlight_end":44},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let seal = sealer.seal(data);","highlight_start":1,"highlight_end":38},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Modified data should fail","highlight_start":1,"highlight_end":37},{"text":"        let tampered = b\"test capability DATA\";  // Changed case","highlight_start":1,"highlight_end":65},{"text":"        assert!(!sealer.verify(tampered, &seal));","highlight_start":1,"highlight_end":50},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\sealing.rs","byte_start":4851,"byte_end":4858,"line_start":148,"line_end":148,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\sealing.rs:149:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m148\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m149\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_tampered_data_fails() {\n\u001b[1m\u001b[96m150\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let sealer = CapabilitySealer::new();\n\u001b[1m\u001b[96m151\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let data = b\"test capability data\";\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m157\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(!sealer.verify(tampered, &seal));\n\u001b[1m\u001b[96m158\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\sealing.rs","byte_start":5213,"byte_end":5533,"line_start":161,"line_end":172,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_tampered_seal_fails() {","highlight_start":5,"highlight_end":36},{"text":"        let sealer = CapabilitySealer::new();","highlight_start":1,"highlight_end":46},{"text":"        let data = b\"test capability data\";","highlight_start":1,"highlight_end":44},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let seal = sealer.seal(data);","highlight_start":1,"highlight_end":38},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Flip one bit in seal","highlight_start":1,"highlight_end":32},{"text":"        let mut bad_seal = seal;","highlight_start":1,"highlight_end":33},{"text":"        bad_seal[0] ^= 1;","highlight_start":1,"highlight_end":26},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        assert!(!sealer.verify(data, &bad_seal));","highlight_start":1,"highlight_end":50},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\sealing.rs","byte_start":5200,"byte_end":5207,"line_start":160,"line_end":160,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\sealing.rs:161:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m160\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m161\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_tampered_seal_fails() {\n\u001b[1m\u001b[96m162\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let sealer = CapabilitySealer::new();\n\u001b[1m\u001b[96m163\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let data = b\"test capability data\";\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m171\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(!sealer.verify(data, &bad_seal));\n\u001b[1m\u001b[96m172\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\sealing.rs","byte_start":5554,"byte_end":5967,"line_start":175,"line_end":186,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_different_keys_different_seals() {","highlight_start":5,"highlight_end":47},{"text":"        let sealer1 = CapabilitySealer::new();","highlight_start":1,"highlight_end":47},{"text":"        let sealer2 = CapabilitySealer::new();","highlight_start":1,"highlight_end":47},{"text":"        let data = b\"test capability data\";","highlight_start":1,"highlight_end":44},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let seal1 = sealer1.seal(data);","highlight_start":1,"highlight_end":40},{"text":"        let seal2 = sealer2.seal(data);","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Different keys should produce different seals","highlight_start":1,"highlight_end":57},{"text":"        // (With overwhelming probability)","highlight_start":1,"highlight_end":43},{"text":"        assert_ne!(seal1, seal2);","highlight_start":1,"highlight_end":34},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\sealing.rs","byte_start":5541,"byte_end":5548,"line_start":174,"line_end":174,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\sealing.rs:175:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m174\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m175\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_different_keys_different_seals() {\n\u001b[1m\u001b[96m176\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let sealer1 = CapabilitySealer::new();\n\u001b[1m\u001b[96m177\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let sealer2 = CapabilitySealer::new();\n\u001b[1m\u001b[96m178\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let data = b\"test capability data\";\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m185\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_ne!(seal1, seal2);\n\u001b[1m\u001b[96m186\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\sealing.rs","byte_start":5988,"byte_end":6508,"line_start":189,"line_end":203,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_constant_time_compare() {","highlight_start":5,"highlight_end":38},{"text":"        let a = [0u8; 32];","highlight_start":1,"highlight_end":27},{"text":"        let b = [0u8; 32];","highlight_start":1,"highlight_end":27},{"text":"        let mut c = [0u8; 32];","highlight_start":1,"highlight_end":31},{"text":"        c[0] = 1;  // Differ in first byte","highlight_start":1,"highlight_end":43},{"text":"        let mut d = [0u8; 32];","highlight_start":1,"highlight_end":31},{"text":"        d[31] = 1;  // Differ in last byte","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        assert!(constant_time_compare(&a, &b));","highlight_start":1,"highlight_end":48},{"text":"        assert!(!constant_time_compare(&a, &c));","highlight_start":1,"highlight_end":49},{"text":"        assert!(!constant_time_compare(&a, &d));","highlight_start":1,"highlight_end":49},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // All comparisons should take same time (not verifiable in test,","highlight_start":1,"highlight_end":74},{"text":"        // but at least check correctness)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\sealing.rs","byte_start":5975,"byte_end":5982,"line_start":188,"line_end":188,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\sealing.rs:189:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m188\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m189\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_constant_time_compare() {\n\u001b[1m\u001b[96m190\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let a = [0u8; 32];\n\u001b[1m\u001b[96m191\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let b = [0u8; 32];\n\u001b[1m\u001b[96m192\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let mut c = [0u8; 32];\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m203\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":5500,"byte_end":5504,"line_start":259,"line_end":259,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:259:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m259\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/world-tree_grove#0.1.0","manifest_path":"F:\\OS\\groves\\world-tree_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"world_tree_grove","src_path":"F:\\OS\\groves\\world-tree_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `essence`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"groves\\world-tree_grove\\src\\lib.rs","byte_start":2470,"byte_end":2481,"line_start":102,"line_end":102,"column_start":29,"column_end":40,"is_primary":true,"text":[{"text":"                if let Some(ref essence) = query.essence {","highlight_start":29,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"groves\\world-tree_grove\\src\\lib.rs","byte_start":2470,"byte_end":2481,"line_start":102,"line_end":102,"column_start":29,"column_end":40,"is_primary":true,"text":[{"text":"                if let Some(ref essence) = query.essence {","highlight_start":29,"highlight_end":40}],"label":null,"suggested_replacement":"_essence","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `essence`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\world-tree_grove\\src\\lib.rs:102:29\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m102\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 if let Some(ref essence) = query.essence {\n    \u001b[1m\u001b[96m|\u001b[0m                             \u001b[1m\u001b[93m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_essence`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-artifact","package_id":"path+file:///F:/OS/groves/world-tree_grove#0.1.0","manifest_path":"F:\\OS\\groves\\world-tree_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"world_tree_grove","src_path":"F:\\OS\\groves\\world-tree_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libworld_tree_grove-75748ff6b70f4509.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-artifact","package_id":"path+file:///F:/OS/awakening/heartwood_loader#0.1.0","manifest_path":"F:\\OS\\awakening\\heartwood_loader\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"heartwood_loader","src_path":"F:\\OS\\awakening\\heartwood_loader\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libheartwood_loader-abbd72f746d7b39b.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":5680,"byte_end":5689,"line_start":267,"line_end":267,"column_start":13,"column_end":22,"is_primary":true,"text":[{"text":"            assert_eq!(map.get(\"name\"), Some(&Value::Text(\"Elara\".to_string())));","highlight_start":13,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:267:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m267\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             assert_eq!(map.get(\"name\"), Some(&Value::Text(\"Elara\".to_string())));\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":5762,"byte_end":5771,"line_start":268,"line_end":268,"column_start":13,"column_end":22,"is_primary":true,"text":[{"text":"            assert_eq!(map.get(\"age\"), Some(&Value::Number(42.0)));","highlight_start":13,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:268:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m268\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             assert_eq!(map.get(\"age\"), Some(&Value::Number(42.0)));\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\concordance_of_fates.rs","byte_start":24004,"byte_end":24574,"line_start":743,"line_end":759,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_fate_creation() {","highlight_start":5,"highlight_end":30},{"text":"        let mut concordance = Concordance::new();","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let fate = Fate {","highlight_start":1,"highlight_end":26},{"text":"            name: String::from(\"TestFate\"),","highlight_start":1,"highlight_end":44},{"text":"            description: String::from(\"A test fate\"),","highlight_start":1,"highlight_end":54},{"text":"            capabilities: FateCapabilities::default(),","highlight_start":1,"highlight_end":55},{"text":"            file_rules: vec![],","highlight_start":1,"highlight_end":32},{"text":"            network_rules: vec![],","highlight_start":1,"highlight_end":35},{"text":"            memory_rules: vec![],","highlight_start":1,"highlight_end":34},{"text":"            allowed_transitions: vec![],","highlight_start":1,"highlight_end":41},{"text":"            is_privileged: false,","highlight_start":1,"highlight_end":34},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        assert!(concordance.define_fate(fate).is_ok());","highlight_start":1,"highlight_end":56},{"text":"        assert_eq!(concordance.fate_count(), 1);","highlight_start":1,"highlight_end":49},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\concordance_of_fates.rs","byte_start":23991,"byte_end":23998,"line_start":742,"line_end":742,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\concordance_of_fates.rs:743:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m742\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m743\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_fate_creation() {\n\u001b[1m\u001b[96m744\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let mut concordance = Concordance::new();\n\u001b[1m\u001b[96m745\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m746\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let fate = Fate {\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m758\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(concordance.fate_count(), 1);\n\u001b[1m\u001b[96m759\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `panic` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":5841,"byte_end":5846,"line_start":270,"line_end":270,"column_start":14,"column_end":19,"is_primary":true,"text":[{"text":"        _ => panic!(\"Expected Map, got {:?}\", result),","highlight_start":14,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::panic;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `panic` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:270:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m270\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         _ => panic!(\"Expected Map, got {:?}\", result),\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::panic;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\mana_pool\\concordance_of_fates.rs","byte_start":24595,"byte_end":24998,"line_start":762,"line_end":770,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_subject_registration() {","highlight_start":5,"highlight_end":37},{"text":"        let mut concordance = Concordance::new();","highlight_start":1,"highlight_end":50},{"text":"        define_default_fates(&mut concordance);","highlight_start":1,"highlight_end":48},{"text":"        concordance.set_default_fate(String::from(\"Guardian\")).unwrap();","highlight_start":1,"highlight_end":73},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let subject_id = SubjectId(1);","highlight_start":1,"highlight_end":39},{"text":"        assert!(concordance.register_subject(subject_id, SubjectType::KernelThread).is_ok());","highlight_start":1,"highlight_end":94},{"text":"        assert_eq!(concordance.subject_count(), 1);","highlight_start":1,"highlight_end":52},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\concordance_of_fates.rs","byte_start":24582,"byte_end":24589,"line_start":761,"line_end":761,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\concordance_of_fates.rs:762:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m761\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m762\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_subject_registration() {\n\u001b[1m\u001b[96m763\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let mut concordance = Concordance::new();\n\u001b[1m\u001b[96m764\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         define_default_fates(&mut concordance);\n\u001b[1m\u001b[96m765\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         concordance.set_default_fate(String::from(\"Guardian\")).unwrap();\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m769\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(concordance.subject_count(), 1);\n\u001b[1m\u001b[96m770\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":5354,"byte_end":5358,"line_start":250,"line_end":250,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:250:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m250\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\attunement\\ward_of_sacred_boundaries.rs","byte_start":13352,"byte_end":13765,"line_start":437,"line_end":448,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_mortal_pointer_validation() {","highlight_start":5,"highlight_end":42},{"text":"        // Valid user space pointer","highlight_start":1,"highlight_end":36},{"text":"        assert!(is_mortal_pointer(0x1000));","highlight_start":1,"highlight_end":44},{"text":"        assert!(is_mortal_pointer(0x0000_7FFF_0000_0000));","highlight_start":1,"highlight_end":59},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Invalid: kernel space","highlight_start":1,"highlight_end":33},{"text":"        assert!(!is_mortal_pointer(0xFFFF_8000_0000_0000));","highlight_start":1,"highlight_end":60},{"text":"        assert!(!is_mortal_pointer(0xFFFF_FFFF_FFFF_FFFF));","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Invalid: null","highlight_start":1,"highlight_end":25},{"text":"        assert!(!is_mortal_pointer(0));","highlight_start":1,"highlight_end":40},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\attunement\\ward_of_sacred_boundaries.rs","byte_start":13339,"byte_end":13346,"line_start":436,"line_end":436,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\ward_of_sacred_boundaries.rs:437:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m436\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m437\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_mortal_pointer_validation() {\n\u001b[1m\u001b[96m438\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         // Valid user space pointer\n\u001b[1m\u001b[96m439\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(is_mortal_pointer(0x1000));\n\u001b[1m\u001b[96m440\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(is_mortal_pointer(0x0000_7FFF_0000_0000));\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m447\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(!is_mortal_pointer(0));\n\u001b[1m\u001b[96m448\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\attunement\\ward_of_sacred_boundaries.rs","byte_start":13786,"byte_end":14290,"line_start":451,"line_end":463,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_region_validation() {","highlight_start":5,"highlight_end":34},{"text":"        // Valid region entirely in user space","highlight_start":1,"highlight_end":47},{"text":"        assert!(validate_mortal_pointer(0x1000, 4096).is_ok());","highlight_start":1,"highlight_end":64},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Invalid: starts in user space but overflows","highlight_start":1,"highlight_end":55},{"text":"        assert!(validate_mortal_pointer(0x0000_7FFF_FFFF_F000, 0x2000).is_err());","highlight_start":1,"highlight_end":82},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Invalid: null pointer","highlight_start":1,"highlight_end":33},{"text":"        assert!(validate_mortal_pointer(0, 4096).is_err());","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Invalid: kernel space","highlight_start":1,"highlight_end":33},{"text":"        assert!(validate_mortal_pointer(0xFFFF_8000_0000_0000, 4096).is_err());","highlight_start":1,"highlight_end":80},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\attunement\\ward_of_sacred_boundaries.rs","byte_start":13773,"byte_end":13780,"line_start":450,"line_end":450,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\ward_of_sacred_boundaries.rs:451:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m450\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m451\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_region_validation() {\n\u001b[1m\u001b[96m452\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         // Valid region entirely in user space\n\u001b[1m\u001b[96m453\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(validate_mortal_pointer(0x1000, 4096).is_ok());\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m462\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(validate_mortal_pointer(0xFFFF_8000_0000_0000, 4096).is_err());\n\u001b[1m\u001b[96m463\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":4948,"byte_end":4952,"line_start":236,"line_end":236,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:236:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m236\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\attunement\\ward_of_unseen_paths.rs","byte_start":8917,"byte_end":9571,"line_start":298,"line_end":314,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_entropy_generation() {","highlight_start":5,"highlight_end":35},{"text":"        // Generate multiple offsets","highlight_start":1,"highlight_end":37},{"text":"        let offset1 = generate_kaslr_entropy();","highlight_start":1,"highlight_end":48},{"text":"        let offset2 = generate_kaslr_entropy();","highlight_start":1,"highlight_end":48},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Should be different (extremely likely with RDTSC)","highlight_start":1,"highlight_end":61},{"text":"        // Note: This could theoretically fail, but probability is ~0","highlight_start":1,"highlight_end":70},{"text":"        // assert!(offset1 != offset2);  // Commented out due to non-determinism","highlight_start":1,"highlight_end":81},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Should be aligned","highlight_start":1,"highlight_end":29},{"text":"        assert_eq!(offset1 % KASLR_ALIGNMENT, 0);","highlight_start":1,"highlight_end":50},{"text":"        assert_eq!(offset2 % KASLR_ALIGNMENT, 0);","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Should be within bounds","highlight_start":1,"highlight_end":35},{"text":"        assert!(offset1 < MAX_KASLR_OFFSET);","highlight_start":1,"highlight_end":45},{"text":"        assert!(offset2 < MAX_KASLR_OFFSET);","highlight_start":1,"highlight_end":45},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\attunement\\ward_of_unseen_paths.rs","byte_start":8904,"byte_end":8911,"line_start":297,"line_end":297,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\ward_of_unseen_paths.rs:298:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m297\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m298\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_entropy_generation() {\n\u001b[1m\u001b[96m299\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         // Generate multiple offsets\n\u001b[1m\u001b[96m300\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let offset1 = generate_kaslr_entropy();\n\u001b[1m\u001b[96m301\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let offset2 = generate_kaslr_entropy();\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m313\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(offset2 < MAX_KASLR_OFFSET);\n\u001b[1m\u001b[96m314\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"couldn't read `heartwood\\src\\../../target/x86_64-unknown-none/release/hello`: The system cannot find the path specified. (os error 3)","code":null,"level":"error","spans":[{"file_name":"heartwood\\src\\test_programs.rs","byte_start":108,"byte_end":172,"line_start":4,"line_end":4,"column_start":30,"column_end":94,"is_primary":true,"text":[{"text":"pub const HELLO_ELF: &[u8] = include_bytes!(\"../../target/x86_64-unknown-none/release/hello\");","highlight_start":30,"highlight_end":94}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\test_programs.rs","byte_start":108,"byte_end":172,"line_start":4,"line_end":4,"column_start":30,"column_end":94,"is_primary":false,"text":[{"text":"pub const HELLO_ELF: &[u8] = include_bytes!(\"../../target/x86_64-unknown-none/release/hello\");","highlight_start":30,"highlight_end":94}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"include_bytes!","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":48445,"byte_end":48471,"line_start":1360,"line_end":1360,"column_start":5,"column_end":31,"is_primary":false,"text":[{"text":"    macro_rules! include_bytes {","highlight_start":5,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: couldn't read `heartwood\\src\\../../target/x86_64-unknown-none/release/hello`: The system cannot find the path specified. (os error 3)\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\test_programs.rs:4:30\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m4\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub const HELLO_ELF: &[u8] = include_bytes!(\"../../target/x86_64-unknown-none/release/hello\");\n  \u001b[1m\u001b[96m|\u001b[0m                              \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":5087,"byte_end":5096,"line_start":241,"line_end":241,"column_start":13,"column_end":22,"is_primary":true,"text":[{"text":"            assert_eq!(items.len(), 3);","highlight_start":13,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:241:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m241\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             assert_eq!(items.len(), 3);\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":5127,"byte_end":5136,"line_start":242,"line_end":242,"column_start":13,"column_end":22,"is_primary":true,"text":[{"text":"            assert_eq!(items[0], Value::Number(1.0));","highlight_start":13,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:242:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m242\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             assert_eq!(items[0], Value::Number(1.0));\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\attunement\\ward_of_unseen_paths.rs","byte_start":9592,"byte_end":10181,"line_start":317,"line_end":332,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_kaslr_offset_math() {","highlight_start":5,"highlight_end":34},{"text":"        // Test applying and removing offsets","highlight_start":1,"highlight_end":46},{"text":"        let test_offset = 64 * 1024 * 1024; // 64 MB","highlight_start":1,"highlight_end":53},{"text":"        unsafe {","highlight_start":1,"highlight_end":17},{"text":"            KASLR_OFFSET = test_offset;","highlight_start":1,"highlight_end":40},{"text":"            KERNEL_BASE_ACTUAL = KERNEL_BASE_DEFAULT + test_offset;","highlight_start":1,"highlight_end":68},{"text":"            KASLR_ENABLED = true;","highlight_start":1,"highlight_end":34},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let test_addr = KERNEL_BASE_DEFAULT + 0x1000;","highlight_start":1,"highlight_end":54},{"text":"        let actual_addr = apply_kaslr_offset(test_addr);","highlight_start":1,"highlight_end":57},{"text":"        assert_eq!(actual_addr, test_addr + test_offset);","highlight_start":1,"highlight_end":58},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let recovered = remove_kaslr_offset(actual_addr);","highlight_start":1,"highlight_end":58},{"text":"        assert_eq!(recovered, test_addr);","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\attunement\\ward_of_unseen_paths.rs","byte_start":9579,"byte_end":9586,"line_start":316,"line_end":316,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\ward_of_unseen_paths.rs:317:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m316\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m317\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_kaslr_offset_math() {\n\u001b[1m\u001b[96m318\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         // Test applying and removing offsets\n\u001b[1m\u001b[96m319\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let test_offset = 64 * 1024 * 1024; // 64 MB\n\u001b[1m\u001b[96m320\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         unsafe {\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m331\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(recovered, test_addr);\n\u001b[1m\u001b[96m332\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\attunement\\ward_of_anonymity.rs","byte_start":9824,"byte_end":10249,"line_start":337,"line_end":349,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_privilege_levels() {","highlight_start":5,"highlight_end":33},{"text":"        // Enable ward","highlight_start":1,"highlight_end":23},{"text":"        unsafe { enable_anonymity(); }","highlight_start":1,"highlight_end":39},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Kernel can access","highlight_start":1,"highlight_end":29},{"text":"        assert!(can_access_symbols(PrivilegeLevel::Kernel));","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Privileged user cannot access","highlight_start":1,"highlight_end":41},{"text":"        assert!(!can_access_symbols(PrivilegeLevel::Privileged));","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Unprivileged definitely cannot access","highlight_start":1,"highlight_end":49},{"text":"        assert!(!can_access_symbols(PrivilegeLevel::Unprivileged));","highlight_start":1,"highlight_end":68},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\attunement\\ward_of_anonymity.rs","byte_start":9811,"byte_end":9818,"line_start":336,"line_end":336,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\ward_of_anonymity.rs:337:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m336\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m337\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_privilege_levels() {\n\u001b[1m\u001b[96m338\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         // Enable ward\n\u001b[1m\u001b[96m339\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         unsafe { enable_anonymity(); }\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m348\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(!can_access_symbols(PrivilegeLevel::Unprivileged));\n\u001b[1m\u001b[96m349\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":5181,"byte_end":5190,"line_start":243,"line_end":243,"column_start":13,"column_end":22,"is_primary":true,"text":[{"text":"            assert_eq!(items[1], Value::Number(2.0));","highlight_start":13,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:243:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m243\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             assert_eq!(items[1], Value::Number(2.0));\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\attunement\\ward_of_anonymity.rs","byte_start":10270,"byte_end":10728,"line_start":352,"line_end":366,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_anonymity_toggle() {","highlight_start":5,"highlight_end":33},{"text":"        // Disable ward","highlight_start":1,"highlight_end":24},{"text":"        unsafe { disable_anonymity(); }","highlight_start":1,"highlight_end":40},{"text":"        assert!(!is_anonymity_enabled());","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Everyone can access now","highlight_start":1,"highlight_end":35},{"text":"        assert!(can_access_symbols(PrivilegeLevel::Unprivileged));","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Re-enable","highlight_start":1,"highlight_end":21},{"text":"        unsafe { enable_anonymity(); }","highlight_start":1,"highlight_end":39},{"text":"        assert!(is_anonymity_enabled());","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Back to restricted","highlight_start":1,"highlight_end":30},{"text":"        assert!(!can_access_symbols(PrivilegeLevel::Unprivileged));","highlight_start":1,"highlight_end":68},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\attunement\\ward_of_anonymity.rs","byte_start":10257,"byte_end":10264,"line_start":351,"line_end":351,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\ward_of_anonymity.rs:352:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m351\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m352\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_anonymity_toggle() {\n\u001b[1m\u001b[96m353\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         // Disable ward\n\u001b[1m\u001b[96m354\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         unsafe { disable_anonymity(); }\n\u001b[1m\u001b[96m355\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(!is_anonymity_enabled());\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m365\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(!can_access_symbols(PrivilegeLevel::Unprivileged));\n\u001b[1m\u001b[96m366\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\attunement\\ward_of_anonymity.rs","byte_start":10749,"byte_end":11187,"line_start":369,"line_end":385,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_function_name_hiding() {","highlight_start":5,"highlight_end":37},{"text":"        unsafe { enable_anonymity(); }","highlight_start":1,"highlight_end":39},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let name = \"schedule\";","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Kernel sees real name","highlight_start":1,"highlight_end":33},{"text":"        assert_eq!(","highlight_start":1,"highlight_end":20},{"text":"            format_function_name(name, PrivilegeLevel::Kernel),","highlight_start":1,"highlight_end":64},{"text":"            \"schedule\"","highlight_start":1,"highlight_end":23},{"text":"        );","highlight_start":1,"highlight_end":11},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Unprivileged sees hidden","highlight_start":1,"highlight_end":36},{"text":"        assert_eq!(","highlight_start":1,"highlight_end":20},{"text":"            format_function_name(name, PrivilegeLevel::Unprivileged),","highlight_start":1,"highlight_end":70},{"text":"            \"<hidden>\"","highlight_start":1,"highlight_end":23},{"text":"        );","highlight_start":1,"highlight_end":11},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\attunement\\ward_of_anonymity.rs","byte_start":10736,"byte_end":10743,"line_start":368,"line_end":368,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\ward_of_anonymity.rs:369:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m368\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m369\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_function_name_hiding() {\n\u001b[1m\u001b[96m370\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         unsafe { enable_anonymity(); }\n\u001b[1m\u001b[96m371\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m372\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let name = \"schedule\";\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m384\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         );\n\u001b[1m\u001b[96m385\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\attunement\\per_cpu.rs","byte_start":7819,"byte_end":8388,"line_start":254,"line_end":265,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_per_cpu_data_layout() {","highlight_start":5,"highlight_end":36},{"text":"        use core::mem::{offset_of, size_of};","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Verify struct layout for assembly access","highlight_start":1,"highlight_end":52},{"text":"        assert_eq!(offset_of!(PerCpuData, self_ptr), 0, \"self_ptr MUST be at offset 0 for gs:[0] access\");","highlight_start":1,"highlight_end":107},{"text":"        assert_eq!(offset_of!(PerCpuData, kernel_stack_top), 8);","highlight_start":1,"highlight_end":65},{"text":"        assert_eq!(offset_of!(PerCpuData, user_stack_saved), 16);","highlight_start":1,"highlight_end":66},{"text":"        assert_eq!(offset_of!(PerCpuData, current_thread_id), 24);","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Verify alignment","highlight_start":1,"highlight_end":28},{"text":"        assert_eq!(size_of::<PerCpuData>() % 8, 0, \"PerCpuData must be 8-byte aligned\");","highlight_start":1,"highlight_end":89},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\attunement\\per_cpu.rs","byte_start":7806,"byte_end":7813,"line_start":253,"line_end":253,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\per_cpu.rs:254:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m253\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m254\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_per_cpu_data_layout() {\n\u001b[1m\u001b[96m255\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         use core::mem::{offset_of, size_of};\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m264\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(size_of::<PerCpuData>() % 8, 0, \"PerCpuData must be 8-byte aligned\");\n\u001b[1m\u001b[96m265\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":5235,"byte_end":5244,"line_start":244,"line_end":244,"column_start":13,"column_end":22,"is_primary":true,"text":[{"text":"            assert_eq!(items[2], Value::Number(3.0));","highlight_start":13,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:244:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m244\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             assert_eq!(items[2], Value::Number(3.0));\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\attunement\\per_cpu.rs","byte_start":8409,"byte_end":8685,"line_start":268,"line_end":274,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_per_cpu_data_creation() {","highlight_start":5,"highlight_end":38},{"text":"        let data = PerCpuData::new(0, 0x1000);","highlight_start":1,"highlight_end":47},{"text":"        assert_eq!(data.cpu_id, 0);","highlight_start":1,"highlight_end":36},{"text":"        assert_eq!(data.kernel_stack_top, 0x1000);","highlight_start":1,"highlight_end":51},{"text":"        assert_eq!(data.user_stack_saved, 0);","highlight_start":1,"highlight_end":46},{"text":"        assert!(data.current_thread_id.is_none());","highlight_start":1,"highlight_end":51},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\attunement\\per_cpu.rs","byte_start":8396,"byte_end":8403,"line_start":267,"line_end":267,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\per_cpu.rs:268:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m267\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m268\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_per_cpu_data_creation() {\n\u001b[1m\u001b[96m269\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let data = PerCpuData::new(0, 0x1000);\n\u001b[1m\u001b[96m270\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(data.cpu_id, 0);\n\u001b[1m\u001b[96m271\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(data.kernel_stack_top, 0x1000);\n\u001b[1m\u001b[96m272\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(data.user_stack_saved, 0);\n\u001b[1m\u001b[96m273\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(data.current_thread_id.is_none());\n\u001b[1m\u001b[96m274\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `panic` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":5300,"byte_end":5305,"line_start":246,"line_end":246,"column_start":14,"column_end":19,"is_primary":true,"text":[{"text":"        _ => panic!(\"Expected List, got {:?}\", result),","highlight_start":14,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::panic;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `panic` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:246:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m246\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         _ => panic!(\"Expected List, got {:?}\", result),\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::panic;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":4697,"byte_end":4701,"line_start":220,"line_end":220,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:220:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m220\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":4499,"byte_end":4503,"line_start":207,"line_end":207,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:207:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m207\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":4331,"byte_end":4335,"line_start":195,"line_end":195,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:195:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m195\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused import: `super::ThreadId`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\syscalls.rs","byte_start":1047,"byte_end":1062,"line_start":33,"line_end":33,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"use super::ThreadId;","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\syscalls.rs","byte_start":1043,"byte_end":1065,"line_start":33,"line_end":34,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use super::ThreadId;","highlight_start":1,"highlight_end":21},{"text":"use x86_64::VirtAddr;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused import: `super::ThreadId`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\loom_of_fate\\syscalls.rs:33:5\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m33\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use super::ThreadId;\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary parentheses around assigned value","code":{"code":"unused_parens","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\mana_pool\\user_space.rs","byte_start":9436,"byte_end":9437,"line_start":289,"line_end":289,"column_start":28,"column_end":29,"is_primary":true,"text":[{"text":"            let page_end = ((seg.vaddr + seg.memsz + 0xFFF) & !0xFFF);","highlight_start":28,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\mana_pool\\user_space.rs","byte_start":9477,"byte_end":9478,"line_start":289,"line_end":289,"column_start":69,"column_end":70,"is_primary":true,"text":[{"text":"            let page_end = ((seg.vaddr + seg.memsz + 0xFFF) & !0xFFF);","highlight_start":69,"highlight_end":70}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove these parentheses","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\mana_pool\\user_space.rs","byte_start":9436,"byte_end":9437,"line_start":289,"line_end":289,"column_start":28,"column_end":29,"is_primary":true,"text":[{"text":"            let page_end = ((seg.vaddr + seg.memsz + 0xFFF) & !0xFFF);","highlight_start":28,"highlight_end":29}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"heartwood\\src\\mana_pool\\user_space.rs","byte_start":9477,"byte_end":9478,"line_start":289,"line_end":289,"column_start":69,"column_end":70,"is_primary":true,"text":[{"text":"            let page_end = ((seg.vaddr + seg.memsz + 0xFFF) & !0xFFF);","highlight_start":69,"highlight_end":70}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary parentheses around assigned value\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\user_space.rs:289:28\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m289\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             let page_end = ((seg.vaddr + seg.memsz + 0xFFF) & !0xFFF);\n    \u001b[1m\u001b[96m|\u001b[0m                            \u001b[1m\u001b[93m^\u001b[0m                                        \u001b[1m\u001b[93m^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default\n\u001b[1m\u001b[96mhelp\u001b[0m: remove these parentheses\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m289\u001b[0m \u001b[91m- \u001b[0m            let page_end = \u001b[91m(\u001b[0m(seg.vaddr + seg.memsz + 0xFFF) & !0xFFF\u001b[91m)\u001b[0m;\n\u001b[1m\u001b[96m289\u001b[0m \u001b[92m+ \u001b[0m            let page_end = (seg.vaddr + seg.memsz + 0xFFF) & !0xFFF;\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":4145,"byte_end":4149,"line_start":183,"line_end":183,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:183:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m183\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":3936,"byte_end":3940,"line_start":171,"line_end":171,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:171:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m171\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused import: `alloc::vec::Vec`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\vfs\\ext4\\superblock.rs","byte_start":360,"byte_end":375,"line_start":10,"line_end":10,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"use alloc::vec::Vec;","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\vfs\\ext4\\superblock.rs","byte_start":356,"byte_end":378,"line_start":10,"line_end":11,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::vec::Vec;","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused import: `alloc::vec::Vec`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\ext4\\superblock.rs:10:5\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m10\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use alloc::vec::Vec;\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^^^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused import: `alloc::vec::Vec`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\vfs\\ext4\\inode.rs","byte_start":403,"byte_end":418,"line_start":11,"line_end":11,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"use alloc::vec::Vec;","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\vfs\\ext4\\inode.rs","byte_start":399,"byte_end":421,"line_start":11,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::vec::Vec;","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused import: `alloc::vec::Vec`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\ext4\\inode.rs:11:5\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m11\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use alloc::vec::Vec;\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^^^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused import: `alloc::string::ToString`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\vfs\\ext4\\mod.rs","byte_start":1123,"byte_end":1146,"line_start":39,"line_end":39,"column_start":5,"column_end":28,"is_primary":true,"text":[{"text":"use alloc::string::ToString;","highlight_start":5,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\vfs\\ext4\\mod.rs","byte_start":1119,"byte_end":1149,"line_start":39,"line_end":40,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::ToString;","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused import: `alloc::string::ToString`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\ext4\\mod.rs:39:5\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m39\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use alloc::string::ToString;\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":3802,"byte_end":3806,"line_start":161,"line_end":161,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:161:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m161\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\stack_protection.rs","byte_start":5491,"byte_end":5816,"line_start":134,"line_end":144,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_canary_get_set() {","highlight_start":5,"highlight_end":31},{"text":"        unsafe {","highlight_start":1,"highlight_end":17},{"text":"            set_current_canary(0x1234567890ABCDEF);","highlight_start":1,"highlight_end":52},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        assert_eq!(get_current_canary(), 0x1234567890ABCDEF);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        unsafe {","highlight_start":1,"highlight_end":17},{"text":"            set_current_canary(0xFEDCBA0987654321);","highlight_start":1,"highlight_end":52},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        assert_eq!(get_current_canary(), 0xFEDCBA0987654321);","highlight_start":1,"highlight_end":62},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\stack_protection.rs","byte_start":5478,"byte_end":5485,"line_start":133,"line_end":133,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\stack_protection.rs:134:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m133\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m134\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_canary_get_set() {\n\u001b[1m\u001b[96m135\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         unsafe {\n\u001b[1m\u001b[96m136\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             set_current_canary(0x1234567890ABCDEF);\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m143\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(get_current_canary(), 0xFEDCBA0987654321);\n\u001b[1m\u001b[96m144\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\stack_protection.rs","byte_start":5837,"byte_end":6050,"line_start":147,"line_end":151,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_canary_default() {","highlight_start":5,"highlight_end":31},{"text":"        // Default value should be non-zero (our placeholder)","highlight_start":1,"highlight_end":62},{"text":"        let default = get_current_canary();","highlight_start":1,"highlight_end":44},{"text":"        assert_ne!(default, 0, \"Canary should have non-zero default\");","highlight_start":1,"highlight_end":71},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\stack_protection.rs","byte_start":5824,"byte_end":5831,"line_start":146,"line_end":146,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\stack_protection.rs:147:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m146\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m147\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_canary_default() {\n\u001b[1m\u001b[96m148\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         // Default value should be non-zero (our placeholder)\n\u001b[1m\u001b[96m149\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let default = get_current_canary();\n\u001b[1m\u001b[96m150\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_ne!(default, 0, \"Canary should have non-zero default\");\n\u001b[1m\u001b[96m151\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused import: `VesselId`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\groves\\lifecycle.rs","byte_start":389,"byte_end":397,"line_start":8,"line_end":8,"column_start":59,"column_end":67,"is_primary":true,"text":[{"text":"use crate::loom_of_fate::{self, ThreadId, ThreadPriority, VesselId};","highlight_start":59,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\groves\\lifecycle.rs","byte_start":387,"byte_end":397,"line_start":8,"line_end":8,"column_start":57,"column_end":67,"is_primary":true,"text":[{"text":"use crate::loom_of_fate::{self, ThreadId, ThreadPriority, VesselId};","highlight_start":57,"highlight_end":67}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused import: `VesselId`\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\groves\\lifecycle.rs:8:59\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m8\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use crate::loom_of_fate::{self, ThreadId, ThreadPriority, VesselId};\n  \u001b[1m\u001b[96m|\u001b[0m                                                           \u001b[1m\u001b[93m^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\stack_protection.rs","byte_start":6129,"byte_end":6200,"line_start":155,"line_end":157,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_stack_chk_fail_panics() {","highlight_start":5,"highlight_end":38},{"text":"        simulate_violation();","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\stack_protection.rs","byte_start":6058,"byte_end":6065,"line_start":153,"line_end":153,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\stack_protection.rs:155:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m153\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m154\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[should_panic(expected = \"STACK CANARY VIOLATION\")]\n\u001b[1m\u001b[96m155\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_stack_chk_fail_panics() {\n\u001b[1m\u001b[96m156\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         simulate_violation();\n\u001b[1m\u001b[96m157\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\mock.rs","byte_start":8078,"byte_end":8263,"line_start":280,"line_end":286,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_create_mockfs() {","highlight_start":5,"highlight_end":30},{"text":"        let fs = MockFs::new();","highlight_start":1,"highlight_end":32},{"text":"        assert_eq!(fs.name(), \"MockFS\");","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Root should exist","highlight_start":1,"highlight_end":29},{"text":"        assert!(fs.exists(&Path::new(\"/\")));","highlight_start":1,"highlight_end":45},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\mock.rs","byte_start":8065,"byte_end":8072,"line_start":279,"line_end":279,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\mock.rs:280:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m279\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m280\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_create_mockfs() {\n\u001b[1m\u001b[96m281\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let fs = MockFs::new();\n\u001b[1m\u001b[96m282\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(fs.name(), \"MockFS\");\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m285\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(fs.exists(&Path::new(\"/\")));\n\u001b[1m\u001b[96m286\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\mock.rs","byte_start":8284,"byte_end":8567,"line_start":289,"line_end":299,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_write_and_read() {","highlight_start":5,"highlight_end":31},{"text":"        let fs = MockFs::new();","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let path = Path::new(\"/test.txt\");","highlight_start":1,"highlight_end":43},{"text":"        let data = b\"Hello, World!\";","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        fs.write(&path, data).unwrap();","highlight_start":1,"highlight_end":40},{"text":"        let read_data = fs.read(&path).unwrap();","highlight_start":1,"highlight_end":49},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        assert_eq!(read_data, data);","highlight_start":1,"highlight_end":37},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\mock.rs","byte_start":8271,"byte_end":8278,"line_start":288,"line_end":288,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\mock.rs:289:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m288\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m289\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_write_and_read() {\n\u001b[1m\u001b[96m290\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let fs = MockFs::new();\n\u001b[1m\u001b[96m291\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m292\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let path = Path::new(\"/test.txt\");\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m298\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(read_data, data);\n\u001b[1m\u001b[96m299\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\mock.rs","byte_start":8588,"byte_end":8800,"line_start":302,"line_end":308,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_read_nonexistent() {","highlight_start":5,"highlight_end":33},{"text":"        let fs = MockFs::new();","highlight_start":1,"highlight_end":32},{"text":"        let path = Path::new(\"/nonexistent.txt\");","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let result = fs.read(&path);","highlight_start":1,"highlight_end":37},{"text":"        assert_eq!(result, Err(FsError::NotFound));","highlight_start":1,"highlight_end":52},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\mock.rs","byte_start":8575,"byte_end":8582,"line_start":301,"line_end":301,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\mock.rs:302:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m301\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m302\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_read_nonexistent() {\n\u001b[1m\u001b[96m303\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let fs = MockFs::new();\n\u001b[1m\u001b[96m304\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let path = Path::new(\"/nonexistent.txt\");\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m307\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(result, Err(FsError::NotFound));\n\u001b[1m\u001b[96m308\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\mock.rs","byte_start":8821,"byte_end":9267,"line_start":311,"line_end":325,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_create_nested_file() {","highlight_start":5,"highlight_end":35},{"text":"        let fs = MockFs::new();","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let path = Path::new(\"/dir1/dir2/file.txt\");","highlight_start":1,"highlight_end":53},{"text":"        let data = b\"Nested file\";","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        fs.write(&path, data).unwrap();","highlight_start":1,"highlight_end":40},{"text":"        let read_data = fs.read(&path).unwrap();","highlight_start":1,"highlight_end":49},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        assert_eq!(read_data, data);","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Parent directories should exist","highlight_start":1,"highlight_end":43},{"text":"        assert!(fs.exists(&Path::new(\"/dir1\")));","highlight_start":1,"highlight_end":49},{"text":"        assert!(fs.exists(&Path::new(\"/dir1/dir2\")));","highlight_start":1,"highlight_end":54},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\mock.rs","byte_start":8808,"byte_end":8815,"line_start":310,"line_end":310,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\mock.rs:311:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m310\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m311\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_create_nested_file() {\n\u001b[1m\u001b[96m312\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let fs = MockFs::new();\n\u001b[1m\u001b[96m313\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m314\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let path = Path::new(\"/dir1/dir2/file.txt\");\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m324\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(fs.exists(&Path::new(\"/dir1/dir2\")));\n\u001b[1m\u001b[96m325\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\mock.rs","byte_start":9288,"byte_end":9865,"line_start":328,"line_end":343,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_read_dir() {","highlight_start":5,"highlight_end":25},{"text":"        let fs = MockFs::new();","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        fs.write(&Path::new(\"/file1.txt\"), b\"data1\").unwrap();","highlight_start":1,"highlight_end":63},{"text":"        fs.write(&Path::new(\"/file2.txt\"), b\"data2\").unwrap();","highlight_start":1,"highlight_end":63},{"text":"        fs.create_dir(&Path::new(\"/subdir\")).unwrap();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let entries = fs.read_dir(&Path::new(\"/\")).unwrap();","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        assert_eq!(entries.len(), 3);","highlight_start":1,"highlight_end":38},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let names: Vec<&str> = entries.iter().map(|e| e.name.as_str()).collect();","highlight_start":1,"highlight_end":82},{"text":"        assert!(names.contains(&\"file1.txt\"));","highlight_start":1,"highlight_end":47},{"text":"        assert!(names.contains(&\"file2.txt\"));","highlight_start":1,"highlight_end":47},{"text":"        assert!(names.contains(&\"subdir\"));","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\mock.rs","byte_start":9275,"byte_end":9282,"line_start":327,"line_end":327,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\mock.rs:328:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m327\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m328\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_read_dir() {\n\u001b[1m\u001b[96m329\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let fs = MockFs::new();\n\u001b[1m\u001b[96m330\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m331\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         fs.write(&Path::new(\"/file1.txt\"), b\"data1\").unwrap();\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m342\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(names.contains(&\"subdir\"));\n\u001b[1m\u001b[96m343\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\mock.rs","byte_start":9886,"byte_end":10154,"line_start":346,"line_end":357,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_remove_file() {","highlight_start":5,"highlight_end":28},{"text":"        let fs = MockFs::new();","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let path = Path::new(\"/test.txt\");","highlight_start":1,"highlight_end":43},{"text":"        fs.write(&path, b\"data\").unwrap();","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        assert!(fs.exists(&path));","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        fs.remove(&path).unwrap();","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        assert!(!fs.exists(&path));","highlight_start":1,"highlight_end":36},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\mock.rs","byte_start":9873,"byte_end":9880,"line_start":345,"line_end":345,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\mock.rs:346:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m345\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m346\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_remove_file() {\n\u001b[1m\u001b[96m347\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let fs = MockFs::new();\n\u001b[1m\u001b[96m348\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m349\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let path = Path::new(\"/test.txt\");\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m356\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(!fs.exists(&path));\n\u001b[1m\u001b[96m357\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\mock.rs","byte_start":10175,"byte_end":10378,"line_start":360,"line_end":365,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_read_only_filesystem() {","highlight_start":5,"highlight_end":37},{"text":"        let fs = MockFs::new_read_only();","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let result = fs.write(&Path::new(\"/test.txt\"), b\"data\");","highlight_start":1,"highlight_end":65},{"text":"        assert_eq!(result, Err(FsError::ReadOnly));","highlight_start":1,"highlight_end":52},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\mock.rs","byte_start":10162,"byte_end":10169,"line_start":359,"line_end":359,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\mock.rs:360:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m359\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m360\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_read_only_filesystem() {\n\u001b[1m\u001b[96m361\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let fs = MockFs::new_read_only();\n\u001b[1m\u001b[96m362\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m363\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let result = fs.write(&Path::new(\"/test.txt\"), b\"data\");\n\u001b[1m\u001b[96m364\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(result, Err(FsError::ReadOnly));\n\u001b[1m\u001b[96m365\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":3638,"byte_end":3642,"line_start":148,"line_end":148,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:148:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m148\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\mock.rs","byte_start":10399,"byte_end":10858,"line_start":368,"line_end":381,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_stat() {","highlight_start":5,"highlight_end":21},{"text":"        let fs = MockFs::new();","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        fs.write(&Path::new(\"/file.txt\"), b\"12345\").unwrap();","highlight_start":1,"highlight_end":62},{"text":"        fs.create_dir(&Path::new(\"/dir\")).unwrap();","highlight_start":1,"highlight_end":52},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let file_stat = fs.stat(&Path::new(\"/file.txt\")).unwrap();","highlight_start":1,"highlight_end":67},{"text":"        assert_eq!(file_stat.size, 5);","highlight_start":1,"highlight_end":39},{"text":"        assert!(!file_stat.is_dir);","highlight_start":1,"highlight_end":36},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let dir_stat = fs.stat(&Path::new(\"/dir\")).unwrap();","highlight_start":1,"highlight_end":61},{"text":"        assert_eq!(dir_stat.size, 0);","highlight_start":1,"highlight_end":38},{"text":"        assert!(dir_stat.is_dir);","highlight_start":1,"highlight_end":34},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\mock.rs","byte_start":10386,"byte_end":10393,"line_start":367,"line_end":367,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\mock.rs:368:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m367\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m368\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_stat() {\n\u001b[1m\u001b[96m369\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let fs = MockFs::new();\n\u001b[1m\u001b[96m370\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m371\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         fs.write(&Path::new(\"/file.txt\"), b\"12345\").unwrap();\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m380\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(dir_stat.is_dir);\n\u001b[1m\u001b[96m381\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\fat32\\bpb.rs","byte_start":13879,"byte_end":15766,"line_start":371,"line_end":436,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_bpb_validation() {","highlight_start":5,"highlight_end":31},{"text":"        // Create minimal valid FAT32 boot sector","highlight_start":1,"highlight_end":50},{"text":"        let mut boot_sector = [0u8; 512];","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Boot signature","highlight_start":1,"highlight_end":26},{"text":"        boot_sector[510] = 0x55;","highlight_start":1,"highlight_end":33},{"text":"        boot_sector[511] = 0xAA;","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Bytes per sector = 512","highlight_start":1,"highlight_end":34},{"text":"        boot_sector[11] = 0x00;","highlight_start":1,"highlight_end":32},{"text":"        boot_sector[12] = 0x02;","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Sectors per cluster = 8","highlight_start":1,"highlight_end":35},{"text":"        boot_sector[13] = 8;","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Reserved sectors = 32","highlight_start":1,"highlight_end":33},{"text":"        boot_sector[14] = 32;","highlight_start":1,"highlight_end":30},{"text":"        boot_sector[15] = 0;","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Number of FATs = 2","highlight_start":1,"highlight_end":30},{"text":"        boot_sector[16] = 2;","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Root entries = 0 (FAT32)","highlight_start":1,"highlight_end":36},{"text":"        boot_sector[17] = 0;","highlight_start":1,"highlight_end":29},{"text":"        boot_sector[18] = 0;","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Total sectors 16-bit = 0 (FAT32)","highlight_start":1,"highlight_end":44},{"text":"        boot_sector[19] = 0;","highlight_start":1,"highlight_end":29},{"text":"        boot_sector[20] = 0;","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Sectors per FAT 16-bit = 0 (FAT32)","highlight_start":1,"highlight_end":46},{"text":"        boot_sector[22] = 0;","highlight_start":1,"highlight_end":29},{"text":"        boot_sector[23] = 0;","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Total sectors 32-bit = 1000000","highlight_start":1,"highlight_end":42},{"text":"        let total = 1000000u32.to_le_bytes();","highlight_start":1,"highlight_end":46},{"text":"        boot_sector[32..36].copy_from_slice(&total);","highlight_start":1,"highlight_end":53},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Sectors per FAT 32-bit = 1000","highlight_start":1,"highlight_end":41},{"text":"        let spf = 1000u32.to_le_bytes();","highlight_start":1,"highlight_end":41},{"text":"        boot_sector[36..40].copy_from_slice(&spf);","highlight_start":1,"highlight_end":51},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Root cluster = 2","highlight_start":1,"highlight_end":28},{"text":"        boot_sector[44] = 2;","highlight_start":1,"highlight_end":29},{"text":"        boot_sector[45] = 0;","highlight_start":1,"highlight_end":29},{"text":"        boot_sector[46] = 0;","highlight_start":1,"highlight_end":29},{"text":"        boot_sector[47] = 0;","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // FSInfo sector = 1","highlight_start":1,"highlight_end":29},{"text":"        boot_sector[48] = 1;","highlight_start":1,"highlight_end":29},{"text":"        boot_sector[49] = 0;","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Backup boot sector = 6","highlight_start":1,"highlight_end":34},{"text":"        boot_sector[50] = 6;","highlight_start":1,"highlight_end":29},{"text":"        boot_sector[51] = 0;","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Filesystem type = \"FAT32   \"","highlight_start":1,"highlight_end":40},{"text":"        boot_sector[82..90].copy_from_slice(b\"FAT32   \");","highlight_start":1,"highlight_end":58},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let bpb = Fat32Bpb::parse(&boot_sector).unwrap();","highlight_start":1,"highlight_end":58},{"text":"        assert_eq!(bpb.bytes_per_sector, 512);","highlight_start":1,"highlight_end":47},{"text":"        assert_eq!(bpb.sectors_per_cluster, 8);","highlight_start":1,"highlight_end":48},{"text":"        assert_eq!(bpb.root_cluster, 2);","highlight_start":1,"highlight_end":41},{"text":"        assert_eq!(bpb.fsinfo_sector, 1);","highlight_start":1,"highlight_end":42},{"text":"        assert_eq!(bpb.backup_boot_sector, 6);","highlight_start":1,"highlight_end":47},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\fat32\\bpb.rs","byte_start":13866,"byte_end":13873,"line_start":370,"line_end":370,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\fat32\\bpb.rs:371:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m370\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m371\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_bpb_validation() {\n\u001b[1m\u001b[96m372\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         // Create minimal valid FAT32 boot sector\n\u001b[1m\u001b[96m373\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let mut boot_sector = [0u8; 512];\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m435\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(bpb.backup_boot_sector, 6);\n\u001b[1m\u001b[96m436\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\fat32\\bpb.rs","byte_start":15787,"byte_end":16547,"line_start":439,"line_end":460,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_fsinfo_parsing() {","highlight_start":5,"highlight_end":31},{"text":"        let mut fsinfo = [0u8; 512];","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Lead signature (0x41615252)","highlight_start":1,"highlight_end":39},{"text":"        fsinfo[0..4].copy_from_slice(&0x41615252u32.to_le_bytes());","highlight_start":1,"highlight_end":68},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Structure signature (0x61417272)","highlight_start":1,"highlight_end":44},{"text":"        fsinfo[484..488].copy_from_slice(&0x61417272u32.to_le_bytes());","highlight_start":1,"highlight_end":72},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Free clusters = 500000","highlight_start":1,"highlight_end":34},{"text":"        fsinfo[488..492].copy_from_slice(&500000u32.to_le_bytes());","highlight_start":1,"highlight_end":68},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Next free = 100","highlight_start":1,"highlight_end":27},{"text":"        fsinfo[492..496].copy_from_slice(&100u32.to_le_bytes());","highlight_start":1,"highlight_end":65},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Trail signature (0xAA550000)","highlight_start":1,"highlight_end":40},{"text":"        fsinfo[508..512].copy_from_slice(&0xAA550000u32.to_le_bytes());","highlight_start":1,"highlight_end":72},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let fs = FSInfo::parse(&fsinfo).unwrap();","highlight_start":1,"highlight_end":50},{"text":"        assert_eq!(fs.free_clusters, 500000);","highlight_start":1,"highlight_end":46},{"text":"        assert_eq!(fs.next_free, 100);","highlight_start":1,"highlight_end":39},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\fat32\\bpb.rs","byte_start":15774,"byte_end":15781,"line_start":438,"line_end":438,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\fat32\\bpb.rs:439:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m438\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m439\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_fsinfo_parsing() {\n\u001b[1m\u001b[96m440\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let mut fsinfo = [0u8; 512];\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m459\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(fs.next_free, 100);\n\u001b[1m\u001b[96m460\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\fat32\\fat.rs","byte_start":7715,"byte_end":7941,"line_start":230,"line_end":235,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_eoc_detection() {","highlight_start":5,"highlight_end":30},{"text":"        assert!(FatTable::is_eoc(0x0FFFFFF8));","highlight_start":1,"highlight_end":47},{"text":"        assert!(FatTable::is_eoc(0x0FFFFFFF));","highlight_start":1,"highlight_end":47},{"text":"        assert!(!FatTable::is_eoc(0x0FFFFFF7));","highlight_start":1,"highlight_end":48},{"text":"        assert!(!FatTable::is_eoc(0x00000002));","highlight_start":1,"highlight_end":48},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\fat32\\fat.rs","byte_start":7702,"byte_end":7709,"line_start":229,"line_end":229,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\fat32\\fat.rs:230:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m229\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m230\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_eoc_detection() {\n\u001b[1m\u001b[96m231\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(FatTable::is_eoc(0x0FFFFFF8));\n\u001b[1m\u001b[96m232\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(FatTable::is_eoc(0x0FFFFFFF));\n\u001b[1m\u001b[96m233\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(!FatTable::is_eoc(0x0FFFFFF7));\n\u001b[1m\u001b[96m234\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(!FatTable::is_eoc(0x00000002));\n\u001b[1m\u001b[96m235\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\fat32\\fat.rs","byte_start":7962,"byte_end":8148,"line_start":238,"line_end":242,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_bad_cluster_detection() {","highlight_start":5,"highlight_end":38},{"text":"        assert!(FatTable::is_bad(0x0FFFFFF7));","highlight_start":1,"highlight_end":47},{"text":"        assert!(!FatTable::is_bad(0x0FFFFFF8));","highlight_start":1,"highlight_end":48},{"text":"        assert!(!FatTable::is_bad(0x00000000));","highlight_start":1,"highlight_end":48},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\fat32\\fat.rs","byte_start":7949,"byte_end":7956,"line_start":237,"line_end":237,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\fat32\\fat.rs:238:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m237\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m238\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_bad_cluster_detection() {\n\u001b[1m\u001b[96m239\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(FatTable::is_bad(0x0FFFFFF7));\n\u001b[1m\u001b[96m240\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(!FatTable::is_bad(0x0FFFFFF8));\n\u001b[1m\u001b[96m241\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(!FatTable::is_bad(0x00000000));\n\u001b[1m\u001b[96m242\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\fat32\\fat.rs","byte_start":8169,"byte_end":8359,"line_start":245,"line_end":249,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_free_cluster_detection() {","highlight_start":5,"highlight_end":39},{"text":"        assert!(FatTable::is_free(0x00000000));","highlight_start":1,"highlight_end":48},{"text":"        assert!(!FatTable::is_free(0x00000002));","highlight_start":1,"highlight_end":49},{"text":"        assert!(!FatTable::is_free(0x0FFFFFF8));","highlight_start":1,"highlight_end":49},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\fat32\\fat.rs","byte_start":8156,"byte_end":8163,"line_start":244,"line_end":244,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\fat32\\fat.rs:245:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m244\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m245\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_free_cluster_detection() {\n\u001b[1m\u001b[96m246\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(FatTable::is_free(0x00000000));\n\u001b[1m\u001b[96m247\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(!FatTable::is_free(0x00000002));\n\u001b[1m\u001b[96m248\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(!FatTable::is_free(0x0FFFFFF8));\n\u001b[1m\u001b[96m249\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\fat32\\dir.rs","byte_start":7840,"byte_end":8313,"line_start":265,"line_end":277,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_short_name_parsing() {","highlight_start":5,"highlight_end":35},{"text":"        // \"README  TXT\" -> \"README.TXT\"","highlight_start":1,"highlight_end":41},{"text":"        let name = DirEntry::parse_short_name(b\"README  TXT\");","highlight_start":1,"highlight_end":63},{"text":"        assert_eq!(name, \"README.TXT\");","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // \"KERNEL  BIN\" -> \"KERNEL.BIN\"","highlight_start":1,"highlight_end":41},{"text":"        let name = DirEntry::parse_short_name(b\"KERNEL  BIN\");","highlight_start":1,"highlight_end":63},{"text":"        assert_eq!(name, \"KERNEL.BIN\");","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // \"NOEXT       \" -> \"NOEXT\"","highlight_start":1,"highlight_end":37},{"text":"        let name = DirEntry::parse_short_name(b\"NOEXT      \");","highlight_start":1,"highlight_end":63},{"text":"        assert_eq!(name, \"NOEXT\");","highlight_start":1,"highlight_end":35},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\fat32\\dir.rs","byte_start":7827,"byte_end":7834,"line_start":264,"line_end":264,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\fat32\\dir.rs:265:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m264\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m265\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_short_name_parsing() {\n\u001b[1m\u001b[96m266\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         // \"README  TXT\" -> \"README.TXT\"\n\u001b[1m\u001b[96m267\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let name = DirEntry::parse_short_name(b\"README  TXT\");\n\u001b[1m\u001b[96m268\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(name, \"README.TXT\");\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m276\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(name, \"NOEXT\");\n\u001b[1m\u001b[96m277\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\fat32\\dir.rs","byte_start":8334,"byte_end":8660,"line_start":280,"line_end":289,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_attribute_checking() {","highlight_start":5,"highlight_end":35},{"text":"        let mut data = [0u8; 32];","highlight_start":1,"highlight_end":34},{"text":"        data[0] = b'T'; // Valid filename start","highlight_start":1,"highlight_end":48},{"text":"        data[11] = attr::DIRECTORY;","highlight_start":1,"highlight_end":36},{"text":"        data[26] = 2; // First cluster = 2","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let entry = DirEntry::parse(&data).unwrap();","highlight_start":1,"highlight_end":53},{"text":"        assert!(entry.is_dir);","highlight_start":1,"highlight_end":31},{"text":"        assert!(!entry.is_hidden);","highlight_start":1,"highlight_end":35},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\fat32\\dir.rs","byte_start":8321,"byte_end":8328,"line_start":279,"line_end":279,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\fat32\\dir.rs:280:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m279\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m280\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_attribute_checking() {\n\u001b[1m\u001b[96m281\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         let mut data = [0u8; 32];\n\u001b[1m\u001b[96m282\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         data[0] = b'T'; // Valid filename start\n\u001b[1m\u001b[96m283\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         data[11] = attr::DIRECTORY;\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m288\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert!(!entry.is_hidden);\n\u001b[1m\u001b[96m289\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":138,"byte_end":413,"line_start":9,"line_end":16,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"fn test_path_creation() {","highlight_start":1,"highlight_end":26},{"text":"    let path = Path::new(\"/home/user/file.txt\");","highlight_start":1,"highlight_end":49},{"text":"    assert_eq!(path.as_str(), \"/home/user/file.txt\");","highlight_start":1,"highlight_end":54},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Test backslash normalization","highlight_start":1,"highlight_end":36},{"text":"    let path = Path::new(\"C:\\\\Users\\\\file.txt\");","highlight_start":1,"highlight_end":49},{"text":"    assert_eq!(path.as_str(), \"C:/Users/file.txt\");","highlight_start":1,"highlight_end":52},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":129,"byte_end":136,"line_start":8,"line_end":8,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[test]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\tests.rs:9:1\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m8\u001b[0m \u001b[1m\u001b[96m|\u001b[0m   #[test]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n \u001b[1m\u001b[96m9\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m fn test_path_creation() {\n\u001b[1m\u001b[96m10\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     let path = Path::new(\"/home/user/file.txt\");\n\u001b[1m\u001b[96m11\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     assert_eq!(path.as_str(), \"/home/user/file.txt\");\n\u001b[1m\u001b[96m...\u001b[0m  \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m15\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     assert_eq!(path.as_str(), \"C:/Users/file.txt\");\n\u001b[1m\u001b[96m16\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m }\n   \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":426,"byte_end":957,"line_start":19,"line_end":33,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"fn test_path_join() {","highlight_start":1,"highlight_end":22},{"text":"    let base = Path::new(\"/home/user\");","highlight_start":1,"highlight_end":40},{"text":"    let joined = base.join(\"documents\");","highlight_start":1,"highlight_end":41},{"text":"    assert_eq!(joined.as_str(), \"/home/user/documents\");","highlight_start":1,"highlight_end":57},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Test with trailing slash","highlight_start":1,"highlight_end":32},{"text":"    let base = Path::new(\"/home/user/\");","highlight_start":1,"highlight_end":41},{"text":"    let joined = base.join(\"documents\");","highlight_start":1,"highlight_end":41},{"text":"    assert_eq!(joined.as_str(), \"/home/user/documents\");","highlight_start":1,"highlight_end":57},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Test with leading slash in component","highlight_start":1,"highlight_end":44},{"text":"    let base = Path::new(\"/home/user\");","highlight_start":1,"highlight_end":40},{"text":"    let joined = base.join(\"/documents\");","highlight_start":1,"highlight_end":42},{"text":"    assert_eq!(joined.as_str(), \"/home/user/documents\");","highlight_start":1,"highlight_end":57},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":417,"byte_end":424,"line_start":18,"line_end":18,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[test]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\tests.rs:19:1\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m18\u001b[0m \u001b[1m\u001b[96m|\u001b[0m   #[test]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m19\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m fn test_path_join() {\n\u001b[1m\u001b[96m20\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     let base = Path::new(\"/home/user\");\n\u001b[1m\u001b[96m21\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     let joined = base.join(\"documents\");\n\u001b[1m\u001b[96m22\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     assert_eq!(joined.as_str(), \"/home/user/documents\");\n\u001b[1m\u001b[96m...\u001b[0m  \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m32\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     assert_eq!(joined.as_str(), \"/home/user/documents\");\n\u001b[1m\u001b[96m33\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m }\n   \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":970,"byte_end":1414,"line_start":36,"line_end":50,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"fn test_path_parent() {","highlight_start":1,"highlight_end":24},{"text":"    let path = Path::new(\"/home/user/file.txt\");","highlight_start":1,"highlight_end":49},{"text":"    let parent = path.parent().unwrap();","highlight_start":1,"highlight_end":41},{"text":"    assert_eq!(parent.as_str(), \"/home/user\");","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    let parent2 = parent.parent().unwrap();","highlight_start":1,"highlight_end":44},{"text":"    assert_eq!(parent2.as_str(), \"/home\");","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    let parent3 = parent2.parent().unwrap();","highlight_start":1,"highlight_end":45},{"text":"    assert_eq!(parent3.as_str(), \"\");","highlight_start":1,"highlight_end":38},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Root has no parent","highlight_start":1,"highlight_end":26},{"text":"    let root = Path::new(\"/\");","highlight_start":1,"highlight_end":31},{"text":"    assert!(root.parent().is_none());","highlight_start":1,"highlight_end":38},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":961,"byte_end":968,"line_start":35,"line_end":35,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[test]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\tests.rs:36:1\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m35\u001b[0m \u001b[1m\u001b[96m|\u001b[0m   #[test]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m36\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m fn test_path_parent() {\n\u001b[1m\u001b[96m37\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     let path = Path::new(\"/home/user/file.txt\");\n\u001b[1m\u001b[96m38\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     let parent = path.parent().unwrap();\n\u001b[1m\u001b[96m39\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     assert_eq!(parent.as_str(), \"/home/user\");\n\u001b[1m\u001b[96m...\u001b[0m  \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m49\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     assert!(root.parent().is_none());\n\u001b[1m\u001b[96m50\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m }\n   \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":1427,"byte_end":1728,"line_start":53,"line_end":62,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"fn test_path_file_name() {","highlight_start":1,"highlight_end":27},{"text":"    let path = Path::new(\"/home/user/file.txt\");","highlight_start":1,"highlight_end":49},{"text":"    assert_eq!(path.file_name(), Some(\"file.txt\"));","highlight_start":1,"highlight_end":52},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    let path = Path::new(\"/home/user/\");","highlight_start":1,"highlight_end":41},{"text":"    assert_eq!(path.file_name(), Some(\"user\"));","highlight_start":1,"highlight_end":48},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    let path = Path::new(\"/\");","highlight_start":1,"highlight_end":31},{"text":"    assert!(path.file_name().is_none());","highlight_start":1,"highlight_end":41},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":1418,"byte_end":1425,"line_start":52,"line_end":52,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[test]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\tests.rs:53:1\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m52\u001b[0m \u001b[1m\u001b[96m|\u001b[0m   #[test]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m53\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m fn test_path_file_name() {\n\u001b[1m\u001b[96m54\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     let path = Path::new(\"/home/user/file.txt\");\n\u001b[1m\u001b[96m55\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     assert_eq!(path.file_name(), Some(\"file.txt\"));\n\u001b[1m\u001b[96m...\u001b[0m  \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m61\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     assert!(path.file_name().is_none());\n\u001b[1m\u001b[96m62\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m }\n   \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":1741,"byte_end":1882,"line_start":65,"line_end":69,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"fn test_vfs_manager_creation() {","highlight_start":1,"highlight_end":33},{"text":"    let vfs = VfsManager::new();","highlight_start":1,"highlight_end":33},{"text":"    assert_eq!(vfs.count(), 0);","highlight_start":1,"highlight_end":32},{"text":"    assert!(vfs.mounts().is_empty());","highlight_start":1,"highlight_end":38},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":1732,"byte_end":1739,"line_start":64,"line_end":64,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[test]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\tests.rs:65:1\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m64\u001b[0m \u001b[1m\u001b[96m|\u001b[0m   #[test]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m65\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m fn test_vfs_manager_creation() {\n\u001b[1m\u001b[96m66\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     let vfs = VfsManager::new();\n\u001b[1m\u001b[96m67\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     assert_eq!(vfs.count(), 0);\n\u001b[1m\u001b[96m68\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     assert!(vfs.mounts().is_empty());\n\u001b[1m\u001b[96m69\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m }\n   \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":1895,"byte_end":2159,"line_start":72,"line_end":81,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"fn test_vfs_mount() {","highlight_start":1,"highlight_end":22},{"text":"    let mut vfs = VfsManager::new();","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    let mock_fs = Box::new(MockFs::new());","highlight_start":1,"highlight_end":43},{"text":"    vfs.mount(\"test\", mock_fs).unwrap();","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    assert_eq!(vfs.count(), 1);","highlight_start":1,"highlight_end":32},{"text":"    assert!(vfs.is_mounted(\"test\"));","highlight_start":1,"highlight_end":37},{"text":"    assert!(vfs.get(\"test\").is_some());","highlight_start":1,"highlight_end":40},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":1886,"byte_end":1893,"line_start":71,"line_end":71,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[test]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\tests.rs:72:1\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m71\u001b[0m \u001b[1m\u001b[96m|\u001b[0m   #[test]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m72\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m fn test_vfs_mount() {\n\u001b[1m\u001b[96m73\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     let mut vfs = VfsManager::new();\n\u001b[1m\u001b[96m74\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m75\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     let mock_fs = Box::new(MockFs::new());\n\u001b[1m\u001b[96m...\u001b[0m  \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m80\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     assert!(vfs.get(\"test\").is_some());\n\u001b[1m\u001b[96m81\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m }\n   \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":2172,"byte_end":2424,"line_start":84,"line_end":91,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"fn test_vfs_mount_duplicate() {","highlight_start":1,"highlight_end":32},{"text":"    let mut vfs = VfsManager::new();","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    vfs.mount(\"test\", Box::new(MockFs::new())).unwrap();","highlight_start":1,"highlight_end":57},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    let result = vfs.mount(\"test\", Box::new(MockFs::new()));","highlight_start":1,"highlight_end":61},{"text":"    assert_eq!(result, Err(VfsError::AlreadyMounted));","highlight_start":1,"highlight_end":55},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":2163,"byte_end":2170,"line_start":83,"line_end":83,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[test]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\tests.rs:84:1\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m83\u001b[0m \u001b[1m\u001b[96m|\u001b[0m   #[test]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m84\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m fn test_vfs_mount_duplicate() {\n\u001b[1m\u001b[96m85\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     let mut vfs = VfsManager::new();\n\u001b[1m\u001b[96m86\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m87\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     vfs.mount(\"test\", Box::new(MockFs::new())).unwrap();\n\u001b[1m\u001b[96m...\u001b[0m  \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m90\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     assert_eq!(result, Err(VfsError::AlreadyMounted));\n\u001b[1m\u001b[96m91\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m }\n   \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":2437,"byte_end":2957,"line_start":94,"line_end":108,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"fn test_vfs_mount_invalid_name() {","highlight_start":1,"highlight_end":35},{"text":"    let mut vfs = VfsManager::new();","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Empty name","highlight_start":1,"highlight_end":18},{"text":"    let result = vfs.mount(\"\", Box::new(MockFs::new()));","highlight_start":1,"highlight_end":57},{"text":"    assert_eq!(result, Err(VfsError::InvalidMountPoint));","highlight_start":1,"highlight_end":58},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Name with slash","highlight_start":1,"highlight_end":23},{"text":"    let result = vfs.mount(\"test/bad\", Box::new(MockFs::new()));","highlight_start":1,"highlight_end":65},{"text":"    assert_eq!(result, Err(VfsError::InvalidMountPoint));","highlight_start":1,"highlight_end":58},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Name with backslash","highlight_start":1,"highlight_end":27},{"text":"    let result = vfs.mount(\"test\\\\bad\", Box::new(MockFs::new()));","highlight_start":1,"highlight_end":66},{"text":"    assert_eq!(result, Err(VfsError::InvalidMountPoint));","highlight_start":1,"highlight_end":58},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":2428,"byte_end":2435,"line_start":93,"line_end":93,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[test]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\tests.rs:94:1\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m93\u001b[0m \u001b[1m\u001b[96m|\u001b[0m   #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n \u001b[1m\u001b[96m94\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m fn test_vfs_mount_invalid_name() {\n \u001b[1m\u001b[96m95\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     let mut vfs = VfsManager::new();\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m107\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     assert_eq!(result, Err(VfsError::InvalidMountPoint));\n\u001b[1m\u001b[96m108\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":2970,"byte_end":3241,"line_start":111,"line_end":120,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"fn test_vfs_unmount() {","highlight_start":1,"highlight_end":24},{"text":"    let mut vfs = VfsManager::new();","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    vfs.mount(\"test\", Box::new(MockFs::new())).unwrap();","highlight_start":1,"highlight_end":57},{"text":"    assert!(vfs.is_mounted(\"test\"));","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    vfs.unmount(\"test\").unwrap();","highlight_start":1,"highlight_end":34},{"text":"    assert!(!vfs.is_mounted(\"test\"));","highlight_start":1,"highlight_end":38},{"text":"    assert_eq!(vfs.count(), 0);","highlight_start":1,"highlight_end":32},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":2961,"byte_end":2968,"line_start":110,"line_end":110,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[test]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\tests.rs:111:1\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m110\u001b[0m \u001b[1m\u001b[96m|\u001b[0m   #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m111\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m fn test_vfs_unmount() {\n\u001b[1m\u001b[96m112\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     let mut vfs = VfsManager::new();\n\u001b[1m\u001b[96m113\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m114\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     vfs.mount(\"test\", Box::new(MockFs::new())).unwrap();\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m119\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     assert_eq!(vfs.count(), 0);\n\u001b[1m\u001b[96m120\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":3254,"byte_end":3430,"line_start":123,"line_end":128,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"fn test_vfs_unmount_not_mounted() {","highlight_start":1,"highlight_end":36},{"text":"    let mut vfs = VfsManager::new();","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    let result = vfs.unmount(\"nonexistent\");","highlight_start":1,"highlight_end":45},{"text":"    assert_eq!(result, Err(VfsError::NotMounted));","highlight_start":1,"highlight_end":51},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":3245,"byte_end":3252,"line_start":122,"line_end":122,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[test]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\tests.rs:123:1\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m122\u001b[0m \u001b[1m\u001b[96m|\u001b[0m   #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m123\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m fn test_vfs_unmount_not_mounted() {\n\u001b[1m\u001b[96m124\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     let mut vfs = VfsManager::new();\n\u001b[1m\u001b[96m125\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m126\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     let result = vfs.unmount(\"nonexistent\");\n\u001b[1m\u001b[96m127\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     assert_eq!(result, Err(VfsError::NotMounted));\n\u001b[1m\u001b[96m128\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":3443,"byte_end":3764,"line_start":131,"line_end":140,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"fn test_vfs_resolve_simple() {","highlight_start":1,"highlight_end":31},{"text":"    let mut vfs = VfsManager::new();","highlight_start":1,"highlight_end":37},{"text":"    let fs = Box::new(MockFs::new());","highlight_start":1,"highlight_end":38},{"text":"    vfs.mount(\"boot\", fs).unwrap();","highlight_start":1,"highlight_end":36},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    let (mount, _fs, rel_path) = vfs.resolve(&Path::new(\"/boot/kernel.bin\")).unwrap();","highlight_start":1,"highlight_end":87},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    assert_eq!(mount, \"boot\");","highlight_start":1,"highlight_end":31},{"text":"    assert_eq!(rel_path.as_str(), \"kernel.bin\");","highlight_start":1,"highlight_end":49},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":3434,"byte_end":3441,"line_start":130,"line_end":130,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[test]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\tests.rs:131:1\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m130\u001b[0m \u001b[1m\u001b[96m|\u001b[0m   #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m131\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m fn test_vfs_resolve_simple() {\n\u001b[1m\u001b[96m132\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     let mut vfs = VfsManager::new();\n\u001b[1m\u001b[96m133\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     let fs = Box::new(MockFs::new());\n\u001b[1m\u001b[96m134\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     vfs.mount(\"boot\", fs).unwrap();\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m139\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     assert_eq!(rel_path.as_str(), \"kernel.bin\");\n\u001b[1m\u001b[96m140\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":3777,"byte_end":4096,"line_start":143,"line_end":151,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"fn test_vfs_resolve_nested() {","highlight_start":1,"highlight_end":31},{"text":"    let mut vfs = VfsManager::new();","highlight_start":1,"highlight_end":37},{"text":"    vfs.mount(\"root\", Box::new(MockFs::new())).unwrap();","highlight_start":1,"highlight_end":57},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    let (mount, _fs, rel_path) = vfs.resolve(&Path::new(\"/root/home/user/file.txt\")).unwrap();","highlight_start":1,"highlight_end":95},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    assert_eq!(mount, \"root\");","highlight_start":1,"highlight_end":31},{"text":"    assert_eq!(rel_path.as_str(), \"home/user/file.txt\");","highlight_start":1,"highlight_end":57},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":3768,"byte_end":3775,"line_start":142,"line_end":142,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[test]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\tests.rs:143:1\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m142\u001b[0m \u001b[1m\u001b[96m|\u001b[0m   #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m143\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m fn test_vfs_resolve_nested() {\n\u001b[1m\u001b[96m144\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     let mut vfs = VfsManager::new();\n\u001b[1m\u001b[96m145\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     vfs.mount(\"root\", Box::new(MockFs::new())).unwrap();\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m150\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     assert_eq!(rel_path.as_str(), \"home/user/file.txt\");\n\u001b[1m\u001b[96m151\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":4109,"byte_end":4401,"line_start":154,"line_end":162,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"fn test_vfs_resolve_mount_point_only() {","highlight_start":1,"highlight_end":41},{"text":"    let mut vfs = VfsManager::new();","highlight_start":1,"highlight_end":37},{"text":"    vfs.mount(\"boot\", Box::new(MockFs::new())).unwrap();","highlight_start":1,"highlight_end":57},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    let (mount, _fs, rel_path) = vfs.resolve(&Path::new(\"/boot\")).unwrap();","highlight_start":1,"highlight_end":76},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    assert_eq!(mount, \"boot\");","highlight_start":1,"highlight_end":31},{"text":"    assert_eq!(rel_path.as_str(), \"\");","highlight_start":1,"highlight_end":39},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":4100,"byte_end":4107,"line_start":153,"line_end":153,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[test]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\tests.rs:154:1\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m153\u001b[0m \u001b[1m\u001b[96m|\u001b[0m   #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m154\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m fn test_vfs_resolve_mount_point_only() {\n\u001b[1m\u001b[96m155\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     let mut vfs = VfsManager::new();\n\u001b[1m\u001b[96m156\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     vfs.mount(\"boot\", Box::new(MockFs::new())).unwrap();\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m161\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     assert_eq!(rel_path.as_str(), \"\");\n\u001b[1m\u001b[96m162\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":4414,"byte_end":4588,"line_start":165,"line_end":170,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"fn test_vfs_resolve_not_mounted() {","highlight_start":1,"highlight_end":36},{"text":"    let vfs = VfsManager::new();","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    let result = vfs.resolve(&Path::new(\"/nonexistent/file.txt\"));","highlight_start":1,"highlight_end":67},{"text":"    assert!(result.is_none());","highlight_start":1,"highlight_end":31},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":4405,"byte_end":4412,"line_start":164,"line_end":164,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[test]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\tests.rs:165:1\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m164\u001b[0m \u001b[1m\u001b[96m|\u001b[0m   #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m165\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m fn test_vfs_resolve_not_mounted() {\n\u001b[1m\u001b[96m166\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     let vfs = VfsManager::new();\n\u001b[1m\u001b[96m167\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m168\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     let result = vfs.resolve(&Path::new(\"/nonexistent/file.txt\"));\n\u001b[1m\u001b[96m169\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     assert!(result.is_none());\n\u001b[1m\u001b[96m170\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":4601,"byte_end":5297,"line_start":173,"line_end":195,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"fn test_vfs_file_operations_through_manager() {","highlight_start":1,"highlight_end":48},{"text":"    let mut vfs = VfsManager::new();","highlight_start":1,"highlight_end":37},{"text":"    let fs = Box::new(MockFs::new());","highlight_start":1,"highlight_end":38},{"text":"    vfs.mount(\"test\", fs).unwrap();","highlight_start":1,"highlight_end":36},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Get filesystem reference","highlight_start":1,"highlight_end":32},{"text":"    let test_fs = vfs.get(\"test\").unwrap();","highlight_start":1,"highlight_end":44},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Write a file","highlight_start":1,"highlight_end":20},{"text":"    test_fs.write(&Path::new(\"/hello.txt\"), b\"Hello, World!\").unwrap();","highlight_start":1,"highlight_end":72},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Read it back","highlight_start":1,"highlight_end":20},{"text":"    let data = test_fs.read(&Path::new(\"/hello.txt\")).unwrap();","highlight_start":1,"highlight_end":64},{"text":"    assert_eq!(data, b\"Hello, World!\");","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Check it exists","highlight_start":1,"highlight_end":23},{"text":"    assert!(test_fs.exists(&Path::new(\"/hello.txt\")));","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Get stats","highlight_start":1,"highlight_end":17},{"text":"    let stat = test_fs.stat(&Path::new(\"/hello.txt\")).unwrap();","highlight_start":1,"highlight_end":64},{"text":"    assert_eq!(stat.size, 13);","highlight_start":1,"highlight_end":31},{"text":"    assert!(!stat.is_dir);","highlight_start":1,"highlight_end":27},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":4592,"byte_end":4599,"line_start":172,"line_end":172,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[test]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\tests.rs:173:1\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m172\u001b[0m \u001b[1m\u001b[96m|\u001b[0m   #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m173\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m fn test_vfs_file_operations_through_manager() {\n\u001b[1m\u001b[96m174\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     let mut vfs = VfsManager::new();\n\u001b[1m\u001b[96m175\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     let fs = Box::new(MockFs::new());\n\u001b[1m\u001b[96m176\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     vfs.mount(\"test\", fs).unwrap();\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m194\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     assert!(!stat.is_dir);\n\u001b[1m\u001b[96m195\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":5310,"byte_end":6464,"line_start":198,"line_end":226,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"fn test_vfs_multiple_filesystems() {","highlight_start":1,"highlight_end":37},{"text":"    let mut vfs = VfsManager::new();","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    vfs.mount(\"boot\", Box::new(MockFs::new())).unwrap();","highlight_start":1,"highlight_end":57},{"text":"    vfs.mount(\"root\", Box::new(MockFs::new())).unwrap();","highlight_start":1,"highlight_end":57},{"text":"    vfs.mount(\"data\", Box::new(MockFs::new())).unwrap();","highlight_start":1,"highlight_end":57},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    assert_eq!(vfs.count(), 3);","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    let mounts = vfs.mounts();","highlight_start":1,"highlight_end":31},{"text":"    assert!(mounts.contains(&\"boot\"));","highlight_start":1,"highlight_end":39},{"text":"    assert!(mounts.contains(&\"root\"));","highlight_start":1,"highlight_end":39},{"text":"    assert!(mounts.contains(&\"data\"));","highlight_start":1,"highlight_end":39},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Write to different filesystems","highlight_start":1,"highlight_end":38},{"text":"    vfs.get(\"boot\").unwrap().write(&Path::new(\"/kernel.bin\"), b\"boot\").unwrap();","highlight_start":1,"highlight_end":81},{"text":"    vfs.get(\"root\").unwrap().write(&Path::new(\"/etc/config\"), b\"root\").unwrap();","highlight_start":1,"highlight_end":81},{"text":"    vfs.get(\"data\").unwrap().write(&Path::new(\"/file.txt\"), b\"data\").unwrap();","highlight_start":1,"highlight_end":79},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Verify each filesystem has its own data","highlight_start":1,"highlight_end":47},{"text":"    let boot_data = vfs.get(\"boot\").unwrap().read(&Path::new(\"/kernel.bin\")).unwrap();","highlight_start":1,"highlight_end":87},{"text":"    assert_eq!(boot_data, b\"boot\");","highlight_start":1,"highlight_end":36},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    let root_data = vfs.get(\"root\").unwrap().read(&Path::new(\"/etc/config\")).unwrap();","highlight_start":1,"highlight_end":87},{"text":"    assert_eq!(root_data, b\"root\");","highlight_start":1,"highlight_end":36},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    let data_data = vfs.get(\"data\").unwrap().read(&Path::new(\"/file.txt\")).unwrap();","highlight_start":1,"highlight_end":85},{"text":"    assert_eq!(data_data, b\"data\");","highlight_start":1,"highlight_end":36},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":5301,"byte_end":5308,"line_start":197,"line_end":197,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[test]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\tests.rs:198:1\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m197\u001b[0m \u001b[1m\u001b[96m|\u001b[0m   #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m198\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m fn test_vfs_multiple_filesystems() {\n\u001b[1m\u001b[96m199\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     let mut vfs = VfsManager::new();\n\u001b[1m\u001b[96m200\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m201\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     vfs.mount(\"boot\", Box::new(MockFs::new())).unwrap();\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m225\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     assert_eq!(data_data, b\"data\");\n\u001b[1m\u001b[96m226\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":6477,"byte_end":6865,"line_start":229,"line_end":242,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"fn test_vfs_unmount_all() {","highlight_start":1,"highlight_end":28},{"text":"    let mut vfs = VfsManager::new();","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    vfs.mount(\"boot\", Box::new(MockFs::new())).unwrap();","highlight_start":1,"highlight_end":57},{"text":"    vfs.mount(\"root\", Box::new(MockFs::new())).unwrap();","highlight_start":1,"highlight_end":57},{"text":"    vfs.mount(\"data\", Box::new(MockFs::new())).unwrap();","highlight_start":1,"highlight_end":57},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    assert_eq!(vfs.count(), 3);","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    vfs.unmount_all().unwrap();","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    assert_eq!(vfs.count(), 0);","highlight_start":1,"highlight_end":32},{"text":"    assert!(vfs.mounts().is_empty());","highlight_start":1,"highlight_end":38},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\vfs\\tests.rs","byte_start":6468,"byte_end":6475,"line_start":228,"line_end":228,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[test]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\tests.rs:229:1\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m228\u001b[0m \u001b[1m\u001b[96m|\u001b[0m   #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m229\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m fn test_vfs_unmount_all() {\n\u001b[1m\u001b[96m230\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     let mut vfs = VfsManager::new();\n\u001b[1m\u001b[96m231\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m232\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     vfs.mount(\"boot\", Box::new(MockFs::new())).unwrap();\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m241\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     assert!(vfs.mounts().is_empty());\n\u001b[1m\u001b[96m242\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":3473,"byte_end":3477,"line_start":135,"line_end":135,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:135:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m135\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"couldn't read `heartwood\\src\\../../target/x86_64-unknown-none/release/hello`: The system cannot find the path specified. (os error 3)","code":null,"level":"error","spans":[{"file_name":"heartwood\\src\\test_programs.rs","byte_start":108,"byte_end":172,"line_start":4,"line_end":4,"column_start":30,"column_end":94,"is_primary":true,"text":[{"text":"pub const HELLO_ELF: &[u8] = include_bytes!(\"../../target/x86_64-unknown-none/release/hello\");","highlight_start":30,"highlight_end":94}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\test_programs.rs","byte_start":108,"byte_end":172,"line_start":4,"line_end":4,"column_start":30,"column_end":94,"is_primary":false,"text":[{"text":"pub const HELLO_ELF: &[u8] = include_bytes!(\"../../target/x86_64-unknown-none/release/hello\");","highlight_start":30,"highlight_end":94}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"include_bytes!","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":48445,"byte_end":48471,"line_start":1360,"line_end":1360,"column_start":5,"column_end":31,"is_primary":false,"text":[{"text":"    macro_rules! include_bytes {","highlight_start":5,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: couldn't read `heartwood\\src\\../../target/x86_64-unknown-none/release/hello`: The system cannot find the path specified. (os error 3)\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\test_programs.rs:4:30\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m4\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub const HELLO_ELF: &[u8] = include_bytes!(\"../../target/x86_64-unknown-none/release/hello\");\n  \u001b[1m\u001b[96m|\u001b[0m                              \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":3329,"byte_end":3333,"line_start":125,"line_end":125,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:125:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m125\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":3176,"byte_end":3180,"line_start":115,"line_end":115,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:115:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m115\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused import: `super::ThreadId`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\syscalls.rs","byte_start":1047,"byte_end":1062,"line_start":33,"line_end":33,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"use super::ThreadId;","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\syscalls.rs","byte_start":1043,"byte_end":1065,"line_start":33,"line_end":34,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use super::ThreadId;","highlight_start":1,"highlight_end":21},{"text":"use x86_64::VirtAddr;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused import: `super::ThreadId`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\loom_of_fate\\syscalls.rs:33:5\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m33\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use super::ThreadId;\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary parentheses around assigned value","code":{"code":"unused_parens","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\mana_pool\\user_space.rs","byte_start":9436,"byte_end":9437,"line_start":289,"line_end":289,"column_start":28,"column_end":29,"is_primary":true,"text":[{"text":"            let page_end = ((seg.vaddr + seg.memsz + 0xFFF) & !0xFFF);","highlight_start":28,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\mana_pool\\user_space.rs","byte_start":9477,"byte_end":9478,"line_start":289,"line_end":289,"column_start":69,"column_end":70,"is_primary":true,"text":[{"text":"            let page_end = ((seg.vaddr + seg.memsz + 0xFFF) & !0xFFF);","highlight_start":69,"highlight_end":70}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove these parentheses","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\mana_pool\\user_space.rs","byte_start":9436,"byte_end":9437,"line_start":289,"line_end":289,"column_start":28,"column_end":29,"is_primary":true,"text":[{"text":"            let page_end = ((seg.vaddr + seg.memsz + 0xFFF) & !0xFFF);","highlight_start":28,"highlight_end":29}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"heartwood\\src\\mana_pool\\user_space.rs","byte_start":9477,"byte_end":9478,"line_start":289,"line_end":289,"column_start":69,"column_end":70,"is_primary":true,"text":[{"text":"            let page_end = ((seg.vaddr + seg.memsz + 0xFFF) & !0xFFF);","highlight_start":69,"highlight_end":70}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary parentheses around assigned value\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\user_space.rs:289:28\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m289\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             let page_end = ((seg.vaddr + seg.memsz + 0xFFF) & !0xFFF);\n    \u001b[1m\u001b[96m|\u001b[0m                            \u001b[1m\u001b[93m^\u001b[0m                                        \u001b[1m\u001b[93m^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default\n\u001b[1m\u001b[96mhelp\u001b[0m: remove these parentheses\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m289\u001b[0m \u001b[91m- \u001b[0m            let page_end = \u001b[91m(\u001b[0m(seg.vaddr + seg.memsz + 0xFFF) & !0xFFF\u001b[91m)\u001b[0m;\n\u001b[1m\u001b[96m289\u001b[0m \u001b[92m+ \u001b[0m            let page_end = (seg.vaddr + seg.memsz + 0xFFF) & !0xFFF;\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"heartwood\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused import: `alloc::vec::Vec`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\vfs\\ext4\\superblock.rs","byte_start":360,"byte_end":375,"line_start":10,"line_end":10,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"use alloc::vec::Vec;","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\vfs\\ext4\\superblock.rs","byte_start":356,"byte_end":378,"line_start":10,"line_end":11,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::vec::Vec;","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused import: `alloc::vec::Vec`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\ext4\\superblock.rs:10:5\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m10\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use alloc::vec::Vec;\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^^^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused import: `alloc::vec::Vec`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\vfs\\ext4\\inode.rs","byte_start":403,"byte_end":418,"line_start":11,"line_end":11,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"use alloc::vec::Vec;","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\vfs\\ext4\\inode.rs","byte_start":399,"byte_end":421,"line_start":11,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::vec::Vec;","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused import: `alloc::vec::Vec`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\ext4\\inode.rs:11:5\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m11\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use alloc::vec::Vec;\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^^^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused import: `alloc::string::ToString`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\vfs\\ext4\\mod.rs","byte_start":1123,"byte_end":1146,"line_start":39,"line_end":39,"column_start":5,"column_end":28,"is_primary":true,"text":[{"text":"use alloc::string::ToString;","highlight_start":5,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\vfs\\ext4\\mod.rs","byte_start":1119,"byte_end":1149,"line_start":39,"line_end":40,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::ToString;","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused import: `alloc::string::ToString`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\ext4\\mod.rs:39:5\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m39\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use alloc::string::ToString;\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused import: `VesselId`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\groves\\lifecycle.rs","byte_start":389,"byte_end":397,"line_start":8,"line_end":8,"column_start":59,"column_end":67,"is_primary":true,"text":[{"text":"use crate::loom_of_fate::{self, ThreadId, ThreadPriority, VesselId};","highlight_start":59,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\groves\\lifecycle.rs","byte_start":387,"byte_end":397,"line_start":8,"line_end":8,"column_start":57,"column_end":67,"is_primary":true,"text":[{"text":"use crate::loom_of_fate::{self, ThreadId, ThreadPriority, VesselId};","highlight_start":57,"highlight_end":67}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused import: `VesselId`\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\groves\\lifecycle.rs:8:59\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m8\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use crate::loom_of_fate::{self, ThreadId, ThreadPriority, VesselId};\n  \u001b[1m\u001b[96m|\u001b[0m                                                           \u001b[1m\u001b[93m^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":3052,"byte_end":3056,"line_start":106,"line_end":106,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:106:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m106\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":2869,"byte_end":2873,"line_start":99,"line_end":99,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:99:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m99\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":2608,"byte_end":2612,"line_start":91,"line_end":91,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:91:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m91\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":2368,"byte_end":2372,"line_start":83,"line_end":83,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:83:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m83\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":2146,"byte_end":2150,"line_start":75,"line_end":75,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:75:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m75\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":2015,"byte_end":2019,"line_start":70,"line_end":70,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:70:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m70\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":1835,"byte_end":1839,"line_start":64,"line_end":64,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:64:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m64\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused import: `super::ThreadId`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\syscalls.rs","byte_start":1047,"byte_end":1062,"line_start":33,"line_end":33,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"use super::ThreadId;","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\syscalls.rs","byte_start":1043,"byte_end":1065,"line_start":33,"line_end":34,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use super::ThreadId;","highlight_start":1,"highlight_end":21},{"text":"use x86_64::VirtAddr;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused import: `super::ThreadId`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\loom_of_fate\\syscalls.rs:33:5\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m33\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use super::ThreadId;\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary parentheses around assigned value","code":{"code":"unused_parens","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\mana_pool\\user_space.rs","byte_start":9436,"byte_end":9437,"line_start":289,"line_end":289,"column_start":28,"column_end":29,"is_primary":true,"text":[{"text":"            let page_end = ((seg.vaddr + seg.memsz + 0xFFF) & !0xFFF);","highlight_start":28,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\mana_pool\\user_space.rs","byte_start":9477,"byte_end":9478,"line_start":289,"line_end":289,"column_start":69,"column_end":70,"is_primary":true,"text":[{"text":"            let page_end = ((seg.vaddr + seg.memsz + 0xFFF) & !0xFFF);","highlight_start":69,"highlight_end":70}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove these parentheses","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\mana_pool\\user_space.rs","byte_start":9436,"byte_end":9437,"line_start":289,"line_end":289,"column_start":28,"column_end":29,"is_primary":true,"text":[{"text":"            let page_end = ((seg.vaddr + seg.memsz + 0xFFF) & !0xFFF);","highlight_start":28,"highlight_end":29}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"heartwood\\src\\mana_pool\\user_space.rs","byte_start":9477,"byte_end":9478,"line_start":289,"line_end":289,"column_start":69,"column_end":70,"is_primary":true,"text":[{"text":"            let page_end = ((seg.vaddr + seg.memsz + 0xFFF) & !0xFFF);","highlight_start":69,"highlight_end":70}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary parentheses around assigned value\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\user_space.rs:289:28\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m289\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             let page_end = ((seg.vaddr + seg.memsz + 0xFFF) & !0xFFF);\n    \u001b[1m\u001b[96m|\u001b[0m                            \u001b[1m\u001b[93m^\u001b[0m                                        \u001b[1m\u001b[93m^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default\n\u001b[1m\u001b[96mhelp\u001b[0m: remove these parentheses\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m289\u001b[0m \u001b[91m- \u001b[0m            let page_end = \u001b[91m(\u001b[0m(seg.vaddr + seg.memsz + 0xFFF) & !0xFFF\u001b[91m)\u001b[0m;\n\u001b[1m\u001b[96m289\u001b[0m \u001b[92m+ \u001b[0m            let page_end = (seg.vaddr + seg.memsz + 0xFFF) & !0xFFF;\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":1567,"byte_end":1571,"line_start":55,"line_end":55,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:55:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m55\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":1484,"byte_end":1488,"line_start":50,"line_end":50,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:50:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m50\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused import: `super::*`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\vfs\\fat32\\mod.rs","byte_start":7028,"byte_end":7036,"line_start":232,"line_end":232,"column_start":9,"column_end":17,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":9,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\vfs\\fat32\\mod.rs","byte_start":7024,"byte_end":7037,"line_start":232,"line_end":232,"column_start":5,"column_end":18,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":18}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused import: `super::*`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\fat32\\mod.rs:232:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m232\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     use super::*;\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused import: `alloc::vec::Vec`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\vfs\\ext4\\superblock.rs","byte_start":360,"byte_end":375,"line_start":10,"line_end":10,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"use alloc::vec::Vec;","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\vfs\\ext4\\superblock.rs","byte_start":356,"byte_end":378,"line_start":10,"line_end":11,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::vec::Vec;","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused import: `alloc::vec::Vec`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\ext4\\superblock.rs:10:5\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m10\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use alloc::vec::Vec;\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^^^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused import: `alloc::vec::Vec`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\vfs\\ext4\\inode.rs","byte_start":403,"byte_end":418,"line_start":11,"line_end":11,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"use alloc::vec::Vec;","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\vfs\\ext4\\inode.rs","byte_start":399,"byte_end":421,"line_start":11,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::vec::Vec;","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused import: `alloc::vec::Vec`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\ext4\\inode.rs:11:5\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m11\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use alloc::vec::Vec;\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^^^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused import: `alloc::string::ToString`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\vfs\\ext4\\mod.rs","byte_start":1123,"byte_end":1146,"line_start":39,"line_end":39,"column_start":5,"column_end":28,"is_primary":true,"text":[{"text":"use alloc::string::ToString;","highlight_start":5,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\vfs\\ext4\\mod.rs","byte_start":1119,"byte_end":1149,"line_start":39,"line_end":40,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::ToString;","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused import: `alloc::string::ToString`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\ext4\\mod.rs:39:5\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m39\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use alloc::string::ToString;\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused import: `super::*`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\vfs\\ext4\\mod.rs","byte_start":5816,"byte_end":5824,"line_start":194,"line_end":194,"column_start":9,"column_end":17,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":9,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\vfs\\ext4\\mod.rs","byte_start":5812,"byte_end":5825,"line_start":194,"line_end":194,"column_start":5,"column_end":18,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":18}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused import: `super::*`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\ext4\\mod.rs:194:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m194\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     use super::*;\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":1352,"byte_end":1356,"line_start":44,"line_end":44,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:44:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m44\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused import: `VesselId`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\groves\\lifecycle.rs","byte_start":389,"byte_end":397,"line_start":8,"line_end":8,"column_start":59,"column_end":67,"is_primary":true,"text":[{"text":"use crate::loom_of_fate::{self, ThreadId, ThreadPriority, VesselId};","highlight_start":59,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\groves\\lifecycle.rs","byte_start":387,"byte_end":397,"line_start":8,"line_end":8,"column_start":57,"column_end":67,"is_primary":true,"text":[{"text":"use crate::loom_of_fate::{self, ThreadId, ThreadPriority, VesselId};","highlight_start":57,"highlight_end":67}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused import: `VesselId`\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\groves\\lifecycle.rs:8:59\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m8\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use crate::loom_of_fate::{self, ThreadId, ThreadPriority, VesselId};\n  \u001b[1m\u001b[96m|\u001b[0m                                                           \u001b[1m\u001b[93m^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":1128,"byte_end":1132,"line_start":37,"line_end":37,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:37:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m37\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":957,"byte_end":961,"line_start":30,"line_end":30,"column_start":3,"column_end":7,"is_primary":true,"text":[{"text":"#[test]","highlight_start":3,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:30:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m30\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[test]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::prelude::rust_2024::test;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"`#[panic_handler]` function required, but not found","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: `#[panic_handler]` function required, but not found\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `panic` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":910,"byte_end":915,"line_start":26,"line_end":26,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"        Err(e) => panic!(\"Evaluation failed: {}\", e),","highlight_start":19,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::panic;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `panic` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:26:19\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m26\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Err(e) => panic!(\"Evaluation failed: {}\", e),\n   \u001b[1m\u001b[96m|\u001b[0m                   \u001b[1m\u001b[91m^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::panic;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":817,"byte_end":826,"line_start":25,"line_end":25,"column_start":23,"column_end":32,"is_primary":true,"text":[{"text":"        Ok(result) => assert_eq!(result, expected, \"Expected {:?}, got {:?}\", expected, result),","highlight_start":23,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:25:23\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m25\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(result) => assert_eq!(result, expected, \"Expected {:?}, got {:?}\", expected, result),\n   \u001b[1m\u001b[96m|\u001b[0m                       \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::assert_eq;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `format` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":624,"byte_end":630,"line_start":19,"line_end":19,"column_start":38,"column_end":44,"is_primary":true,"text":[{"text":"    evaluator.eval(&ast).map_err(|e| format!(\"Runtime error: {:?}\", e))","highlight_start":38,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `format` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:19:38\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m19\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     evaluator.eval(&ast).map_err(|e| format!(\"Runtime error: {:?}\", e))\n   \u001b[1m\u001b[96m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `format` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":493,"byte_end":499,"line_start":15,"line_end":15,"column_start":42,"column_end":48,"is_primary":true,"text":[{"text":"    let ast = parser.parse().map_err(|e| format!(\"Parse error: {:?}\", e))?;","highlight_start":42,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `format` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:15:42\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m15\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     let ast = parser.parse().map_err(|e| format!(\"Parse error: {:?}\", e))?;\n   \u001b[1m\u001b[96m|\u001b[0m                                          \u001b[1m\u001b[91m^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `std`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the `x86_64-aethelos` target may not support the standard library","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`std` is required by `glimmer_weave` because it does not declare `#![no_std]`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider building the standard library from source with `cargo build -Zbuild-std`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `std`\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: the `x86_64-aethelos` target may not support the standard library\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `std` is required by `glimmer_weave` because it does not declare `#![no_std]`\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: consider building the standard library from source with `cargo build -Zbuild-std`\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot resolve a prelude import","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot resolve a prelude import\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":281,"byte_end":287,"line_start":8,"line_end":8,"column_start":25,"column_end":31,"is_primary":true,"text":[{"text":"fn run(source: &str) -> Result<Value, String> {","highlight_start":25,"highlight_end":31}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:8:25\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m8\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn run(source: &str) -> Result<Value, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `String` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":295,"byte_end":301,"line_start":8,"line_end":8,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"fn run(source: &str) -> Result<Value, String> {","highlight_start":39,"highlight_end":45}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":263,"byte_end":263,"line_start":8,"line_end":8,"column_start":7,"column_end":7,"is_primary":true,"text":[{"text":"fn run(source: &str) -> Result<Value, String> {","highlight_start":7,"highlight_end":7}],"label":null,"suggested_replacement":"<String>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `String` in this scope\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:8:39\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m8\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn run(source: &str) -> Result<Value, String> {\n  \u001b[1m\u001b[96m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m8\u001b[0m \u001b[1m\u001b[96m| \u001b[0mfn run\u001b[92m<String>\u001b[0m(source: &str) -> Result<Value, String> {\n  \u001b[1m\u001b[96m|\u001b[0m       \u001b[92m++++++++\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":803,"byte_end":805,"line_start":25,"line_end":25,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(result) => assert_eq!(result, expected, \"Expected {:?}, got {:?}\", expected, result),","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:25:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m25\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(result) => assert_eq!(result, expected, \"Expected {:?}, got {:?}\", expected, result),\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Err` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":900,"byte_end":903,"line_start":26,"line_end":26,"column_start":9,"column_end":12,"is_primary":true,"text":[{"text":"        Err(e) => panic!(\"Evaluation failed: {}\", e),","highlight_start":9,"highlight_end":12}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Err` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:26:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m26\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Err(e) => panic!(\"Evaluation failed: {}\", e),\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"`#[panic_handler]` function required, but not found","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: `#[panic_handler]` function required, but not found\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/ancient-runes/corelib#0.1.0","manifest_path":"F:\\OS\\ancient-runes\\corelib\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"corelib","src_path":"F:\\OS\\ancient-runes\\corelib\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"ancient-runes\\corelib\\src\\syscalls.rs","byte_start":12525,"byte_end":12727,"line_start":521,"line_end":525,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn test_errno_str() {","highlight_start":5,"highlight_end":26},{"text":"        assert_eq!(errno_str(EPERM), \"Operation not permitted\");","highlight_start":1,"highlight_end":65},{"text":"        assert_eq!(errno_str(ENOMEM), \"Out of memory\");","highlight_start":1,"highlight_end":56},{"text":"        assert_eq!(errno_str(-999), \"Unknown error\");","highlight_start":1,"highlight_end":54},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"ancient-runes\\corelib\\src\\syscalls.rs","byte_start":12513,"byte_end":12520,"line_start":520,"line_end":520,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    #[test]","highlight_start":5,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[test]","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":59508,"byte_end":59522,"line_start":1649,"line_end":1649,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    pub macro test($item:item) {","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mancient-runes\\corelib\\src\\syscalls.rs:521:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m520\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96min this attribute macro expansion\u001b[0m\n\u001b[1m\u001b[96m521\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m     fn test_errno_str() {\n\u001b[1m\u001b[96m522\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(errno_str(EPERM), \"Operation not permitted\");\n\u001b[1m\u001b[96m523\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(errno_str(ENOMEM), \"Out of memory\");\n\u001b[1m\u001b[96m524\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         assert_eq!(errno_str(-999), \"Unknown error\");\n\u001b[1m\u001b[96m525\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mcan't find crate\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/ancient-runes/corelib#0.1.0","manifest_path":"F:\\OS\\ancient-runes\\corelib\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"corelib","src_path":"F:\\OS\\ancient-runes\\corelib\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"ancient-runes\\corelib\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/ancient-runes/corelib#0.1.0","manifest_path":"F:\\OS\\ancient-runes\\corelib\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"corelib","src_path":"F:\\OS\\ancient-runes\\corelib\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `matches` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11607,"byte_end":11614,"line_start":411,"line_end":411,"column_start":26,"column_end":33,"is_primary":true,"text":[{"text":"            let is_eof = matches!(token, Token::Eof);","highlight_start":26,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::matches;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `matches` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:411:26\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m411\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             let is_eof = matches!(token, Token::Eof);\n    \u001b[1m\u001b[96m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::matches;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/ancient-runes/corelib#0.1.0","manifest_path":"F:\\OS\\ancient-runes\\corelib\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"corelib","src_path":"F:\\OS\\ancient-runes\\corelib\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"`#[panic_handler]` function required, but not found","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: `#[panic_handler]` function required, but not found\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":322,"byte_end":328,"line_start":11,"line_end":11,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":247,"byte_end":247,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\token.rs:11:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m11\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":579,"byte_end":585,"line_start":24,"line_end":24,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":247,"byte_end":247,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\token.rs:24:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m24\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, PartialEq)]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `matches` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":3889,"byte_end":3896,"line_start":188,"line_end":188,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"        matches!(","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":247,"byte_end":247,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::matches;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `matches` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\token.rs:188:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m188\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         matches!(\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::matches;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `matches` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":5152,"byte_end":5159,"line_start":231,"line_end":231,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"        matches!(","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":247,"byte_end":247,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::matches;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `matches` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\token.rs:231:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m231\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         matches!(\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::matches;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":8206,"byte_end":8210,"line_start":326,"line_end":326,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[test]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":8185,"byte_end":8185,"line_start":324,"line_end":324,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\token.rs:326:7\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m326\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m324\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":8254,"byte_end":8260,"line_start":328,"line_end":328,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        assert!(Token::Bind.is_keyword());","highlight_start":9,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":8185,"byte_end":8185,"line_start":324,"line_end":324,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\token.rs:328:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m328\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert!(Token::Bind.is_keyword());\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m324\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `to_string` found for reference `&'static str` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":1212,"byte_end":1221,"line_start":39,"line_end":39,"column_start":51,"column_end":60,"is_primary":true,"text":[{"text":"    assert_eval(r#\"\"hello\"\"#, Value::Text(\"hello\".to_string()));","highlight_start":51,"highlight_end":60}],"label":"method not found in `&'static str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `ToString` which provides `to_string` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::string::ToString;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `to_string` found for reference `&'static str` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:39:51\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m39\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     assert_eval(r#\"\"hello\"\"#, Value::Text(\"hello\".to_string()));\n   \u001b[1m\u001b[96m|\u001b[0m                                                   \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&'static str`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: items from traits can only be used if the trait is in scope\n\u001b[1m\u001b[96mhelp\u001b[0m: trait `ToString` which provides `to_string` is implemented but not in scope; perhaps you want to import it\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use alloc::string::ToString;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":8297,"byte_end":8303,"line_start":329,"line_end":329,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        assert!(Token::Chant.is_keyword());","highlight_start":9,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":8185,"byte_end":8185,"line_start":324,"line_end":324,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\token.rs:329:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m329\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert!(Token::Chant.is_keyword());\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m324\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `to_string` found for reference `&'static str` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":1277,"byte_end":1286,"line_start":40,"line_end":40,"column_start":51,"column_end":60,"is_primary":true,"text":[{"text":"    assert_eval(r#\"\"world\"\"#, Value::Text(\"world\".to_string()));","highlight_start":51,"highlight_end":60}],"label":"method not found in `&'static str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `ToString` which provides `to_string` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::string::ToString;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `to_string` found for reference `&'static str` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:40:51\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m40\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     assert_eval(r#\"\"world\"\"#, Value::Text(\"world\".to_string()));\n   \u001b[1m\u001b[96m|\u001b[0m                                                   \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&'static str`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: items from traits can only be used if the trait is in scope\n\u001b[1m\u001b[96mhelp\u001b[0m: trait `ToString` which provides `to_string` is implemented but not in scope; perhaps you want to import it\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use alloc::string::ToString;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":8341,"byte_end":8347,"line_start":330,"line_end":330,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        assert!(!Token::Ident(\"foo\".to_string()).is_keyword());","highlight_start":9,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":8185,"byte_end":8185,"line_start":324,"line_end":324,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\token.rs:330:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m330\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert!(!Token::Ident(\"foo\".to_string()).is_keyword());\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m324\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `to_string` found for reference `&'static str` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":1332,"byte_end":1341,"line_start":41,"line_end":41,"column_start":41,"column_end":50,"is_primary":true,"text":[{"text":"    assert_eval(r#\"\"\"\"#, Value::Text(\"\".to_string()));","highlight_start":41,"highlight_end":50}],"label":"method not found in `&'static str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `ToString` which provides `to_string` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::string::ToString;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `to_string` found for reference `&'static str` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:41:41\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m41\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     assert_eval(r#\"\"\"\"#, Value::Text(\"\".to_string()));\n   \u001b[1m\u001b[96m|\u001b[0m                                         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&'static str`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: items from traits can only be used if the trait is in scope\n\u001b[1m\u001b[96mhelp\u001b[0m: trait `ToString` which provides `to_string` is implemented but not in scope; perhaps you want to import it\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use alloc::string::ToString;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":8405,"byte_end":8411,"line_start":331,"line_end":331,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        assert!(!Token::Number(42.0).is_keyword());","highlight_start":9,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":8185,"byte_end":8185,"line_start":324,"line_end":324,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\token.rs:331:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m331\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert!(!Token::Number(42.0).is_keyword());\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m324\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `to_string` found for reference `&'static str` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":2126,"byte_end":2135,"line_start":72,"line_end":72,"column_start":73,"column_end":82,"is_primary":true,"text":[{"text":"    assert_eval(r#\"\"hello\" + \" \" + \"world\"\"#, Value::Text(\"hello world\".to_string()));","highlight_start":73,"highlight_end":82}],"label":"method not found in `&'static str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `ToString` which provides `to_string` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::string::ToString;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `to_string` found for reference `&'static str` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:72:73\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m72\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     assert_eval(r#\"\"hello\" + \" \" + \"world\"\"#, Value::Text(\"hello world\".to_string()));\n   \u001b[1m\u001b[96m|\u001b[0m                                                                         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&'static str`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: items from traits can only be used if the trait is in scope\n\u001b[1m\u001b[96mhelp\u001b[0m: trait `ToString` which provides `to_string` is implemented but not in scope; perhaps you want to import it\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use alloc::string::ToString;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":8462,"byte_end":8466,"line_start":334,"line_end":334,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[test]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":8185,"byte_end":8185,"line_start":324,"line_end":324,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\token.rs:334:7\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m334\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m324\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":8508,"byte_end":8514,"line_start":336,"line_end":336,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        assert!(Token::Bind.is_statement_start());","highlight_start":9,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":8185,"byte_end":8185,"line_start":324,"line_end":324,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\token.rs:336:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m336\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert!(Token::Bind.is_statement_start());\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m324\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":8559,"byte_end":8565,"line_start":337,"line_end":337,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        assert!(Token::For.is_statement_start());","highlight_start":9,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":8185,"byte_end":8185,"line_start":324,"line_end":324,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\token.rs:337:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m337\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert!(Token::For.is_statement_start());\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m324\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":8609,"byte_end":8615,"line_start":338,"line_end":338,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        assert!(Token::Ident(\"foo\".to_string()).is_statement_start());","highlight_start":9,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":8185,"byte_end":8185,"line_start":324,"line_end":324,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\token.rs:338:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m338\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert!(Token::Ident(\"foo\".to_string()).is_statement_start());\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m324\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":8680,"byte_end":8686,"line_start":339,"line_end":339,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        assert!(!Token::Then.is_statement_start());","highlight_start":9,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":8185,"byte_end":8185,"line_start":324,"line_end":324,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\token.rs:339:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m339\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert!(!Token::Then.is_statement_start());\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m324\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":8732,"byte_end":8738,"line_start":340,"line_end":340,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        assert!(!Token::Plus.is_statement_start());","highlight_start":9,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":8185,"byte_end":8185,"line_start":324,"line_end":324,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\token.rs:340:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m340\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert!(!Token::Plus.is_statement_start());\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m324\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11815,"byte_end":11819,"line_start":427,"line_end":427,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[test]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:427:7\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m427\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11996,"byte_end":12005,"line_start":433,"line_end":433,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[0], Token::Bind);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:433:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m433\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[0], Token::Bind);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":12040,"byte_end":12049,"line_start":434,"line_end":434,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[1], Token::Weave);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:434:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m434\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[1], Token::Weave);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":12085,"byte_end":12094,"line_start":435,"line_end":435,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[2], Token::Set);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:435:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m435\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[2], Token::Set);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":12128,"byte_end":12137,"line_start":436,"line_end":436,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[3], Token::To);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:436:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m436\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[3], Token::To);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":12170,"byte_end":12179,"line_start":437,"line_end":437,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[4], Token::Should);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:437:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m437\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[4], Token::Should);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":12216,"byte_end":12225,"line_start":438,"line_end":438,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[5], Token::Then);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:438:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m438\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[5], Token::Then);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/ancient-runes/corelib#0.1.0","manifest_path":"F:\\OS\\ancient-runes\\corelib\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"corelib","src_path":"F:\\OS\\ancient-runes\\corelib\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0463`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mFor more information about this error, try `rustc --explain E0463`.\u001b[0m\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":12260,"byte_end":12269,"line_start":439,"line_end":439,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[6], Token::End);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:439:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m439\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[6], Token::End);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":12308,"byte_end":12312,"line_start":442,"line_end":442,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[test]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:442:7\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m442\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `to_string` found for reference `&'static str` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":6050,"byte_end":6059,"line_start":280,"line_end":280,"column_start":45,"column_end":54,"is_primary":true,"text":[{"text":"    assert_eval(source, Value::Text(\"Elara\".to_string()));","highlight_start":45,"highlight_end":54}],"label":"method not found in `&'static str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `ToString` which provides `to_string` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::string::ToString;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `to_string` found for reference `&'static str` in the current scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:280:45\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m280\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     assert_eval(source, Value::Text(\"Elara\".to_string()));\n    \u001b[1m\u001b[96m|\u001b[0m                                             \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&'static str`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: items from traits can only be used if the trait is in scope\n\u001b[1m\u001b[96mhelp\u001b[0m: trait `ToString` which provides `to_string` is implemented but not in scope; perhaps you want to import it\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use alloc::string::ToString;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":12470,"byte_end":12479,"line_start":448,"line_end":448,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[0], Token::Number(42.0));","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:448:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m448\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[0], Token::Number(42.0));\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"no method named `to_string` found for reference `&'static str` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":6641,"byte_end":6650,"line_start":316,"line_end":316,"column_start":53,"column_end":62,"is_primary":true,"text":[{"text":"    assert_eval(source, Value::Text(\"Hello, World!\".to_string()));","highlight_start":53,"highlight_end":62}],"label":"method not found in `&'static str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `ToString` which provides `to_string` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\tests\\interpreter_tests.rs","byte_start":134,"byte_end":134,"line_start":5,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use glimmer_weave::{Lexer, Parser, Evaluator, Value};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::string::ToString;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `to_string` found for reference `&'static str` in the current scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\tests\\interpreter_tests.rs:316:53\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m316\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     assert_eval(source, Value::Text(\"Hello, World!\".to_string()));\n    \u001b[1m\u001b[96m|\u001b[0m                                                     \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&'static str`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: items from traits can only be used if the trait is in scope\n\u001b[1m\u001b[96mhelp\u001b[0m: trait `ToString` which provides `to_string` is implemented but not in scope; perhaps you want to import it\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[92m+ use alloc::string::ToString;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":12522,"byte_end":12531,"line_start":449,"line_end":449,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[1], Token::Number(3.14));","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:449:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m449\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[1], Token::Number(3.14));\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":12574,"byte_end":12583,"line_start":450,"line_end":450,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[2], Token::Number(0.0));","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:450:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m450\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[2], Token::Number(0.0));\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0412, E0463, E0531, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mSome errors have detailed explanations: E0412, E0463, E0531, E0599.\u001b[0m\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"interpreter_tests","src_path":"F:\\OS\\groves\\glimmer_weave\\tests\\interpreter_tests.rs","edition":"2021","doc":false,"doctest":false,"test":true},"message":{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0412`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mFor more information about an error, try `rustc --explain E0412`.\u001b[0m\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":12625,"byte_end":12634,"line_start":451,"line_end":451,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[3], Token::Number(100.5));","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:451:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m451\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[3], Token::Number(100.5));\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":12683,"byte_end":12687,"line_start":454,"line_end":454,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[test]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:454:7\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m454\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":12863,"byte_end":12872,"line_start":460,"line_end":460,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[0], Token::Text(\"hello\".to_string()));","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:460:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m460\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[0], Token::Text(\"hello\".to_string()));\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":12928,"byte_end":12937,"line_start":461,"line_end":461,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[1], Token::Text(\"world\".to_string()));","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:461:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m461\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[1], Token::Text(\"world\".to_string()));\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":12993,"byte_end":13002,"line_start":462,"line_end":462,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[2], Token::Text(\"test\\nstring\".to_string()));","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:462:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m462\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[2], Token::Text(\"test\\nstring\".to_string()));\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":13070,"byte_end":13074,"line_start":465,"line_end":465,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[test]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:465:7\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m465\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":13246,"byte_end":13255,"line_start":471,"line_end":471,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[0], Token::Ident(\"foo\".to_string()));","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:471:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m471\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[0], Token::Ident(\"foo\".to_string()));\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":13310,"byte_end":13319,"line_start":472,"line_end":472,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[1], Token::Ident(\"bar_baz\".to_string()));","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:472:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m472\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[1], Token::Ident(\"bar_baz\".to_string()));\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":13378,"byte_end":13387,"line_start":473,"line_end":473,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[2], Token::Ident(\"_test\".to_string()));","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:473:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m473\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[2], Token::Ident(\"_test\".to_string()));\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":13444,"byte_end":13453,"line_start":474,"line_end":474,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[3], Token::Ident(\"name123\".to_string()));","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:474:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m474\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[3], Token::Ident(\"name123\".to_string()));\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":13517,"byte_end":13521,"line_start":477,"line_end":477,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[test]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:477:7\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m477\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":13687,"byte_end":13696,"line_start":483,"line_end":483,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[0], Token::Plus);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:483:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m483\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[0], Token::Plus);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":13731,"byte_end":13740,"line_start":484,"line_end":484,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[1], Token::Minus);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:484:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m484\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[1], Token::Minus);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":13776,"byte_end":13785,"line_start":485,"line_end":485,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[2], Token::Star);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:485:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m485\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[2], Token::Star);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":13820,"byte_end":13829,"line_start":486,"line_end":486,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[3], Token::Slash);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:486:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m486\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[3], Token::Slash);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/network_sprite#0.1.0","manifest_path":"F:\\OS\\groves\\network_sprite\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"network_sprite","src_path":"F:\\OS\\groves\\network_sprite\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"groves\\network_sprite\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":13865,"byte_end":13874,"line_start":487,"line_end":487,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[4], Token::Percent);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:487:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m487\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[4], Token::Percent);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/network_sprite#0.1.0","manifest_path":"F:\\OS\\groves\\network_sprite\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"network_sprite","src_path":"F:\\OS\\groves\\network_sprite\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":13912,"byte_end":13921,"line_start":488,"line_end":488,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[5], Token::Greater);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:488:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m488\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[5], Token::Greater);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/network_sprite#0.1.0","manifest_path":"F:\\OS\\groves\\network_sprite\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"network_sprite","src_path":"F:\\OS\\groves\\network_sprite\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"`#[panic_handler]` function required, but not found","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: `#[panic_handler]` function required, but not found\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":13959,"byte_end":13968,"line_start":489,"line_end":489,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[6], Token::Less);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:489:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m489\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[6], Token::Less);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":14003,"byte_end":14012,"line_start":490,"line_end":490,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[7], Token::GreaterEq);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:490:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m490\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[7], Token::GreaterEq);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":14052,"byte_end":14061,"line_start":491,"line_end":491,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[8], Token::LessEq);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:491:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m491\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[8], Token::LessEq);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":14098,"byte_end":14107,"line_start":492,"line_end":492,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[9], Token::Pipe);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:492:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m492\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[9], Token::Pipe);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":14147,"byte_end":14151,"line_start":495,"line_end":495,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[test]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:495:7\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m495\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":14314,"byte_end":14323,"line_start":501,"line_end":501,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[0], Token::LeftParen);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:501:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m501\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[0], Token::LeftParen);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":14363,"byte_end":14372,"line_start":502,"line_end":502,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[1], Token::RightParen);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:502:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m502\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[1], Token::RightParen);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":14413,"byte_end":14422,"line_start":503,"line_end":503,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[2], Token::LeftBracket);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:503:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m503\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[2], Token::LeftBracket);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":14464,"byte_end":14473,"line_start":504,"line_end":504,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[3], Token::RightBracket);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:504:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m504\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[3], Token::RightBracket);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-artifact","package_id":"path+file:///F:/OS/groves/lanthir_grove#0.1.0","manifest_path":"F:\\OS\\groves\\lanthir_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"lanthir_grove","src_path":"F:\\OS\\groves\\lanthir_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\liblanthir_grove-69fd9036090e6dc1.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/network_sprite#0.1.0","manifest_path":"F:\\OS\\groves\\network_sprite\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"network_sprite","src_path":"F:\\OS\\groves\\network_sprite\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `data`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"groves\\network_sprite\\src\\lib.rs","byte_start":1730,"byte_end":1734,"line_start":74,"line_end":74,"column_start":46,"column_end":50,"is_primary":true,"text":[{"text":"    pub fn send(&mut self, id: ConnectionId, data: &[u8]) -> Result<(), NetworkError> {","highlight_start":46,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"groves\\network_sprite\\src\\lib.rs","byte_start":1730,"byte_end":1734,"line_start":74,"line_end":74,"column_start":46,"column_end":50,"is_primary":true,"text":[{"text":"    pub fn send(&mut self, id: ConnectionId, data: &[u8]) -> Result<(), NetworkError> {","highlight_start":46,"highlight_end":50}],"label":null,"suggested_replacement":"_data","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `data`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\network_sprite\\src\\lib.rs:74:46\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m74\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn send(&mut self, id: ConnectionId, data: &[u8]) -> Result<(), NetworkError> {\n   \u001b[1m\u001b[96m|\u001b[0m                                              \u001b[1m\u001b[93m^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_data`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-artifact","package_id":"path+file:///F:/OS/groves/network_sprite#0.1.0","manifest_path":"F:\\OS\\groves\\network_sprite\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"network_sprite","src_path":"F:\\OS\\groves\\network_sprite\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["F:\\OS\\target\\x86_64-aethelos\\debug\\deps\\libnetwork_sprite-a1c84a8d746a8d22.rmeta"],"executable":null,"fresh":true}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":14516,"byte_end":14525,"line_start":505,"line_end":505,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[4], Token::LeftBrace);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:505:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m505\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[4], Token::LeftBrace);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":14565,"byte_end":14574,"line_start":506,"line_end":506,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[5], Token::RightBrace);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:506:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m506\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[5], Token::RightBrace);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/awakening/heartwood_loader#0.1.0","manifest_path":"F:\\OS\\awakening\\heartwood_loader\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"heartwood_loader","src_path":"F:\\OS\\awakening\\heartwood_loader\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"awakening\\heartwood_loader\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/awakening/heartwood_loader#0.1.0","manifest_path":"F:\\OS\\awakening\\heartwood_loader\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"heartwood_loader","src_path":"F:\\OS\\awakening\\heartwood_loader\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"`#[panic_handler]` function required, but not found","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: `#[panic_handler]` function required, but not found\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":14615,"byte_end":14624,"line_start":507,"line_end":507,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[6], Token::Comma);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:507:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m507\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[6], Token::Comma);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/network_sprite#0.1.0","manifest_path":"F:\\OS\\groves\\network_sprite\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"network_sprite","src_path":"F:\\OS\\groves\\network_sprite\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `data`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"groves\\network_sprite\\src\\lib.rs","byte_start":1730,"byte_end":1734,"line_start":74,"line_end":74,"column_start":46,"column_end":50,"is_primary":true,"text":[{"text":"    pub fn send(&mut self, id: ConnectionId, data: &[u8]) -> Result<(), NetworkError> {","highlight_start":46,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"groves\\network_sprite\\src\\lib.rs","byte_start":1730,"byte_end":1734,"line_start":74,"line_end":74,"column_start":46,"column_end":50,"is_primary":true,"text":[{"text":"    pub fn send(&mut self, id: ConnectionId, data: &[u8]) -> Result<(), NetworkError> {","highlight_start":46,"highlight_end":50}],"label":null,"suggested_replacement":"_data","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `data`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\network_sprite\\src\\lib.rs:74:46\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m74\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn send(&mut self, id: ConnectionId, data: &[u8]) -> Result<(), NetworkError> {\n   \u001b[1m\u001b[96m|\u001b[0m                                              \u001b[1m\u001b[93m^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_data`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/awakening/heartwood_loader#0.1.0","manifest_path":"F:\\OS\\awakening\\heartwood_loader\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"heartwood_loader","src_path":"F:\\OS\\awakening\\heartwood_loader\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0463`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mFor more information about this error, try `rustc --explain E0463`.\u001b[0m\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":14660,"byte_end":14669,"line_start":508,"line_end":508,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[7], Token::Colon);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:508:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m508\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[7], Token::Colon);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":14705,"byte_end":14714,"line_start":509,"line_end":509,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[8], Token::Dot);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:509:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m509\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[8], Token::Dot);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/network_sprite#0.1.0","manifest_path":"F:\\OS\\groves\\network_sprite\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"network_sprite","src_path":"F:\\OS\\groves\\network_sprite\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0463`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mFor more information about this error, try `rustc --explain E0463`.\u001b[0m\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":14753,"byte_end":14757,"line_start":512,"line_end":512,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[test]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:512:7\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m512\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":14917,"byte_end":14926,"line_start":518,"line_end":518,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[0], Token::Ident(\"x\".to_string()));","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:518:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m518\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[0], Token::Ident(\"x\".to_string()));\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":14979,"byte_end":14988,"line_start":519,"line_end":519,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[1], Token::IsNot);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:519:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m519\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[1], Token::IsNot);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":15024,"byte_end":15033,"line_start":520,"line_end":520,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[2], Token::Ident(\"y\".to_string()));","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:520:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m520\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[2], Token::Ident(\"y\".to_string()));\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":15091,"byte_end":15095,"line_start":523,"line_end":523,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[test]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:523:7\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m523\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":15359,"byte_end":15368,"line_start":535,"line_end":535,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[0], Token::Bind);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:535:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m535\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[0], Token::Bind);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":15403,"byte_end":15412,"line_start":536,"line_end":536,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[1], Token::Ident(\"x\".to_string()));","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:536:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m536\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[1], Token::Ident(\"x\".to_string()));\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":15465,"byte_end":15474,"line_start":537,"line_end":537,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[2], Token::To);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:537:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m537\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[2], Token::To);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":15507,"byte_end":15516,"line_start":538,"line_end":538,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[3], Token::Number(42.0));","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:538:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m538\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[3], Token::Number(42.0));\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":15559,"byte_end":15568,"line_start":539,"line_end":539,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[4], Token::Newline);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:539:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m539\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[4], Token::Newline);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":15639,"byte_end":15648,"line_start":542,"line_end":542,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[5], Token::Bind);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:542:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m542\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[5], Token::Bind);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":15683,"byte_end":15692,"line_start":543,"line_end":543,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[6], Token::Ident(\"name\".to_string()));","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:543:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m543\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[6], Token::Ident(\"name\".to_string()));\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":15748,"byte_end":15757,"line_start":544,"line_end":544,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[7], Token::To);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:544:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m544\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[7], Token::To);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":15790,"byte_end":15799,"line_start":545,"line_end":545,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[8], Token::Text(\"Elara\".to_string()));","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:545:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m545\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[8], Token::Text(\"Elara\".to_string()));\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":15855,"byte_end":15864,"line_start":546,"line_end":546,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[9], Token::Newline);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:546:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m546\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[9], Token::Newline);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":15933,"byte_end":15942,"line_start":549,"line_end":549,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[10], Token::Should);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:549:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m549\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[10], Token::Should);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":15980,"byte_end":15989,"line_start":550,"line_end":550,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[11], Token::Ident(\"x\".to_string()));","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:550:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m550\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[11], Token::Ident(\"x\".to_string()));\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":16043,"byte_end":16052,"line_start":551,"line_end":551,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[12], Token::Greater);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:551:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m551\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[12], Token::Greater);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":16091,"byte_end":16100,"line_start":552,"line_end":552,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[13], Token::Number(40.0));","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:552:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m552\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[13], Token::Number(40.0));\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":16144,"byte_end":16153,"line_start":553,"line_end":553,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[14], Token::Then);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:553:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m553\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[14], Token::Then);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":16194,"byte_end":16198,"line_start":556,"line_end":556,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[test]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:556:7\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m556\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":16452,"byte_end":16461,"line_start":566,"line_end":566,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[0], Token::Newline); // After first comment","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:566:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m566\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[0], Token::Newline); // After first comment\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":16522,"byte_end":16531,"line_start":567,"line_end":567,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[1], Token::Bind);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:567:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m567\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[1], Token::Bind);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":16566,"byte_end":16575,"line_start":568,"line_end":568,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[2], Token::Ident(\"x\".to_string()));","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:568:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m568\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[2], Token::Ident(\"x\".to_string()));\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":16628,"byte_end":16637,"line_start":569,"line_end":569,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[3], Token::To);","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:569:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m569\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[3], Token::To);\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":16670,"byte_end":16679,"line_start":570,"line_end":570,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(tokens[4], Token::Number(42.0));","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11794,"byte_end":11794,"line_start":425,"line_end":425,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:570:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m570\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(tokens[4], Token::Number(42.0));\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\ast.rs","byte_start":349,"byte_end":355,"line_start":13,"line_end":13,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\ast.rs","byte_start":236,"byte_end":236,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\ast.rs:13:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, PartialEq)]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\ast.rs","byte_start":3598,"byte_end":3604,"line_start":163,"line_end":163,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\ast.rs","byte_start":236,"byte_end":236,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\ast.rs:163:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m163\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\ast.rs","byte_start":4004,"byte_end":4010,"line_start":186,"line_end":186,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\ast.rs","byte_start":236,"byte_end":236,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\ast.rs:186:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m186\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\ast.rs","byte_start":4155,"byte_end":4161,"line_start":193,"line_end":193,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\ast.rs","byte_start":236,"byte_end":236,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\ast.rs:193:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m193\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, PartialEq)]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\ast.rs","byte_start":4302,"byte_end":4308,"line_start":200,"line_end":200,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\ast.rs","byte_start":236,"byte_end":236,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\ast.rs:200:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m200\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, PartialEq)]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\ast.rs","byte_start":4601,"byte_end":4607,"line_start":211,"line_end":211,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\ast.rs","byte_start":236,"byte_end":236,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\ast.rs:211:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m211\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, PartialEq)]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\ast.rs","byte_start":4762,"byte_end":4768,"line_start":218,"line_end":218,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\ast.rs","byte_start":236,"byte_end":236,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\ast.rs:218:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m218\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, PartialEq)]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\ast.rs","byte_start":4956,"byte_end":4962,"line_start":226,"line_end":226,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\ast.rs","byte_start":236,"byte_end":236,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\ast.rs:226:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m226\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `matches` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\ast.rs","byte_start":5356,"byte_end":5363,"line_start":241,"line_end":241,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"        matches!(","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\ast.rs","byte_start":236,"byte_end":236,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::matches;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `matches` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\ast.rs:241:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m241\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         matches!(\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::matches;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":461,"byte_end":467,"line_start":21,"line_end":21,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:21:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m21\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone)]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `matches` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":1251,"byte_end":1258,"line_start":54,"line_end":54,"column_start":15,"column_end":22,"is_primary":true,"text":[{"text":"        while matches!(self.current(), Token::Newline) {","highlight_start":15,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::matches;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `matches` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:54:15\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m54\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         while matches!(self.current(), Token::Newline) {\n   \u001b[1m\u001b[96m|\u001b[0m               \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::matches;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `matches` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":2402,"byte_end":2409,"line_start":97,"line_end":97,"column_start":16,"column_end":23,"is_primary":true,"text":[{"text":"        while !matches!(self.current(), Token::Eof) {","highlight_start":16,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::matches;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `matches` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:97:16\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m97\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         while !matches!(self.current(), Token::Eof) {\n   \u001b[1m\u001b[96m|\u001b[0m                \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::matches;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `matches` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":5580,"byte_end":5587,"line_start":205,"line_end":205,"column_start":16,"column_end":23,"is_primary":true,"text":[{"text":"        while !matches!(self.current(), Token::Otherwise | Token::End | Token::Eof) {","highlight_start":16,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::matches;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `matches` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:205:16\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m205\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         while !matches!(self.current(), Token::Otherwise | Token::End | Token::Eof) {\n    \u001b[1m\u001b[96m|\u001b[0m                \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::matches;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `matches` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":5915,"byte_end":5922,"line_start":213,"line_end":213,"column_start":20,"column_end":27,"is_primary":true,"text":[{"text":"            while !matches!(self.current(), Token::End | Token::Eof) {","highlight_start":20,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::matches;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `matches` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:213:20\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m213\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             while !matches!(self.current(), Token::End | Token::Eof) {\n    \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::matches;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `matches` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":7030,"byte_end":7037,"line_start":255,"line_end":255,"column_start":16,"column_end":23,"is_primary":true,"text":[{"text":"        while !matches!(self.current(), Token::End | Token::Eof) {","highlight_start":16,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::matches;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `matches` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:255:16\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m255\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         while !matches!(self.current(), Token::End | Token::Eof) {\n    \u001b[1m\u001b[96m|\u001b[0m                \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::matches;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `matches` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":7636,"byte_end":7643,"line_start":279,"line_end":279,"column_start":16,"column_end":23,"is_primary":true,"text":[{"text":"        while !matches!(self.current(), Token::End | Token::Eof) {","highlight_start":16,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::matches;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `matches` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:279:16\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m279\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         while !matches!(self.current(), Token::End | Token::Eof) {\n    \u001b[1m\u001b[96m|\u001b[0m                \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::matches;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `matches` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":8503,"byte_end":8510,"line_start":311,"line_end":311,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"        if !matches!(self.current(), Token::RightParen) {","highlight_start":13,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::matches;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `matches` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:311:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m311\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if !matches!(self.current(), Token::RightParen) {\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::matches;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `matches` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":9310,"byte_end":9317,"line_start":337,"line_end":337,"column_start":16,"column_end":23,"is_primary":true,"text":[{"text":"        while !matches!(self.current(), Token::End | Token::Eof) {","highlight_start":16,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::matches;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `matches` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:337:16\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m337\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         while !matches!(self.current(), Token::End | Token::Eof) {\n    \u001b[1m\u001b[96m|\u001b[0m                \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::matches;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"binary operation `==` cannot be applied to type `Result<&elf_loader::Elf64Ehdr, elf_loader::ElfError>`","code":{"code":"E0369","explanation":"A binary operation was attempted on a type which doesn't support it.\n\nErroneous code example:\n\n```compile_fail,E0369\nlet x = 12f32; // error: binary operation `<<` cannot be applied to\n               //        type `f32`\n\nx << 2;\n```\n\nTo fix this error, please check that this type implements this binary\noperation. Example:\n\n```\nlet x = 12u32; // the `u32` type does implement it:\n               // https://doc.rust-lang.org/stable/std/ops/trait.Shl.html\n\nx << 2; // ok!\n```\n\nIt is also possible to overload most operators for your own type by\nimplementing traits from `std::ops`.\n\nString concatenation appends the string on the right to the string on the\nleft and may require reallocation. This requires ownership of the string\non the left. If something should be added to a string literal, move the\nliteral to the heap by allocating it with `to_owned()` like in\n`\"Your text\".to_owned()`.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":1454,"byte_end":1463,"line_start":46,"line_end":46,"column_start":22,"column_end":31,"is_primary":false,"text":[{"text":"                if !(*left_val == *right_val) {","highlight_start":22,"highlight_end":31}],"label":"Result<&elf_loader::Elf64Ehdr, elf_loader::ElfError>","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\loom_of_fate\\elf_loader.rs","byte_start":15351,"byte_end":15398,"line_start":493,"line_end":493,"column_start":9,"column_end":56,"is_primary":false,"text":[{"text":"        assert_eq!(result, Err(ElfError::InvalidMagic));","highlight_start":9,"highlight_end":56}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":1467,"byte_end":1477,"line_start":46,"line_end":46,"column_start":35,"column_end":45,"is_primary":false,"text":[{"text":"                if !(*left_val == *right_val) {","highlight_start":35,"highlight_end":45}],"label":"Result<&elf_loader::Elf64Ehdr, elf_loader::ElfError>","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\loom_of_fate\\elf_loader.rs","byte_start":15351,"byte_end":15398,"line_start":493,"line_end":493,"column_start":9,"column_end":56,"is_primary":false,"text":[{"text":"        assert_eq!(result, Err(ElfError::InvalidMagic));","highlight_start":9,"highlight_end":56}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":1464,"byte_end":1466,"line_start":46,"line_end":46,"column_start":32,"column_end":34,"is_primary":true,"text":[{"text":"                if !(*left_val == *right_val) {","highlight_start":32,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\loom_of_fate\\elf_loader.rs","byte_start":15351,"byte_end":15398,"line_start":493,"line_end":493,"column_start":9,"column_end":56,"is_primary":false,"text":[{"text":"        assert_eq!(result, Err(ElfError::InvalidMagic));","highlight_start":9,"highlight_end":56}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"an implementation of `PartialEq` might be missing for `elf_loader::Elf64Ehdr`","code":null,"level":"note","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\elf_loader.rs","byte_start":1443,"byte_end":1463,"line_start":58,"line_end":58,"column_start":1,"column_end":21,"is_primary":true,"text":[{"text":"pub struct Elf64Ehdr {","highlight_start":1,"highlight_end":21}],"label":"must implement `PartialEq`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider annotating `elf_loader::Elf64Ehdr` with `#[derive(PartialEq)]`","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\elf_loader.rs","byte_start":1443,"byte_end":1443,"line_start":58,"line_end":58,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub struct Elf64Ehdr {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(PartialEq)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0369]\u001b[0m\u001b[1m\u001b[97m: binary operation `==` cannot be applied to type `Result<&elf_loader::Elf64Ehdr, elf_loader::ElfError>`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\loom_of_fate\\elf_loader.rs:493:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m493\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(result, Err(ElfError::InvalidMagic));\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91mResult<&elf_loader::Elf64Ehdr, elf_loader::ElfError>\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91mResult<&elf_loader::Elf64Ehdr, elf_loader::ElfError>\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: an implementation of `PartialEq` might be missing for `elf_loader::Elf64Ehdr`\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\loom_of_fate\\elf_loader.rs:58:1\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m58\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub struct Elf64Ehdr {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mmust implement `PartialEq`\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\u001b[1m\u001b[96mhelp\u001b[0m: consider annotating `elf_loader::Elf64Ehdr` with `#[derive(PartialEq)]`\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m58\u001b[0m \u001b[92m+ #[derive(PartialEq)]\u001b[0m\n \u001b[1m\u001b[96m59\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub struct Elf64Ehdr {\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `matches` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":10095,"byte_end":10102,"line_start":366,"line_end":366,"column_start":15,"column_end":22,"is_primary":true,"text":[{"text":"        while matches!(self.current(), Token::When | Token::Otherwise) {","highlight_start":15,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::matches;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `matches` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:366:15\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m366\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         while matches!(self.current(), Token::When | Token::Otherwise) {\n    \u001b[1m\u001b[96m|\u001b[0m               \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::matches;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `matches` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":10402,"byte_end":10409,"line_start":373,"line_end":373,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"                while !matches!(","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::matches;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `matches` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:373:24\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m373\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 while !matches!(\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::matches;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `matches` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":10924,"byte_end":10931,"line_start":387,"line_end":387,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"                while !matches!(self.current(), Token::End | Token::Eof) {","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::matches;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `matches` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:387:24\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m387\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 while !matches!(self.current(), Token::End | Token::Eof) {\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::matches;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `matches` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":12549,"byte_end":12556,"line_start":441,"line_end":441,"column_start":16,"column_end":23,"is_primary":true,"text":[{"text":"        while !matches!(self.current(), Token::Harmonize | Token::End | Token::Eof) {","highlight_start":16,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::matches;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `matches` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:441:16\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m441\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         while !matches!(self.current(), Token::Harmonize | Token::End | Token::Eof) {\n    \u001b[1m\u001b[96m|\u001b[0m                \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::matches;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `matches` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":13359,"byte_end":13366,"line_start":465,"line_end":465,"column_start":20,"column_end":27,"is_primary":true,"text":[{"text":"            while !matches!(","highlight_start":20,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::matches;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `matches` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:465:20\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m465\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             while !matches!(\n    \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::matches;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `matches` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":14854,"byte_end":14861,"line_start":519,"line_end":519,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"        if matches!(self.current(), Token::Pipe) {","highlight_start":12,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::matches;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `matches` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:519:12\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m519\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if matches!(self.current(), Token::Pipe) {\n    \u001b[1m\u001b[96m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::matches;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `matches` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":19937,"byte_end":19944,"line_start":687,"line_end":687,"column_start":25,"column_end":32,"is_primary":true,"text":[{"text":"                    if !matches!(self.current(), Token::RightParen) {","highlight_start":25,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::matches;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `matches` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:687:25\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m687\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     if !matches!(self.current(), Token::RightParen) {\n    \u001b[1m\u001b[96m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::matches;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `matches` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":22416,"byte_end":22423,"line_start":763,"line_end":763,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"        if !matches!(self.current(), Token::RightBracket) {","highlight_start":13,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::matches;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `matches` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:763:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m763\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if !matches!(self.current(), Token::RightBracket) {\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::matches;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `matches` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":22936,"byte_end":22943,"line_start":781,"line_end":781,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"        if !matches!(self.current(), Token::RightBrace) {","highlight_start":13,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::matches;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `matches` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:781:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m781\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if !matches!(self.current(), Token::RightBrace) {\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::matches;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":555,"byte_end":561,"line_start":19,"line_end":19,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:19:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m19\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, PartialEq)]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"binary operation `==` cannot be applied to type `Result<&capability::SealedCapability, capability_table::CapabilityError>`","code":{"code":"E0369","explanation":"A binary operation was attempted on a type which doesn't support it.\n\nErroneous code example:\n\n```compile_fail,E0369\nlet x = 12f32; // error: binary operation `<<` cannot be applied to\n               //        type `f32`\n\nx << 2;\n```\n\nTo fix this error, please check that this type implements this binary\noperation. Example:\n\n```\nlet x = 12u32; // the `u32` type does implement it:\n               // https://doc.rust-lang.org/stable/std/ops/trait.Shl.html\n\nx << 2; // ok!\n```\n\nIt is also possible to overload most operators for your own type by\nimplementing traits from `std::ops`.\n\nString concatenation appends the string on the right to the string on the\nleft and may require reallocation. This requires ownership of the string\non the left. If something should be added to a string literal, move the\nliteral to the heap by allocating it with `to_owned()` like in\n`\"Your text\".to_owned()`.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":1454,"byte_end":1463,"line_start":46,"line_end":46,"column_start":22,"column_end":31,"is_primary":false,"text":[{"text":"                if !(*left_val == *right_val) {","highlight_start":22,"highlight_end":31}],"label":"Result<&capability::SealedCapability, capability_table::CapabilityError>","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\capability_table.rs","byte_start":8157,"byte_end":8223,"line_start":247,"line_end":247,"column_start":9,"column_end":75,"is_primary":false,"text":[{"text":"        assert_eq!(table.get(invalid_id), Err(CapabilityError::InvalidId));","highlight_start":9,"highlight_end":75}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":1467,"byte_end":1477,"line_start":46,"line_end":46,"column_start":35,"column_end":45,"is_primary":false,"text":[{"text":"                if !(*left_val == *right_val) {","highlight_start":35,"highlight_end":45}],"label":"Result<&capability::SealedCapability, capability_table::CapabilityError>","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\capability_table.rs","byte_start":8157,"byte_end":8223,"line_start":247,"line_end":247,"column_start":9,"column_end":75,"is_primary":false,"text":[{"text":"        assert_eq!(table.get(invalid_id), Err(CapabilityError::InvalidId));","highlight_start":9,"highlight_end":75}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":1464,"byte_end":1466,"line_start":46,"line_end":46,"column_start":32,"column_end":34,"is_primary":true,"text":[{"text":"                if !(*left_val == *right_val) {","highlight_start":32,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\capability_table.rs","byte_start":8157,"byte_end":8223,"line_start":247,"line_end":247,"column_start":9,"column_end":75,"is_primary":false,"text":[{"text":"        assert_eq!(table.get(invalid_id), Err(CapabilityError::InvalidId));","highlight_start":9,"highlight_end":75}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"an implementation of `PartialEq` might be missing for `capability::SealedCapability`","code":null,"level":"note","spans":[{"file_name":"heartwood\\src\\mana_pool\\capability.rs","byte_start":2490,"byte_end":2517,"line_start":83,"line_end":83,"column_start":1,"column_end":28,"is_primary":true,"text":[{"text":"pub struct SealedCapability {","highlight_start":1,"highlight_end":28}],"label":"must implement `PartialEq`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider annotating `capability::SealedCapability` with `#[derive(PartialEq)]`","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\mana_pool\\capability.rs","byte_start":2490,"byte_end":2490,"line_start":83,"line_end":83,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub struct SealedCapability {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(PartialEq)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0369]\u001b[0m\u001b[1m\u001b[97m: binary operation `==` cannot be applied to type `Result<&capability::SealedCapability, capability_table::CapabilityError>`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\capability_table.rs:247:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m247\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(table.get(invalid_id), Err(CapabilityError::InvalidId));\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91mResult<&capability::SealedCapability, capability_table::CapabilityError>\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91mResult<&capability::SealedCapability, capability_table::CapabilityError>\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: an implementation of `PartialEq` might be missing for `capability::SealedCapability`\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\capability.rs:83:1\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m83\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub struct SealedCapability {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mmust implement `PartialEq`\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\u001b[1m\u001b[96mhelp\u001b[0m: consider annotating `capability::SealedCapability` with `#[derive(PartialEq)]`\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\capability.rs:83:1\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m83\u001b[0m \u001b[92m+ #[derive(PartialEq)]\u001b[0m\n \u001b[1m\u001b[96m84\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub struct SealedCapability {\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"binary operation `==` cannot be applied to type `Result<&capability::SealedCapability, capability_table::CapabilityError>`","code":{"code":"E0369","explanation":"A binary operation was attempted on a type which doesn't support it.\n\nErroneous code example:\n\n```compile_fail,E0369\nlet x = 12f32; // error: binary operation `<<` cannot be applied to\n               //        type `f32`\n\nx << 2;\n```\n\nTo fix this error, please check that this type implements this binary\noperation. Example:\n\n```\nlet x = 12u32; // the `u32` type does implement it:\n               // https://doc.rust-lang.org/stable/std/ops/trait.Shl.html\n\nx << 2; // ok!\n```\n\nIt is also possible to overload most operators for your own type by\nimplementing traits from `std::ops`.\n\nString concatenation appends the string on the right to the string on the\nleft and may require reallocation. This requires ownership of the string\non the left. If something should be added to a string literal, move the\nliteral to the heap by allocating it with `to_owned()` like in\n`\"Your text\".to_owned()`.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":1454,"byte_end":1463,"line_start":46,"line_end":46,"column_start":22,"column_end":31,"is_primary":false,"text":[{"text":"                if !(*left_val == *right_val) {","highlight_start":22,"highlight_end":31}],"label":"Result<&capability::SealedCapability, capability_table::CapabilityError>","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\capability_table.rs","byte_start":10588,"byte_end":10650,"line_start":316,"line_end":316,"column_start":9,"column_end":71,"is_primary":false,"text":[{"text":"        assert_eq!(table.get(cap_id), Err(CapabilityError::InvalidId));","highlight_start":9,"highlight_end":71}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":1467,"byte_end":1477,"line_start":46,"line_end":46,"column_start":35,"column_end":45,"is_primary":false,"text":[{"text":"                if !(*left_val == *right_val) {","highlight_start":35,"highlight_end":45}],"label":"Result<&capability::SealedCapability, capability_table::CapabilityError>","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\capability_table.rs","byte_start":10588,"byte_end":10650,"line_start":316,"line_end":316,"column_start":9,"column_end":71,"is_primary":false,"text":[{"text":"        assert_eq!(table.get(cap_id), Err(CapabilityError::InvalidId));","highlight_start":9,"highlight_end":71}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":1464,"byte_end":1466,"line_start":46,"line_end":46,"column_start":32,"column_end":34,"is_primary":true,"text":[{"text":"                if !(*left_val == *right_val) {","highlight_start":32,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"heartwood\\src\\mana_pool\\capability_table.rs","byte_start":10588,"byte_end":10650,"line_start":316,"line_end":316,"column_start":9,"column_end":71,"is_primary":false,"text":[{"text":"        assert_eq!(table.get(cap_id), Err(CapabilityError::InvalidId));","highlight_start":9,"highlight_end":71}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"C:\\Users\\admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\macros\\mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"an implementation of `PartialEq` might be missing for `capability::SealedCapability`","code":null,"level":"note","spans":[{"file_name":"heartwood\\src\\mana_pool\\capability.rs","byte_start":2490,"byte_end":2517,"line_start":83,"line_end":83,"column_start":1,"column_end":28,"is_primary":true,"text":[{"text":"pub struct SealedCapability {","highlight_start":1,"highlight_end":28}],"label":"must implement `PartialEq`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider annotating `capability::SealedCapability` with `#[derive(PartialEq)]`","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\mana_pool\\capability.rs","byte_start":2490,"byte_end":2490,"line_start":83,"line_end":83,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub struct SealedCapability {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(PartialEq)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0369]\u001b[0m\u001b[1m\u001b[97m: binary operation `==` cannot be applied to type `Result<&capability::SealedCapability, capability_table::CapabilityError>`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\capability_table.rs:316:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m316\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(table.get(cap_id), Err(CapabilityError::InvalidId));\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91mResult<&capability::SealedCapability, capability_table::CapabilityError>\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91mResult<&capability::SealedCapability, capability_table::CapabilityError>\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: an implementation of `PartialEq` might be missing for `capability::SealedCapability`\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\capability.rs:83:1\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m83\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub struct SealedCapability {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mmust implement `PartialEq`\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\u001b[1m\u001b[96mhelp\u001b[0m: consider annotating `capability::SealedCapability` with `#[derive(PartialEq)]`\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\capability.rs:83:1\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m83\u001b[0m \u001b[92m+ #[derive(PartialEq)]\u001b[0m\n \u001b[1m\u001b[96m84\u001b[0m \u001b[1m\u001b[96m| \u001b[0mpub struct SealedCapability {\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":2417,"byte_end":2423,"line_start":84,"line_end":84,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:84:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m84\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, PartialEq)]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":3570,"byte_end":3576,"line_start":130,"line_end":130,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:130:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m130\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, PartialEq)]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":3858,"byte_end":3864,"line_start":141,"line_end":141,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:141:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m141\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, PartialEq)]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":21854,"byte_end":21858,"line_start":618,"line_end":618,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[test]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":21439,"byte_end":21439,"line_start":605,"line_end":605,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:618:7\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m618\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m605\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":22136,"byte_end":22145,"line_start":633,"line_end":633,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(result, Value::Number(15.0)); // 5+4+3+2+1 = 15","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":21439,"byte_end":21439,"line_start":605,"line_end":605,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:633:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m633\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(result, Value::Number(15.0)); // 5+4+3+2+1 = 15\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m605\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":22208,"byte_end":22212,"line_start":636,"line_end":636,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[test]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":21439,"byte_end":21439,"line_start":605,"line_end":605,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:636:7\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m636\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m605\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":22431,"byte_end":22440,"line_start":647,"line_end":647,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(result, Value::Number(100.0));","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":21439,"byte_end":21439,"line_start":605,"line_end":605,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:647:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m647\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(result, Value::Number(100.0));\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m605\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":22486,"byte_end":22490,"line_start":650,"line_end":650,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[test]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":21439,"byte_end":21439,"line_start":605,"line_end":605,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:650:7\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m650\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m605\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":22781,"byte_end":22790,"line_start":665,"line_end":665,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(result, Value::Number(120.0)); // 5! = 120","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":21439,"byte_end":21439,"line_start":605,"line_end":605,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:665:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m665\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(result, Value::Number(120.0)); // 5! = 120\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m605\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/the-weave_grove#0.1.0","manifest_path":"F:\\OS\\groves\\the-weave_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"the_weave_grove","src_path":"F:\\OS\\groves\\the-weave_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/the-weave_grove#0.1.0","manifest_path":"F:\\OS\\groves\\the-weave_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"the_weave_grove","src_path":"F:\\OS\\groves\\the-weave_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/the-weave_grove#0.1.0","manifest_path":"F:\\OS\\groves\\the-weave_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"the_weave_grove","src_path":"F:\\OS\\groves\\the-weave_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"`#[panic_handler]` function required, but not found","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: `#[panic_handler]` function required, but not found\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":22848,"byte_end":22852,"line_start":668,"line_end":668,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[test]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":21439,"byte_end":21439,"line_start":605,"line_end":605,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:668:7\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m668\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m605\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":23301,"byte_end":23310,"line_start":694,"line_end":694,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(result, Value::Number(55.0)); // 10th Fibonacci number","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":21439,"byte_end":21439,"line_start":605,"line_end":605,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:694:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m694\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(result, Value::Number(55.0)); // 10th Fibonacci number\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m605\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":23380,"byte_end":23384,"line_start":697,"line_end":697,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[test]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":21439,"byte_end":21439,"line_start":605,"line_end":605,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:697:7\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m697\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m605\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":23706,"byte_end":23715,"line_start":716,"line_end":716,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(result, Value::Number(9.0)); // 3x3 = 9","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":21439,"byte_end":21439,"line_start":605,"line_end":605,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:716:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m716\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(result, Value::Number(9.0)); // 3x3 = 9\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m605\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":23770,"byte_end":23774,"line_start":719,"line_end":719,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[test]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":21439,"byte_end":21439,"line_start":605,"line_end":605,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:719:7\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m719\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m605\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/the-weave_grove#0.1.0","manifest_path":"F:\\OS\\groves\\the-weave_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"the_weave_grove","src_path":"F:\\OS\\groves\\the-weave_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `amplitude`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":2130,"byte_end":2139,"line_start":85,"line_end":85,"column_start":36,"column_end":45,"is_primary":true,"text":[{"text":"    pub fn apply_ripple(&mut self, amplitude: f32, frequency: f32, time: f32) {","highlight_start":36,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":2130,"byte_end":2139,"line_start":85,"line_end":85,"column_start":36,"column_end":45,"is_primary":true,"text":[{"text":"    pub fn apply_ripple(&mut self, amplitude: f32, frequency: f32, time: f32) {","highlight_start":36,"highlight_end":45}],"label":null,"suggested_replacement":"_amplitude","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `amplitude`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\the-weave_grove\\src\\lib.rs:85:36\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m85\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn apply_ripple(&mut self, amplitude: f32, frequency: f32, time: f32) {\n   \u001b[1m\u001b[96m|\u001b[0m                                    \u001b[1m\u001b[93m^^^^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_amplitude`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/the-weave_grove#0.1.0","manifest_path":"F:\\OS\\groves\\the-weave_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"the_weave_grove","src_path":"F:\\OS\\groves\\the-weave_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `frequency`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":2146,"byte_end":2155,"line_start":85,"line_end":85,"column_start":52,"column_end":61,"is_primary":true,"text":[{"text":"    pub fn apply_ripple(&mut self, amplitude: f32, frequency: f32, time: f32) {","highlight_start":52,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":2146,"byte_end":2155,"line_start":85,"line_end":85,"column_start":52,"column_end":61,"is_primary":true,"text":[{"text":"    pub fn apply_ripple(&mut self, amplitude: f32, frequency: f32, time: f32) {","highlight_start":52,"highlight_end":61}],"label":null,"suggested_replacement":"_frequency","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `frequency`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\the-weave_grove\\src\\lib.rs:85:52\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m85\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn apply_ripple(&mut self, amplitude: f32, frequency: f32, time: f32) {\n   \u001b[1m\u001b[96m|\u001b[0m                                                    \u001b[1m\u001b[93m^^^^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_frequency`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/the-weave_grove#0.1.0","manifest_path":"F:\\OS\\groves\\the-weave_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"the_weave_grove","src_path":"F:\\OS\\groves\\the-weave_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `time`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":2162,"byte_end":2166,"line_start":85,"line_end":85,"column_start":68,"column_end":72,"is_primary":true,"text":[{"text":"    pub fn apply_ripple(&mut self, amplitude: f32, frequency: f32, time: f32) {","highlight_start":68,"highlight_end":72}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":2162,"byte_end":2166,"line_start":85,"line_end":85,"column_start":68,"column_end":72,"is_primary":true,"text":[{"text":"    pub fn apply_ripple(&mut self, amplitude: f32, frequency: f32, time: f32) {","highlight_start":68,"highlight_end":72}],"label":null,"suggested_replacement":"_time","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `time`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\the-weave_grove\\src\\lib.rs:85:68\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m85\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn apply_ripple(&mut self, amplitude: f32, frequency: f32, time: f32) {\n   \u001b[1m\u001b[96m|\u001b[0m                                                                    \u001b[1m\u001b[93m^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_time`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/the-weave_grove#0.1.0","manifest_path":"F:\\OS\\groves\\the-weave_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"the_weave_grove","src_path":"F:\\OS\\groves\\the-weave_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `parent`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":4028,"byte_end":4034,"line_start":166,"line_end":166,"column_start":32,"column_end":38,"is_primary":true,"text":[{"text":"    pub fn add_node(&mut self, parent: NodeId, node: SceneNode) -> NodeId {","highlight_start":32,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":4028,"byte_end":4034,"line_start":166,"line_end":166,"column_start":32,"column_end":38,"is_primary":true,"text":[{"text":"    pub fn add_node(&mut self, parent: NodeId, node: SceneNode) -> NodeId {","highlight_start":32,"highlight_end":38}],"label":null,"suggested_replacement":"_parent","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `parent`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\the-weave_grove\\src\\lib.rs:166:32\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m166\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn add_node(&mut self, parent: NodeId, node: SceneNode) -> NodeId {\n    \u001b[1m\u001b[96m|\u001b[0m                                \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_parent`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/the-weave_grove#0.1.0","manifest_path":"F:\\OS\\groves\\the-weave_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"the_weave_grove","src_path":"F:\\OS\\groves\\the-weave_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `node`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":4044,"byte_end":4048,"line_start":166,"line_end":166,"column_start":48,"column_end":52,"is_primary":true,"text":[{"text":"    pub fn add_node(&mut self, parent: NodeId, node: SceneNode) -> NodeId {","highlight_start":48,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":4044,"byte_end":4048,"line_start":166,"line_end":166,"column_start":48,"column_end":52,"is_primary":true,"text":[{"text":"    pub fn add_node(&mut self, parent: NodeId, node: SceneNode) -> NodeId {","highlight_start":48,"highlight_end":52}],"label":null,"suggested_replacement":"_node","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `node`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\the-weave_grove\\src\\lib.rs:166:48\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m166\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn add_node(&mut self, parent: NodeId, node: SceneNode) -> NodeId {\n    \u001b[1m\u001b[96m|\u001b[0m                                                \u001b[1m\u001b[93m^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_node`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/the-weave_grove#0.1.0","manifest_path":"F:\\OS\\groves\\the-weave_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"the_weave_grove","src_path":"F:\\OS\\groves\\the-weave_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `node`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":4600,"byte_end":4604,"line_start":182,"line_end":182,"column_start":36,"column_end":40,"is_primary":true,"text":[{"text":"    pub fn attach_glyph(&mut self, node: NodeId, glyph: Glyph) {","highlight_start":36,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":4600,"byte_end":4604,"line_start":182,"line_end":182,"column_start":36,"column_end":40,"is_primary":true,"text":[{"text":"    pub fn attach_glyph(&mut self, node: NodeId, glyph: Glyph) {","highlight_start":36,"highlight_end":40}],"label":null,"suggested_replacement":"_node","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `node`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\the-weave_grove\\src\\lib.rs:182:36\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m182\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn attach_glyph(&mut self, node: NodeId, glyph: Glyph) {\n    \u001b[1m\u001b[96m|\u001b[0m                                    \u001b[1m\u001b[93m^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_node`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/the-weave_grove#0.1.0","manifest_path":"F:\\OS\\groves\\the-weave_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"the_weave_grove","src_path":"F:\\OS\\groves\\the-weave_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `glyph`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":4614,"byte_end":4619,"line_start":182,"line_end":182,"column_start":50,"column_end":55,"is_primary":true,"text":[{"text":"    pub fn attach_glyph(&mut self, node: NodeId, glyph: Glyph) {","highlight_start":50,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"groves\\the-weave_grove\\src\\lib.rs","byte_start":4614,"byte_end":4619,"line_start":182,"line_end":182,"column_start":50,"column_end":55,"is_primary":true,"text":[{"text":"    pub fn attach_glyph(&mut self, node: NodeId, glyph: Glyph) {","highlight_start":50,"highlight_end":55}],"label":null,"suggested_replacement":"_glyph","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `glyph`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\the-weave_grove\\src\\lib.rs:182:50\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m182\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn attach_glyph(&mut self, node: NodeId, glyph: Glyph) {\n    \u001b[1m\u001b[96m|\u001b[0m                                                  \u001b[1m\u001b[93m^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_glyph`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":24076,"byte_end":24085,"line_start":734,"line_end":734,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(result, Value::Number(5050.0)); // Sum of 1..100","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":21439,"byte_end":21439,"line_start":605,"line_end":605,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:734:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m734\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(result, Value::Number(5050.0)); // Sum of 1..100\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m605\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":24149,"byte_end":24153,"line_start":737,"line_end":737,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[test]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":21439,"byte_end":21439,"line_start":605,"line_end":605,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:737:7\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m737\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m605\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/the-weave_grove#0.1.0","manifest_path":"F:\\OS\\groves\\the-weave_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"the_weave_grove","src_path":"F:\\OS\\groves\\the-weave_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0463`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mFor more information about this error, try `rustc --explain E0463`.\u001b[0m\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert_eq` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":24672,"byte_end":24681,"line_start":761,"line_end":761,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        assert_eq!(result, Value::Number(111.0)); // Collatz(27) takes 111 steps","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":21439,"byte_end":21439,"line_start":605,"line_end":605,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert_eq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert_eq` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:761:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m761\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert_eq!(result, Value::Number(111.0)); // Collatz(27) takes 111 steps\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m605\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert_eq;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":799,"byte_end":805,"line_start":28,"line_end":28,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy, PartialEq, Eq)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":678,"byte_end":678,"line_start":22,"line_end":22,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:28:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m28\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m22\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":1712,"byte_end":1718,"line_start":61,"line_end":61,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":678,"byte_end":678,"line_start":22,"line_end":22,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:61:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m61\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone)]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m22\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":13298,"byte_end":13302,"line_start":414,"line_end":414,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[test]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":13277,"byte_end":13277,"line_start":412,"line_end":412,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:414:7\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m414\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m412\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/lanthir_grove#0.1.0","manifest_path":"F:\\OS\\groves\\lanthir_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"lanthir_grove","src_path":"F:\\OS\\groves\\lanthir_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"groves\\lanthir_grove\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `vec` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":13353,"byte_end":13356,"line_start":416,"line_end":416,"column_start":19,"column_end":22,"is_primary":true,"text":[{"text":"        let ast = vec![AstNode::Number(42.0)];","highlight_start":19,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":13277,"byte_end":13277,"line_start":412,"line_end":412,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use alloc::vec;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `vec` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:416:19\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m416\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let ast = vec![AstNode::Number(42.0)];\n    \u001b[1m\u001b[96m|\u001b[0m                   \u001b[1m\u001b[91m^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m412\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse alloc::vec;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/lanthir_grove#0.1.0","manifest_path":"F:\\OS\\groves\\lanthir_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"lanthir_grove","src_path":"F:\\OS\\groves\\lanthir_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/lanthir_grove#0.1.0","manifest_path":"F:\\OS\\groves\\lanthir_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"lanthir_grove","src_path":"F:\\OS\\groves\\lanthir_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"`#[panic_handler]` function required, but not found","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: `#[panic_handler]` function required, but not found\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":13433,"byte_end":13439,"line_start":418,"line_end":418,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        assert!(result.is_ok());","highlight_start":9,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":13277,"byte_end":13277,"line_start":412,"line_end":412,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:418:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m418\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert!(result.is_ok());\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m412\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":13501,"byte_end":13507,"line_start":420,"line_end":420,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        assert!(asm.contains(\"movq $42\"));","highlight_start":9,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":13277,"byte_end":13277,"line_start":412,"line_end":412,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:420:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m420\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert!(asm.contains(\"movq $42\"));\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m412\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/lanthir_grove#0.1.0","manifest_path":"F:\\OS\\groves\\lanthir_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"lanthir_grove","src_path":"F:\\OS\\groves\\lanthir_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0463`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mFor more information about this error, try `rustc --explain E0463`.\u001b[0m\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `test` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":13549,"byte_end":13553,"line_start":423,"line_end":423,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"    #[test]","highlight_start":7,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":13277,"byte_end":13277,"line_start":412,"line_end":412,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::test;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `test` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:423:7\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m423\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     #[test]\n    \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[91m^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m412\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::prelude::rust_2024::test;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `vec` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":13681,"byte_end":13684,"line_start":429,"line_end":429,"column_start":19,"column_end":22,"is_primary":true,"text":[{"text":"        let ast = vec![BinaryOp {","highlight_start":19,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":13277,"byte_end":13277,"line_start":412,"line_end":412,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use alloc::vec;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `vec` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:429:19\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m429\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let ast = vec![BinaryOp {\n    \u001b[1m\u001b[96m|\u001b[0m                   \u001b[1m\u001b[91m^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m412\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse alloc::vec;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `assert` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":13865,"byte_end":13871,"line_start":436,"line_end":436,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        assert!(result.is_ok());","highlight_start":9,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":13277,"byte_end":13277,"line_start":412,"line_end":412,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::assert;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `assert` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:436:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m436\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         assert!(result.is_ok());\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m412\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::assert;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":1510,"byte_end":1516,"line_start":40,"line_end":40,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":1416,"byte_end":1416,"line_start":35,"line_end":35,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\elf.rs:40:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m40\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, Copy)]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m35\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":1641,"byte_end":1647,"line_start":49,"line_end":49,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":1416,"byte_end":1416,"line_start":35,"line_end":35,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\elf.rs:49:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m49\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, Copy)]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m35\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":1779,"byte_end":1785,"line_start":58,"line_end":58,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":1416,"byte_end":1416,"line_start":35,"line_end":35,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\elf.rs:58:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m58\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, Copy)]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m35\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":2033,"byte_end":2039,"line_start":69,"line_end":69,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":1416,"byte_end":1416,"line_start":35,"line_end":35,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\elf.rs:69:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m69\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, Copy)]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m35\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":2162,"byte_end":2168,"line_start":78,"line_end":78,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":1416,"byte_end":1416,"line_start":35,"line_end":35,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\elf.rs:78:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m78\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, Copy)]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m35\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":2687,"byte_end":2693,"line_start":94,"line_end":94,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":1416,"byte_end":1416,"line_start":35,"line_end":35,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\elf.rs:94:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m94\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, Copy)]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m35\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":2895,"byte_end":2901,"line_start":103,"line_end":103,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":1416,"byte_end":1416,"line_start":35,"line_end":35,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\elf.rs:103:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m103\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, Copy)]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m35\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":3026,"byte_end":3032,"line_start":112,"line_end":112,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":1416,"byte_end":1416,"line_start":35,"line_end":35,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\elf.rs:112:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m112\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, Copy)]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m35\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":3197,"byte_end":3203,"line_start":123,"line_end":123,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":1416,"byte_end":1416,"line_start":35,"line_end":35,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\elf.rs:123:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m123\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, Copy)]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m35\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":4192,"byte_end":4198,"line_start":143,"line_end":143,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":1416,"byte_end":1416,"line_start":35,"line_end":35,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\elf.rs:143:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m143\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, Copy)]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m35\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":4910,"byte_end":4916,"line_start":159,"line_end":159,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Copy)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":1416,"byte_end":1416,"line_start":35,"line_end":35,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\elf.rs:159:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m159\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, Copy)]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m35\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":812,"byte_end":818,"line_start":23,"line_end":23,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Clone)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:23:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m23\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Clone)]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":840,"byte_end":846,"line_start":23,"line_end":23,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:23:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m23\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, PartialEq)]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/world-tree_grove#0.1.0","manifest_path":"F:\\OS\\groves\\world-tree_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"world_tree_grove","src_path":"F:\\OS\\groves\\world-tree_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"can't find crate for `test`","code":{"code":"E0463","explanation":"A crate was declared but cannot be found.\n\nErroneous code example:\n\n```compile_fail,E0463\nextern crate foo; // error: can't find crate\n```\n\nYou need to link your code to the relevant crate in order to be able to use it\n(through Cargo or the `-L` option of rustc, for example).\n\n## Common causes\n\n- The crate is not present at all. If using Cargo, add it to `[dependencies]`\n  in Cargo.toml.\n- The crate is present, but under a different name. If using Cargo, look for\n  `package = ` under `[dependencies]` in Cargo.toml.\n\n## Common causes for missing `std` or `core`\n\n- You are cross-compiling for a target which doesn't have `std` prepackaged.\n  Consider one of the following:\n  + Adding a pre-compiled version of std with `rustup target add`\n  + Building std from source with `cargo build -Z build-std`\n  + Using `#![no_std]` at the crate root, so you won't need `std` in the first\n    place.\n- You are developing the compiler itself and haven't built libstd from source.\n  You can usually build it with `x.py build library/std`. More information\n  about x.py is available in the [rustc-dev-guide].\n\n[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler\n"},"level":"error","spans":[{"file_name":"groves\\world-tree_grove\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"can't find crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0463]\u001b[0m\u001b[1m\u001b[97m: can't find crate for `test`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":2731,"byte_end":2737,"line_start":88,"line_end":88,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, PartialEq)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:88:3\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m88\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone, PartialEq)]\n   \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/world-tree_grove#0.1.0","manifest_path":"F:\\OS\\groves\\world-tree_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"world_tree_grove","src_path":"F:\\OS\\groves\\world-tree_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":3601,"byte_end":3607,"line_start":120,"line_end":120,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:120:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m120\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone)]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/world-tree_grove#0.1.0","manifest_path":"F:\\OS\\groves\\world-tree_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"world_tree_grove","src_path":"F:\\OS\\groves\\world-tree_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"`#[panic_handler]` function required, but not found","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: `#[panic_handler]` function required, but not found\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find attribute `derive` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":3774,"byte_end":3780,"line_start":129,"line_end":129,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone)]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this attribute macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::prelude::rust_2024::derive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find attribute `derive` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:129:3\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m129\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug, Clone)]\n    \u001b[1m\u001b[96m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this attribute macro\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::prelude::rust_2024::derive;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `matches` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":16021,"byte_end":16028,"line_start":512,"line_end":512,"column_start":29,"column_end":36,"is_primary":true,"text":[{"text":"                        if !matches!(left_type, Type::Number | Type::Any | Type::Unknown) {","highlight_start":29,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::matches;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `matches` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:512:29\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m512\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         if !matches!(left_type, Type::Number | Type::Any | Type::Unknown) {\n    \u001b[1m\u001b[96m|\u001b[0m                             \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::matches;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `matches` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":16452,"byte_end":16459,"line_start":519,"line_end":519,"column_start":29,"column_end":36,"is_primary":true,"text":[{"text":"                        if !matches!(right_type, Type::Number | Type::Any | Type::Unknown) {","highlight_start":29,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::matches;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `matches` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:519:29\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m519\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         if !matches!(right_type, Type::Number | Type::Any | Type::Unknown) {\n    \u001b[1m\u001b[96m|\u001b[0m                             \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::matches;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `matches` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":17739,"byte_end":17746,"line_start":549,"line_end":549,"column_start":29,"column_end":36,"is_primary":true,"text":[{"text":"                        if !matches!(operand_type, Type::Number | Type::Any | Type::Unknown) {","highlight_start":29,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::matches;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `matches` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:549:29\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m549\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         if !matches!(operand_type, Type::Number | Type::Any | Type::Unknown) {\n    \u001b[1m\u001b[96m|\u001b[0m                             \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::matches;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `matches` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":22121,"byte_end":22128,"line_start":658,"line_end":658,"column_start":29,"column_end":36,"is_primary":true,"text":[{"text":"                        if !matches!(idx_type, Type::Number | Type::Any | Type::Unknown) {","highlight_start":29,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::matches;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `matches` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:658:29\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m658\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         if !matches!(idx_type, Type::Number | Type::Any | Type::Unknown) {\n    \u001b[1m\u001b[96m|\u001b[0m                             \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::matches;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `matches` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":23385,"byte_end":23392,"line_start":687,"line_end":687,"column_start":21,"column_end":28,"is_primary":true,"text":[{"text":"                if !matches!(start_type, Type::Number | Type::Any | Type::Unknown) {","highlight_start":21,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::matches;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `matches` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:687:21\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m687\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 if !matches!(start_type, Type::Number | Type::Any | Type::Unknown) {\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::matches;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find macro `matches` in this scope","code":null,"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":23753,"byte_end":23760,"line_start":695,"line_end":695,"column_start":21,"column_end":28,"is_primary":true,"text":[{"text":"                if !matches!(end_type, Type::Number | Type::Any | Type::Unknown) {","highlight_start":21,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this macro","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::matches;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: cannot find macro `matches` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:695:21\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m695\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 if !matches!(end_type, Type::Number | Type::Any | Type::Unknown) {\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this macro\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::matches;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/world-tree_grove#0.1.0","manifest_path":"F:\\OS\\groves\\world-tree_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"world_tree_grove","src_path":"F:\\OS\\groves\\world-tree_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `essence`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"groves\\world-tree_grove\\src\\lib.rs","byte_start":2470,"byte_end":2481,"line_start":102,"line_end":102,"column_start":29,"column_end":40,"is_primary":true,"text":[{"text":"                if let Some(ref essence) = query.essence {","highlight_start":29,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"groves\\world-tree_grove\\src\\lib.rs","byte_start":2470,"byte_end":2481,"line_start":102,"line_end":102,"column_start":29,"column_end":40,"is_primary":true,"text":[{"text":"                if let Some(ref essence) = query.essence {","highlight_start":29,"highlight_end":40}],"label":null,"suggested_replacement":"_essence","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `essence`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\world-tree_grove\\src\\lib.rs:102:29\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m102\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 if let Some(ref essence) = query.essence {\n    \u001b[1m\u001b[96m|\u001b[0m                             \u001b[1m\u001b[93m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_essence`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/world-tree_grove#0.1.0","manifest_path":"F:\\OS\\groves\\world-tree_grove\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"world_tree_grove","src_path":"F:\\OS\\groves\\world-tree_grove\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0463`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mFor more information about this error, try `rustc --explain E0463`.\u001b[0m\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\harbor.rs","byte_start":5160,"byte_end":5170,"line_start":153,"line_end":153,"column_start":13,"column_end":23,"is_primary":true,"text":[{"text":"        let mut vessel = Vessel::from_elf(beacon, parent, elf_data, fate, main_thread)?;","highlight_start":13,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\harbor.rs","byte_start":5160,"byte_end":5164,"line_start":153,"line_end":153,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"        let mut vessel = Vessel::from_elf(beacon, parent, elf_data, fate, main_thread)?;","highlight_start":13,"highlight_end":17}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: variable does not need to be mutable\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\loom_of_fate\\harbor.rs:153:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m153\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let mut vessel = Vessel::from_elf(beacon, parent, elf_data, fate, main_thread)?;\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[96m----\u001b[0m\u001b[1m\u001b[93m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[96mhelp: remove this `mut`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `header_ptr`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\elf_loader.rs","byte_start":7243,"byte_end":7253,"line_start":234,"line_end":234,"column_start":9,"column_end":19,"is_primary":true,"text":[{"text":"    let header_ptr = data.as_ptr() as *const Elf64Ehdr;","highlight_start":9,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\elf_loader.rs","byte_start":7243,"byte_end":7253,"line_start":234,"line_end":234,"column_start":9,"column_end":19,"is_primary":true,"text":[{"text":"    let header_ptr = data.as_ptr() as *const Elf64Ehdr;","highlight_start":9,"highlight_end":19}],"label":null,"suggested_replacement":"_header_ptr","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `header_ptr`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\loom_of_fate\\elf_loader.rs:234:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m234\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     let header_ptr = data.as_ptr() as *const Elf64Ehdr;\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_header_ptr`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\harbor.rs","byte_start":5160,"byte_end":5170,"line_start":153,"line_end":153,"column_start":13,"column_end":23,"is_primary":true,"text":[{"text":"        let mut vessel = Vessel::from_elf(beacon, parent, elf_data, fate, main_thread)?;","highlight_start":13,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\harbor.rs","byte_start":5160,"byte_end":5164,"line_start":153,"line_end":153,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"        let mut vessel = Vessel::from_elf(beacon, parent, elf_data, fate, main_thread)?;","highlight_start":13,"highlight_end":17}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: variable does not need to be mutable\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\loom_of_fate\\harbor.rs:153:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m153\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let mut vessel = Vessel::from_elf(beacon, parent, elf_data, fate, main_thread)?;\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[96m----\u001b[0m\u001b[1m\u001b[93m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[96mhelp: remove this `mut`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\mod.rs","byte_start":17209,"byte_end":17215,"line_start":494,"line_end":494,"column_start":33,"column_end":39,"is_primary":true,"text":[{"text":"                let source_cs = unsafe { (*from_ctx_ptr).cs };","highlight_start":33,"highlight_end":39}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\loom_of_fate\\mod.rs","byte_start":15995,"byte_end":16001,"line_start":469,"line_end":469,"column_start":9,"column_end":15,"is_primary":false,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_unsafe)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\loom_of_fate\\mod.rs:494:33\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m469\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m494\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 let source_cs = unsafe { (*from_ctx_ptr).cs };\n    \u001b[1m\u001b[96m|\u001b[0m                                 \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_unsafe)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\mod.rs","byte_start":18931,"byte_end":18937,"line_start":522,"line_end":522,"column_start":21,"column_end":27,"is_primary":true,"text":[{"text":"                    unsafe {","highlight_start":21,"highlight_end":27}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\loom_of_fate\\mod.rs","byte_start":15995,"byte_end":16001,"line_start":469,"line_end":469,"column_start":9,"column_end":15,"is_primary":false,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\loom_of_fate\\mod.rs:522:21\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m469\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m522\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `header_ptr`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\elf_loader.rs","byte_start":7243,"byte_end":7253,"line_start":234,"line_end":234,"column_start":9,"column_end":19,"is_primary":true,"text":[{"text":"    let header_ptr = data.as_ptr() as *const Elf64Ehdr;","highlight_start":9,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\elf_loader.rs","byte_start":7243,"byte_end":7253,"line_start":234,"line_end":234,"column_start":9,"column_end":19,"is_primary":true,"text":[{"text":"    let header_ptr = data.as_ptr() as *const Elf64Ehdr;","highlight_start":9,"highlight_end":19}],"label":null,"suggested_replacement":"_header_ptr","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `header_ptr`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\loom_of_fate\\elf_loader.rs:234:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m234\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     let header_ptr = data.as_ptr() as *const Elf64Ehdr;\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_header_ptr`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\mod.rs","byte_start":17209,"byte_end":17215,"line_start":494,"line_end":494,"column_start":33,"column_end":39,"is_primary":true,"text":[{"text":"                let source_cs = unsafe { (*from_ctx_ptr).cs };","highlight_start":33,"highlight_end":39}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\loom_of_fate\\mod.rs","byte_start":15995,"byte_end":16001,"line_start":469,"line_end":469,"column_start":9,"column_end":15,"is_primary":false,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_unsafe)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\loom_of_fate\\mod.rs:494:33\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m469\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m494\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 let source_cs = unsafe { (*from_ctx_ptr).cs };\n    \u001b[1m\u001b[96m|\u001b[0m                                 \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_unsafe)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\mod.rs","byte_start":18931,"byte_end":18937,"line_start":522,"line_end":522,"column_start":21,"column_end":27,"is_primary":true,"text":[{"text":"                    unsafe {","highlight_start":21,"highlight_end":27}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\loom_of_fate\\mod.rs","byte_start":15995,"byte_end":16001,"line_start":469,"line_end":469,"column_start":9,"column_end":15,"is_primary":false,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\loom_of_fate\\mod.rs:522:21\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m469\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m522\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `offset_in_page`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\mana_pool\\user_space.rs","byte_start":9367,"byte_end":9381,"line_start":288,"line_end":288,"column_start":17,"column_end":31,"is_primary":true,"text":[{"text":"            let offset_in_page = seg.vaddr - page_start;","highlight_start":17,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\mana_pool\\user_space.rs","byte_start":9367,"byte_end":9381,"line_start":288,"line_end":288,"column_start":17,"column_end":31,"is_primary":true,"text":[{"text":"            let offset_in_page = seg.vaddr - page_start;","highlight_start":17,"highlight_end":31}],"label":null,"suggested_replacement":"_offset_in_page","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `offset_in_page`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\user_space.rs:288:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m288\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             let offset_in_page = seg.vaddr - page_start;\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[93m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_offset_in_page`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `offset_in_page`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\mana_pool\\user_space.rs","byte_start":9367,"byte_end":9381,"line_start":288,"line_end":288,"column_start":17,"column_end":31,"is_primary":true,"text":[{"text":"            let offset_in_page = seg.vaddr - page_start;","highlight_start":17,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\mana_pool\\user_space.rs","byte_start":9367,"byte_end":9381,"line_start":288,"line_end":288,"column_start":17,"column_end":31,"is_primary":true,"text":[{"text":"            let offset_in_page = seg.vaddr - page_start;","highlight_start":17,"highlight_end":31}],"label":null,"suggested_replacement":"_offset_in_page","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `offset_in_page`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\user_space.rs:288:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m288\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             let offset_in_page = seg.vaddr - page_start;\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[93m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_offset_in_page`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\idt.rs","byte_start":4231,"byte_end":4237,"line_start":107,"line_end":107,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\idt.rs:107:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m107\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\idt.rs","byte_start":8607,"byte_end":8613,"line_start":247,"line_end":247,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\idt.rs:247:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m247\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\idt.rs","byte_start":12376,"byte_end":12382,"line_start":352,"line_end":352,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\idt.rs:352:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m352\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\harbor.rs","byte_start":5160,"byte_end":5170,"line_start":153,"line_end":153,"column_start":13,"column_end":23,"is_primary":true,"text":[{"text":"        let mut vessel = Vessel::from_elf(beacon, parent, elf_data, fate, main_thread)?;","highlight_start":13,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\harbor.rs","byte_start":5160,"byte_end":5164,"line_start":153,"line_end":153,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"        let mut vessel = Vessel::from_elf(beacon, parent, elf_data, fate, main_thread)?;","highlight_start":13,"highlight_end":17}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: variable does not need to be mutable\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\loom_of_fate\\harbor.rs:153:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m153\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let mut vessel = Vessel::from_elf(beacon, parent, elf_data, fate, main_thread)?;\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[96m----\u001b[0m\u001b[1m\u001b[93m^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[96mhelp: remove this `mut`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `header_ptr`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\elf_loader.rs","byte_start":7243,"byte_end":7253,"line_start":234,"line_end":234,"column_start":9,"column_end":19,"is_primary":true,"text":[{"text":"    let header_ptr = data.as_ptr() as *const Elf64Ehdr;","highlight_start":9,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\elf_loader.rs","byte_start":7243,"byte_end":7253,"line_start":234,"line_end":234,"column_start":9,"column_end":19,"is_primary":true,"text":[{"text":"    let header_ptr = data.as_ptr() as *const Elf64Ehdr;","highlight_start":9,"highlight_end":19}],"label":null,"suggested_replacement":"_header_ptr","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `header_ptr`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\loom_of_fate\\elf_loader.rs:234:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m234\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     let header_ptr = data.as_ptr() as *const Elf64Ehdr;\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_header_ptr`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":3874,"byte_end":3880,"line_start":82,"line_end":82,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":1439,"byte_end":1445,"line_start":40,"line_end":40,"column_start":5,"column_end":11,"is_primary":false,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\mod.rs:82:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m40\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m82\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":4145,"byte_end":4151,"line_start":88,"line_end":88,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":1439,"byte_end":1445,"line_start":40,"line_end":40,"column_start":5,"column_end":11,"is_primary":false,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\mod.rs:88:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m40\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m88\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":4520,"byte_end":4526,"line_start":96,"line_end":96,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":1439,"byte_end":1445,"line_start":40,"line_end":40,"column_start":5,"column_end":11,"is_primary":false,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\mod.rs:96:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m40\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m96\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":4778,"byte_end":4784,"line_start":102,"line_end":102,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":1439,"byte_end":1445,"line_start":40,"line_end":40,"column_start":5,"column_end":11,"is_primary":false,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\mod.rs:102:9\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m40\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m102\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":5165,"byte_end":5171,"line_start":110,"line_end":110,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":1439,"byte_end":1445,"line_start":40,"line_end":40,"column_start":5,"column_end":11,"is_primary":false,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\mod.rs:110:9\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m40\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m110\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":5433,"byte_end":5439,"line_start":116,"line_end":116,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":1439,"byte_end":1445,"line_start":40,"line_end":40,"column_start":5,"column_end":11,"is_primary":false,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\mod.rs:116:9\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m40\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m116\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":5811,"byte_end":5817,"line_start":124,"line_end":124,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":1439,"byte_end":1445,"line_start":40,"line_end":40,"column_start":5,"column_end":11,"is_primary":false,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\mod.rs:124:9\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m40\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m124\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":6115,"byte_end":6121,"line_start":130,"line_end":130,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":1439,"byte_end":1445,"line_start":40,"line_end":40,"column_start":5,"column_end":11,"is_primary":false,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\mod.rs:130:9\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m40\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m130\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\idt.rs","byte_start":4231,"byte_end":4237,"line_start":107,"line_end":107,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\idt.rs:107:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m107\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\idt.rs","byte_start":8607,"byte_end":8613,"line_start":247,"line_end":247,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\idt.rs:247:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m247\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\idt.rs","byte_start":12376,"byte_end":12382,"line_start":352,"line_end":352,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\idt.rs:352:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m352\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\mod.rs","byte_start":17209,"byte_end":17215,"line_start":494,"line_end":494,"column_start":33,"column_end":39,"is_primary":true,"text":[{"text":"                let source_cs = unsafe { (*from_ctx_ptr).cs };","highlight_start":33,"highlight_end":39}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\loom_of_fate\\mod.rs","byte_start":15995,"byte_end":16001,"line_start":469,"line_end":469,"column_start":9,"column_end":15,"is_primary":false,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_unsafe)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\loom_of_fate\\mod.rs:494:33\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m469\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m494\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 let source_cs = unsafe { (*from_ctx_ptr).cs };\n    \u001b[1m\u001b[96m|\u001b[0m                                 \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_unsafe)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\loom_of_fate\\mod.rs","byte_start":18931,"byte_end":18937,"line_start":522,"line_end":522,"column_start":21,"column_end":27,"is_primary":true,"text":[{"text":"                    unsafe {","highlight_start":21,"highlight_end":27}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\loom_of_fate\\mod.rs","byte_start":15995,"byte_end":16001,"line_start":469,"line_end":469,"column_start":9,"column_end":15,"is_primary":false,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\loom_of_fate\\mod.rs:522:21\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m469\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m522\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":3874,"byte_end":3880,"line_start":82,"line_end":82,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":1439,"byte_end":1445,"line_start":40,"line_end":40,"column_start":5,"column_end":11,"is_primary":false,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\mod.rs:82:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m40\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m82\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":4145,"byte_end":4151,"line_start":88,"line_end":88,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":1439,"byte_end":1445,"line_start":40,"line_end":40,"column_start":5,"column_end":11,"is_primary":false,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\mod.rs:88:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m40\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m88\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":4520,"byte_end":4526,"line_start":96,"line_end":96,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":1439,"byte_end":1445,"line_start":40,"line_end":40,"column_start":5,"column_end":11,"is_primary":false,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\mod.rs:96:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m40\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m96\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":4778,"byte_end":4784,"line_start":102,"line_end":102,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":1439,"byte_end":1445,"line_start":40,"line_end":40,"column_start":5,"column_end":11,"is_primary":false,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\mod.rs:102:9\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m40\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m102\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":5165,"byte_end":5171,"line_start":110,"line_end":110,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":1439,"byte_end":1445,"line_start":40,"line_end":40,"column_start":5,"column_end":11,"is_primary":false,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\mod.rs:110:9\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m40\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m110\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":5433,"byte_end":5439,"line_start":116,"line_end":116,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":1439,"byte_end":1445,"line_start":40,"line_end":40,"column_start":5,"column_end":11,"is_primary":false,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\mod.rs:116:9\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m40\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m116\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":5811,"byte_end":5817,"line_start":124,"line_end":124,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":1439,"byte_end":1445,"line_start":40,"line_end":40,"column_start":5,"column_end":11,"is_primary":false,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\mod.rs:124:9\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m40\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m124\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":6115,"byte_end":6121,"line_start":130,"line_end":130,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":1439,"byte_end":1445,"line_start":40,"line_end":40,"column_start":5,"column_end":11,"is_primary":false,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\mod.rs:130:9\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m40\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m130\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `offset_in_page`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\mana_pool\\user_space.rs","byte_start":9367,"byte_end":9381,"line_start":288,"line_end":288,"column_start":17,"column_end":31,"is_primary":true,"text":[{"text":"            let offset_in_page = seg.vaddr - page_start;","highlight_start":17,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\mana_pool\\user_space.rs","byte_start":9367,"byte_end":9381,"line_start":288,"line_end":288,"column_start":17,"column_end":31,"is_primary":true,"text":[{"text":"            let offset_in_page = seg.vaddr - page_start;","highlight_start":17,"highlight_end":31}],"label":null,"suggested_replacement":"_offset_in_page","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `offset_in_page`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\mana_pool\\user_space.rs:288:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m288\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             let offset_in_page = seg.vaddr - page_start;\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[93m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_offset_in_page`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\idt.rs","byte_start":4231,"byte_end":4237,"line_start":107,"line_end":107,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\idt.rs:107:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m107\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\idt.rs","byte_start":8607,"byte_end":8613,"line_start":247,"line_end":247,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\idt.rs:247:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m247\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\idt.rs","byte_start":12376,"byte_end":12382,"line_start":352,"line_end":352,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\idt.rs:352:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m352\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\vfs\\fat32\\bpb.rs","byte_start":10371,"byte_end":10377,"line_start":285,"line_end":285,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\fat32\\bpb.rs:285:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m285\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\vfs\\fat32\\bpb.rs","byte_start":10543,"byte_end":10549,"line_start":292,"line_end":292,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\fat32\\bpb.rs:292:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m292\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\vfs\\fat32\\mod.rs","byte_start":1683,"byte_end":1689,"line_start":61,"line_end":61,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\fat32\\mod.rs:61:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m61\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\vfs\\fat32\\mod.rs","byte_start":1856,"byte_end":1862,"line_start":68,"line_end":68,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\fat32\\mod.rs:68:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m68\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":3874,"byte_end":3880,"line_start":82,"line_end":82,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":1439,"byte_end":1445,"line_start":40,"line_end":40,"column_start":5,"column_end":11,"is_primary":false,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\mod.rs:82:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m40\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m82\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":4145,"byte_end":4151,"line_start":88,"line_end":88,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":1439,"byte_end":1445,"line_start":40,"line_end":40,"column_start":5,"column_end":11,"is_primary":false,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\mod.rs:88:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m40\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m88\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":4520,"byte_end":4526,"line_start":96,"line_end":96,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":1439,"byte_end":1445,"line_start":40,"line_end":40,"column_start":5,"column_end":11,"is_primary":false,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\mod.rs:96:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m40\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m96\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":4778,"byte_end":4784,"line_start":102,"line_end":102,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":1439,"byte_end":1445,"line_start":40,"line_end":40,"column_start":5,"column_end":11,"is_primary":false,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\mod.rs:102:9\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m40\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m102\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":5165,"byte_end":5171,"line_start":110,"line_end":110,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":1439,"byte_end":1445,"line_start":40,"line_end":40,"column_start":5,"column_end":11,"is_primary":false,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\mod.rs:110:9\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m40\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m110\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":5433,"byte_end":5439,"line_start":116,"line_end":116,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":1439,"byte_end":1445,"line_start":40,"line_end":40,"column_start":5,"column_end":11,"is_primary":false,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\mod.rs:116:9\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m40\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m116\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":5811,"byte_end":5817,"line_start":124,"line_end":124,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":1439,"byte_end":1445,"line_start":40,"line_end":40,"column_start":5,"column_end":11,"is_primary":false,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\mod.rs:124:9\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m40\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m124\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":6115,"byte_end":6121,"line_start":130,"line_end":130,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"heartwood\\src\\attunement\\mod.rs","byte_start":1439,"byte_end":1445,"line_start":40,"line_end":40,"column_start":5,"column_end":11,"is_primary":false,"text":[{"text":"    unsafe {","highlight_start":5,"highlight_end":11}],"label":"because it's nested under this `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\attunement\\mod.rs:130:9\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m40\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96mbecause it's nested under this `unsafe` block\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m130\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\vfs\\fat32\\bpb.rs","byte_start":10371,"byte_end":10377,"line_start":285,"line_end":285,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\fat32\\bpb.rs:285:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m285\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\vfs\\fat32\\bpb.rs","byte_start":10543,"byte_end":10549,"line_start":292,"line_end":292,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\fat32\\bpb.rs:292:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m292\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\vfs\\fat32\\mod.rs","byte_start":1683,"byte_end":1689,"line_start":61,"line_end":61,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\fat32\\mod.rs:61:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m61\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\vfs\\fat32\\mod.rs","byte_start":1856,"byte_end":1862,"line_start":68,"line_end":68,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\fat32\\mod.rs:68:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m68\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `entry_type`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\vfs\\ext4\\mod.rs","byte_start":3878,"byte_end":3888,"line_start":123,"line_end":123,"column_start":34,"column_end":44,"is_primary":true,"text":[{"text":"                Some((inode_num, entry_type)) => {","highlight_start":34,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\vfs\\ext4\\mod.rs","byte_start":3878,"byte_end":3888,"line_start":123,"line_end":123,"column_start":34,"column_end":44,"is_primary":true,"text":[{"text":"                Some((inode_num, entry_type)) => {","highlight_start":34,"highlight_end":44}],"label":null,"suggested_replacement":"_entry_type","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `entry_type`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\ext4\\mod.rs:123:34\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m123\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Some((inode_num, entry_type)) => {\n    \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[93m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_entry_type`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `error`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\drivers\\ata.rs","byte_start":4724,"byte_end":4729,"line_start":138,"line_end":138,"column_start":25,"column_end":30,"is_primary":true,"text":[{"text":"                    let error = inb(bus + ATA_REG_ERROR);","highlight_start":25,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\drivers\\ata.rs","byte_start":4724,"byte_end":4729,"line_start":138,"line_end":138,"column_start":25,"column_end":30,"is_primary":true,"text":[{"text":"                    let error = inb(bus + ATA_REG_ERROR);","highlight_start":25,"highlight_end":30}],"label":null,"suggested_replacement":"_error","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `error`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\drivers\\ata.rs:138:25\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m138\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     let error = inb(bus + ATA_REG_ERROR);\n    \u001b[1m\u001b[96m|\u001b[0m                         \u001b[1m\u001b[93m^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_error`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `entry_type`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\vfs\\ext4\\mod.rs","byte_start":3878,"byte_end":3888,"line_start":123,"line_end":123,"column_start":34,"column_end":44,"is_primary":true,"text":[{"text":"                Some((inode_num, entry_type)) => {","highlight_start":34,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\vfs\\ext4\\mod.rs","byte_start":3878,"byte_end":3888,"line_start":123,"line_end":123,"column_start":34,"column_end":44,"is_primary":true,"text":[{"text":"                Some((inode_num, entry_type)) => {","highlight_start":34,"highlight_end":44}],"label":null,"suggested_replacement":"_entry_type","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `entry_type`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\ext4\\mod.rs:123:34\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m123\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Some((inode_num, entry_type)) => {\n    \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[93m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_entry_type`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `error`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\drivers\\ata.rs","byte_start":4724,"byte_end":4729,"line_start":138,"line_end":138,"column_start":25,"column_end":30,"is_primary":true,"text":[{"text":"                    let error = inb(bus + ATA_REG_ERROR);","highlight_start":25,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\drivers\\ata.rs","byte_start":4724,"byte_end":4729,"line_start":138,"line_end":138,"column_start":25,"column_end":30,"is_primary":true,"text":[{"text":"                    let error = inb(bus + ATA_REG_ERROR);","highlight_start":25,"highlight_end":30}],"label":null,"suggested_replacement":"_error","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `error`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\drivers\\ata.rs:138:25\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m138\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     let error = inb(bus + ATA_REG_ERROR);\n    \u001b[1m\u001b[96m|\u001b[0m                         \u001b[1m\u001b[93m^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_error`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\vfs\\fat32\\bpb.rs","byte_start":10371,"byte_end":10377,"line_start":285,"line_end":285,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\fat32\\bpb.rs:285:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m285\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\vfs\\fat32\\bpb.rs","byte_start":10543,"byte_end":10549,"line_start":292,"line_end":292,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\fat32\\bpb.rs:292:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m292\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\vfs\\fat32\\mod.rs","byte_start":1683,"byte_end":1689,"line_start":61,"line_end":61,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\fat32\\mod.rs:61:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m61\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\vfs\\fat32\\mod.rs","byte_start":1856,"byte_end":1862,"line_start":68,"line_end":68,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        unsafe {","highlight_start":9,"highlight_end":15}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary `unsafe` block\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\fat32\\mod.rs:68:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m68\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         unsafe {\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93munnecessary `unsafe` block\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Option` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":854,"byte_end":860,"line_start":36,"line_end":36,"column_start":19,"column_end":25,"is_primary":true,"text":[{"text":"    current_char: Option<char>,","highlight_start":19,"highlight_end":25}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this enum","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Option` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:36:19\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m36\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     current_char: Option<char>,\n   \u001b[1m\u001b[96m|\u001b[0m                   \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this enum\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":1575,"byte_end":1579,"line_start":64,"line_end":64,"column_start":16,"column_end":20,"is_primary":true,"text":[{"text":"        if let Some('\\n') = self.current_char {","highlight_start":16,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:64:16\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m64\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if let Some('\\n') = self.current_char {\n   \u001b[1m\u001b[96m|\u001b[0m                \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Option` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":1901,"byte_end":1907,"line_start":76,"line_end":76,"column_start":23,"column_end":29,"is_primary":true,"text":[{"text":"    fn peek(&self) -> Option<char> {","highlight_start":23,"highlight_end":29}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this enum","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Option` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:76:23\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m76\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn peek(&self) -> Option<char> {\n   \u001b[1m\u001b[96m|\u001b[0m                       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this enum\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":2093,"byte_end":2097,"line_start":82,"line_end":82,"column_start":19,"column_end":23,"is_primary":true,"text":[{"text":"        while let Some(c) = self.current_char {","highlight_start":19,"highlight_end":23}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:82:19\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m82\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         while let Some(c) = self.current_char {\n   \u001b[1m\u001b[96m|\u001b[0m                   \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":2417,"byte_end":2421,"line_start":94,"line_end":94,"column_start":19,"column_end":23,"is_primary":true,"text":[{"text":"        while let Some(c) = self.current_char {","highlight_start":19,"highlight_end":23}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:94:19\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m94\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         while let Some(c) = self.current_char {\n   \u001b[1m\u001b[96m|\u001b[0m                   \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":2769,"byte_end":2773,"line_start":109,"line_end":109,"column_start":19,"column_end":23,"is_primary":true,"text":[{"text":"        while let Some(c) = self.current_char {","highlight_start":19,"highlight_end":23}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:109:19\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m109\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         while let Some(c) = self.current_char {\n    \u001b[1m\u001b[96m|\u001b[0m                   \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":3097,"byte_end":3101,"line_start":118,"line_end":118,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"                    Some('n') => result.push('\\n'),","highlight_start":21,"highlight_end":25}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:118:21\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m118\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     Some('n') => result.push('\\n'),\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":3149,"byte_end":3153,"line_start":119,"line_end":119,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"                    Some('t') => result.push('\\t'),","highlight_start":21,"highlight_end":25}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:119:21\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m119\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     Some('t') => result.push('\\t'),\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":3201,"byte_end":3205,"line_start":120,"line_end":120,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"                    Some('r') => result.push('\\r'),","highlight_start":21,"highlight_end":25}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:120:21\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m120\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     Some('r') => result.push('\\r'),\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":3253,"byte_end":3257,"line_start":121,"line_end":121,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"                    Some('\\\\') => result.push('\\\\'),","highlight_start":21,"highlight_end":25}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:121:21\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m121\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     Some('\\\\') => result.push('\\\\'),\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":3306,"byte_end":3310,"line_start":122,"line_end":122,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"                    Some('\"') => result.push('\"'),","highlight_start":21,"highlight_end":25}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:122:21\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m122\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     Some('\"') => result.push('\"'),\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `entry_type`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\vfs\\ext4\\mod.rs","byte_start":3878,"byte_end":3888,"line_start":123,"line_end":123,"column_start":34,"column_end":44,"is_primary":true,"text":[{"text":"                Some((inode_num, entry_type)) => {","highlight_start":34,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\vfs\\ext4\\mod.rs","byte_start":3878,"byte_end":3888,"line_start":123,"line_end":123,"column_start":34,"column_end":44,"is_primary":true,"text":[{"text":"                Some((inode_num, entry_type)) => {","highlight_start":34,"highlight_end":44}],"label":null,"suggested_replacement":"_entry_type","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `entry_type`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\vfs\\ext4\\mod.rs:123:34\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m123\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Some((inode_num, entry_type)) => {\n    \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[93m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_entry_type`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":3357,"byte_end":3361,"line_start":123,"line_end":123,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"                    Some(c) => {","highlight_start":21,"highlight_end":25}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:123:21\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m123\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     Some(c) => {\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":4120,"byte_end":4124,"line_start":149,"line_end":149,"column_start":19,"column_end":23,"is_primary":true,"text":[{"text":"        while let Some(c) = self.current_char {","highlight_start":19,"highlight_end":23}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:149:19\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m149\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         while let Some(c) = self.current_char {\n    \u001b[1m\u001b[96m|\u001b[0m                   \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":4387,"byte_end":4391,"line_start":159,"line_end":159,"column_start":33,"column_end":37,"is_primary":true,"text":[{"text":"        if self.current_char == Some('.') && self.peek().map_or(false, |c| c.is_ascii_digit()) {","highlight_start":33,"highlight_end":37}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:159:33\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m159\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if self.current_char == Some('.') && self.peek().map_or(false, |c| c.is_ascii_digit()) {\n    \u001b[1m\u001b[96m|\u001b[0m                                 \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":4581,"byte_end":4585,"line_start":164,"line_end":164,"column_start":23,"column_end":27,"is_primary":true,"text":[{"text":"            while let Some(c) = self.current_char {","highlight_start":23,"highlight_end":27}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:164:23\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m164\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             while let Some(c) = self.current_char {\n    \u001b[1m\u001b[96m|\u001b[0m                       \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":5142,"byte_end":5146,"line_start":184,"line_end":184,"column_start":19,"column_end":23,"is_primary":true,"text":[{"text":"        while let Some(c) = self.current_char {","highlight_start":19,"highlight_end":23}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:184:19\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m184\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         while let Some(c) = self.current_char {\n    \u001b[1m\u001b[96m|\u001b[0m                   \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":5507,"byte_end":5511,"line_start":195,"line_end":195,"column_start":49,"column_end":53,"is_primary":true,"text":[{"text":"        if text == \"is\" && self.current_char == Some(' ') {","highlight_start":49,"highlight_end":53}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:195:49\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m195\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if text == \"is\" && self.current_char == Some(' ') {\n    \u001b[1m\u001b[96m|\u001b[0m                                                 \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":5780,"byte_end":5784,"line_start":203,"line_end":203,"column_start":20,"column_end":24,"is_primary":true,"text":[{"text":"            if let Some(c) = self.current_char {","highlight_start":20,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:203:20\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m203\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             if let Some(c) = self.current_char {\n    \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":5927,"byte_end":5931,"line_start":206,"line_end":206,"column_start":31,"column_end":35,"is_primary":true,"text":[{"text":"                    while let Some(c2) = self.current_char {","highlight_start":31,"highlight_end":35}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:206:31\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m206\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     while let Some(c2) = self.current_char {\n    \u001b[1m\u001b[96m|\u001b[0m                               \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":8609,"byte_end":8613,"line_start":285,"line_end":285,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            Some('\\n') => {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:285:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m285\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some('\\n') => {\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":8715,"byte_end":8719,"line_start":290,"line_end":290,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            Some('#') => {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:290:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m290\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some('#') => {\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":8900,"byte_end":8904,"line_start":296,"line_end":296,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            Some('\"') => self.read_string(),","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:296:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m296\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some('\"') => self.read_string(),\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":8946,"byte_end":8950,"line_start":298,"line_end":298,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            Some(c) if c.is_ascii_digit() => self.read_number(),","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:298:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m298\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(c) if c.is_ascii_digit() => self.read_number(),\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":9012,"byte_end":9016,"line_start":300,"line_end":300,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            Some(c) if c.is_alphabetic() || c == '_' => self.read_identifier_or_keyword(),","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:300:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m300\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(c) if c.is_alphabetic() || c == '_' => self.read_identifier_or_keyword(),\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":9104,"byte_end":9108,"line_start":302,"line_end":302,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            Some('+') => {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:302:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m302\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some('+') => {\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":9206,"byte_end":9210,"line_start":307,"line_end":307,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            Some('-') => {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:307:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m307\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some('-') => {\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":9309,"byte_end":9313,"line_start":312,"line_end":312,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            Some('*') => {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:312:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m312\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some('*') => {\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":9411,"byte_end":9415,"line_start":317,"line_end":317,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            Some('/') => {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:317:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m317\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some('/') => {\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":9514,"byte_end":9518,"line_start":322,"line_end":322,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            Some('%') => {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:322:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m322\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some('%') => {\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":9619,"byte_end":9623,"line_start":327,"line_end":327,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            Some('>') => {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:327:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m327\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some('>') => {\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":9706,"byte_end":9710,"line_start":329,"line_end":329,"column_start":41,"column_end":45,"is_primary":true,"text":[{"text":"                if self.current_char == Some('=') {","highlight_start":41,"highlight_end":45}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:329:41\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m329\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 if self.current_char == Some('=') {\n    \u001b[1m\u001b[96m|\u001b[0m                                         \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":9896,"byte_end":9900,"line_start":337,"line_end":337,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            Some('<') => {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:337:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m337\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some('<') => {\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":9983,"byte_end":9987,"line_start":339,"line_end":339,"column_start":41,"column_end":45,"is_primary":true,"text":[{"text":"                if self.current_char == Some('=') {","highlight_start":41,"highlight_end":45}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:339:41\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m339\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 if self.current_char == Some('=') {\n    \u001b[1m\u001b[96m|\u001b[0m                                         \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":10167,"byte_end":10171,"line_start":347,"line_end":347,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            Some('|') => {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:347:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m347\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some('|') => {\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":10269,"byte_end":10273,"line_start":352,"line_end":352,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            Some('(') => {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:352:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m352\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some('(') => {\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":10376,"byte_end":10380,"line_start":357,"line_end":357,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            Some(')') => {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:357:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m357\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(')') => {\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":10484,"byte_end":10488,"line_start":362,"line_end":362,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            Some('[') => {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:362:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m362\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some('[') => {\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":10593,"byte_end":10597,"line_start":367,"line_end":367,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            Some(']') => {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:367:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m367\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(']') => {\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":10703,"byte_end":10707,"line_start":372,"line_end":372,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            Some('{') => {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:372:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m372\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some('{') => {\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":10810,"byte_end":10814,"line_start":377,"line_end":377,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            Some('}') => {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:377:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m377\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some('}') => {\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":10918,"byte_end":10922,"line_start":382,"line_end":382,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            Some(',') => {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:382:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m382\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(',') => {\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11021,"byte_end":11025,"line_start":387,"line_end":387,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            Some(':') => {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:387:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m387\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(':') => {\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11124,"byte_end":11128,"line_start":392,"line_end":392,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            Some('.') => {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:392:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m392\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some('.') => {\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":11225,"byte_end":11229,"line_start":397,"line_end":397,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            Some(c) => {","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\lexer.rs","byte_start":536,"byte_end":536,"line_start":25,"line_end":25,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::String;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\lexer.rs:397:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m397\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(c) => {\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Option` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\ast.rs","byte_start":942,"byte_end":948,"line_start":39,"line_end":39,"column_start":22,"column_end":28,"is_primary":true,"text":[{"text":"        else_branch: Option<Vec<AstNode>>,","highlight_start":22,"highlight_end":28}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this enum","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\ast.rs","byte_start":236,"byte_end":236,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Option` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\ast.rs:39:22\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m39\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         else_branch: Option<Vec<AstNode>>,\n   \u001b[1m\u001b[96m|\u001b[0m                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this enum\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::option::Option;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":586,"byte_end":592,"line_start":27,"line_end":27,"column_start":27,"column_end":33,"is_primary":true,"text":[{"text":"pub type ParseResult<T> = Result<T, ParseError>;","highlight_start":27,"highlight_end":33}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:27:27\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m27\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub type ParseResult<T> = Result<T, ParseError>;\n   \u001b[1m\u001b[96m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":1922,"byte_end":1924,"line_start":78,"line_end":78,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"            Ok(())","highlight_start":13,"highlight_end":15}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:78:13\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m78\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(())\n   \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":1958,"byte_end":1961,"line_start":80,"line_end":80,"column_start":13,"column_end":16,"is_primary":true,"text":[{"text":"            Err(ParseError {","highlight_start":13,"highlight_end":16}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:80:13\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m80\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Err(ParseError {\n   \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":2548,"byte_end":2550,"line_start":102,"line_end":102,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(statements)","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:102:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m102\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(statements)\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":3379,"byte_end":3381,"line_start":124,"line_end":124,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(AstNode::ExprStmt(Box::new(expr)))","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:124:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m124\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(AstNode::ExprStmt(Box::new(expr)))\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":3693,"byte_end":3696,"line_start":136,"line_end":136,"column_start":24,"column_end":27,"is_primary":true,"text":[{"text":"                return Err(ParseError {","highlight_start":24,"highlight_end":27}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:136:24\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m136\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 return Err(ParseError {\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":4000,"byte_end":4002,"line_start":148,"line_end":148,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(AstNode::BindStmt { name, value })","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:148:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m148\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(AstNode::BindStmt { name, value })\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":4298,"byte_end":4301,"line_start":158,"line_end":158,"column_start":24,"column_end":27,"is_primary":true,"text":[{"text":"                return Err(ParseError {","highlight_start":24,"highlight_end":27}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:158:24\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m158\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 return Err(ParseError {\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":4606,"byte_end":4608,"line_start":170,"line_end":170,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(AstNode::WeaveStmt { name, value })","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:170:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m170\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(AstNode::WeaveStmt { name, value })\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":4900,"byte_end":4903,"line_start":180,"line_end":180,"column_start":24,"column_end":27,"is_primary":true,"text":[{"text":"                return Err(ParseError {","highlight_start":24,"highlight_end":27}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:180:24\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m180\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 return Err(ParseError {\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":5206,"byte_end":5208,"line_start":192,"line_end":192,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(AstNode::SetStmt { name, value })","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:192:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m192\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(AstNode::SetStmt { name, value })\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":6089,"byte_end":6093,"line_start":217,"line_end":217,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            Some(else_stmts)","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:217:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m217\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(else_stmts)\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find value `None` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":6135,"byte_end":6139,"line_start":219,"line_end":219,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            None","highlight_start":13,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these unit variants","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::elf::ElfClass::None;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::elf::ElfData::None;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::elf::ElfMachine::None;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::elf::ElfType::None;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::None;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find value `None` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:219:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m219\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             None\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these unit variants\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use crate::elf::ElfClass::None;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use crate::elf::ElfData::None;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use crate::elf::ElfMachine::None;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use crate::elf::ElfType::None;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0mand 1 other candidate\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":6195,"byte_end":6197,"line_start":224,"line_end":224,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(AstNode::IfStmt {","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:224:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m224\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(AstNode::IfStmt {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":6608,"byte_end":6611,"line_start":239,"line_end":239,"column_start":24,"column_end":27,"is_primary":true,"text":[{"text":"                return Err(ParseError {","highlight_start":24,"highlight_end":27}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:239:24\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m239\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 return Err(ParseError {\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":7218,"byte_end":7220,"line_start":262,"line_end":262,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(AstNode::ForStmt {","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:262:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m262\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(AstNode::ForStmt {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":7824,"byte_end":7826,"line_start":286,"line_end":286,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(AstNode::WhileStmt {","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:286:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m286\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(AstNode::WhileStmt {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":8176,"byte_end":8179,"line_start":299,"line_end":299,"column_start":24,"column_end":27,"is_primary":true,"text":[{"text":"                return Err(ParseError {","highlight_start":24,"highlight_end":27}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:299:24\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m299\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 return Err(ParseError {\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":8816,"byte_end":8819,"line_start":319,"line_end":319,"column_start":32,"column_end":35,"is_primary":true,"text":[{"text":"                        return Err(ParseError {","highlight_start":32,"highlight_end":35}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:319:32\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m319\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         return Err(ParseError {\n    \u001b[1m\u001b[96m|\u001b[0m                                \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":9498,"byte_end":9500,"line_start":344,"line_end":344,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(AstNode::ChantDef { name, params, body })","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:344:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m344\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(AstNode::ChantDef { name, params, body })\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":9736,"byte_end":9738,"line_start":353,"line_end":353,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(AstNode::YieldStmt { value })","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:353:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m353\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(AstNode::YieldStmt { value })\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":11315,"byte_end":11317,"line_start":402,"line_end":402,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(AstNode::MatchStmt { value, arms })","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:402:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m402\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(AstNode::MatchStmt { value, arms })\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":11594,"byte_end":11596,"line_start":411,"line_end":411,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(Pattern::Literal(AstNode::Number(val)))","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:411:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m411\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(Pattern::Literal(AstNode::Number(val)))\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":11768,"byte_end":11770,"line_start":416,"line_end":416,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(Pattern::Literal(AstNode::Text(val)))","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:416:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m416\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(Pattern::Literal(AstNode::Text(val)))\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":11934,"byte_end":11936,"line_start":421,"line_end":421,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(Pattern::Literal(AstNode::Truth(val)))","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:421:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m421\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(Pattern::Literal(AstNode::Truth(val)))\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":12112,"byte_end":12114,"line_start":426,"line_end":426,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(Pattern::Ident(n))","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:426:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m426\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(Pattern::Ident(n))\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":12165,"byte_end":12168,"line_start":428,"line_end":428,"column_start":18,"column_end":21,"is_primary":true,"text":[{"text":"            _ => Err(ParseError {","highlight_start":18,"highlight_end":21}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:428:18\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m428\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             _ => Err(ParseError {\n    \u001b[1m\u001b[96m|\u001b[0m                  \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":12989,"byte_end":12992,"line_start":453,"line_end":453,"column_start":28,"column_end":31,"is_primary":true,"text":[{"text":"                    return Err(ParseError {","highlight_start":28,"highlight_end":31}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:453:28\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m453\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     return Err(ParseError {\n    \u001b[1m\u001b[96m|\u001b[0m                            \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":13764,"byte_end":13766,"line_start":481,"line_end":481,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(AstNode::AttemptStmt { body, handlers })","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:481:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m481\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(AstNode::AttemptStmt { body, handlers })\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":14250,"byte_end":14253,"line_start":496,"line_end":496,"column_start":24,"column_end":27,"is_primary":true,"text":[{"text":"                return Err(ParseError {","highlight_start":24,"highlight_end":27}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:496:24\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m496\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 return Err(ParseError {\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":14471,"byte_end":14473,"line_start":504,"line_end":504,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(AstNode::RequestStmt {","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:504:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m504\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(AstNode::RequestStmt {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":15155,"byte_end":15157,"line_start":530,"line_end":530,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(expr)","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:530:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m530\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(expr)\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":15602,"byte_end":15604,"line_start":546,"line_end":546,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(left)","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:546:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m546\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(left)\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":16052,"byte_end":16054,"line_start":562,"line_end":562,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(left)","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:562:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m562\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(left)\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":16909,"byte_end":16911,"line_start":589,"line_end":589,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(left)","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:589:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m589\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(left)\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":17548,"byte_end":17550,"line_start":612,"line_end":612,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(left)","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:612:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m612\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(left)\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":18233,"byte_end":18235,"line_start":636,"line_end":636,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(left)","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:636:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m636\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(left)\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":18443,"byte_end":18445,"line_start":644,"line_end":644,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(AstNode::UnaryOp {","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:644:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m644\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(AstNode::UnaryOp {\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":18680,"byte_end":18682,"line_start":651,"line_end":651,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(AstNode::UnaryOp {","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:651:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m651\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(AstNode::UnaryOp {\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":19345,"byte_end":19348,"line_start":671,"line_end":671,"column_start":36,"column_end":39,"is_primary":true,"text":[{"text":"                            return Err(ParseError {","highlight_start":36,"highlight_end":39}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:671:36\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m671\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   return Err(ParseError {\n    \u001b[1m\u001b[96m|\u001b[0m                              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":20907,"byte_end":20909,"line_start":715,"line_end":715,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(expr)","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:715:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m715\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(expr)\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":21135,"byte_end":21137,"line_start":723,"line_end":723,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(AstNode::Number(n))","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:723:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m723\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(AstNode::Number(n))\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":21252,"byte_end":21254,"line_start":727,"line_end":727,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(AstNode::Text(s))","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:727:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m727\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(AstNode::Text(s))\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":21368,"byte_end":21370,"line_start":731,"line_end":731,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(AstNode::Truth(b))","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:731:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m731\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(AstNode::Truth(b))\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":21484,"byte_end":21486,"line_start":735,"line_end":735,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(AstNode::Nothing)","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:735:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m735\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(AstNode::Nothing)\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":21603,"byte_end":21605,"line_start":739,"line_end":739,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(AstNode::Ident(name))","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:739:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m739\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(AstNode::Ident(name))\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":21826,"byte_end":21828,"line_start":745,"line_end":745,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(expr)","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:745:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m745\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(expr)\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":22063,"byte_end":22066,"line_start":751,"line_end":751,"column_start":18,"column_end":21,"is_primary":true,"text":[{"text":"            _ => Err(ParseError {","highlight_start":18,"highlight_end":21}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:751:18\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m751\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             _ => Err(ParseError {\n    \u001b[1m\u001b[96m|\u001b[0m                  \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":22714,"byte_end":22716,"line_start":773,"line_end":773,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(AstNode::List(elements))","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:773:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m773\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(AstNode::List(elements))\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":23158,"byte_end":23161,"line_start":786,"line_end":786,"column_start":32,"column_end":35,"is_primary":true,"text":[{"text":"                        return Err(ParseError {","highlight_start":32,"highlight_end":35}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:786:32\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m786\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         return Err(ParseError {\n    \u001b[1m\u001b[96m|\u001b[0m                                \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":23726,"byte_end":23728,"line_start":806,"line_end":806,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(AstNode::Map(pairs))","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:806:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m806\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(AstNode::Map(pairs))\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":24704,"byte_end":24707,"line_start":834,"line_end":834,"column_start":28,"column_end":31,"is_primary":true,"text":[{"text":"                    return Err(ParseError {","highlight_start":28,"highlight_end":31}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:834:28\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m834\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     return Err(ParseError {\n    \u001b[1m\u001b[96m|\u001b[0m                            \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":25228,"byte_end":25230,"line_start":855,"line_end":855,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(AstNode::SeekExpr { conditions })","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:855:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m855\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(AstNode::SeekExpr { conditions })\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":25636,"byte_end":25638,"line_start":869,"line_end":869,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(AstNode::Range { start, end })","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\parser.rs","byte_start":205,"byte_end":205,"line_start":8,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\parser.rs:869:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m869\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(AstNode::Range { start, end })\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":4603,"byte_end":4607,"line_start":169,"line_end":169,"column_start":16,"column_end":20,"is_primary":true,"text":[{"text":"        if let Some(scope) = self.scopes.last_mut() {","highlight_start":16,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:169:16\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m169\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if let Some(scope) = self.scopes.last_mut() {\n    \u001b[1m\u001b[96m|\u001b[0m                \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":4841,"byte_end":4845,"line_start":176,"line_end":176,"column_start":16,"column_end":20,"is_primary":true,"text":[{"text":"        if let Some(scope) = self.scopes.last_mut() {","highlight_start":16,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:176:16\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m176\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if let Some(scope) = self.scopes.last_mut() {\n    \u001b[1m\u001b[96m|\u001b[0m                \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":5076,"byte_end":5082,"line_start":182,"line_end":182,"column_start":38,"column_end":44,"is_primary":true,"text":[{"text":"    pub fn get(&self, name: &str) -> Result<Value, RuntimeError> {","highlight_start":38,"highlight_end":44}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:182:38\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m182\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn get(&self, name: &str) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":5173,"byte_end":5177,"line_start":184,"line_end":184,"column_start":20,"column_end":24,"is_primary":true,"text":[{"text":"            if let Some(binding) = scope.get(name) {","highlight_start":20,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:184:20\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m184\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             if let Some(binding) = scope.get(name) {\n    \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":5230,"byte_end":5232,"line_start":185,"line_end":185,"column_start":24,"column_end":26,"is_primary":true,"text":[{"text":"                return Ok(binding.value.clone());","highlight_start":24,"highlight_end":26}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:185:24\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m185\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 return Ok(binding.value.clone());\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":5289,"byte_end":5292,"line_start":188,"line_end":188,"column_start":9,"column_end":12,"is_primary":true,"text":[{"text":"        Err(RuntimeError::UndefinedVariable(name.to_string()))","highlight_start":9,"highlight_end":12}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:188:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m188\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Err(RuntimeError::UndefinedVariable(name.to_string()))\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":5455,"byte_end":5461,"line_start":192,"line_end":192,"column_start":56,"column_end":62,"is_primary":true,"text":[{"text":"    pub fn set(&mut self, name: &str, value: Value) -> Result<(), RuntimeError> {","highlight_start":56,"highlight_end":62}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:192:56\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m192\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn set(&mut self, name: &str, value: Value) -> Result<(), RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                                        \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":5553,"byte_end":5557,"line_start":194,"line_end":194,"column_start":20,"column_end":24,"is_primary":true,"text":[{"text":"            if let Some(binding) = scope.get_mut(name) {","highlight_start":20,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:194:20\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m194\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             if let Some(binding) = scope.get_mut(name) {\n    \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":5656,"byte_end":5659,"line_start":196,"line_end":196,"column_start":28,"column_end":31,"is_primary":true,"text":[{"text":"                    return Err(RuntimeError::ImmutableBinding(name.to_string()));","highlight_start":28,"highlight_end":31}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:196:28\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m196\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     return Err(RuntimeError::ImmutableBinding(name.to_string()));\n    \u001b[1m\u001b[96m|\u001b[0m                            \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":5791,"byte_end":5793,"line_start":199,"line_end":199,"column_start":24,"column_end":26,"is_primary":true,"text":[{"text":"                return Ok(());","highlight_start":24,"highlight_end":26}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:199:24\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m199\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 return Ok(());\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":5831,"byte_end":5834,"line_start":202,"line_end":202,"column_start":9,"column_end":12,"is_primary":true,"text":[{"text":"        Err(RuntimeError::UndefinedVariable(name.to_string()))","highlight_start":9,"highlight_end":12}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:202:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m202\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Err(RuntimeError::UndefinedVariable(name.to_string()))\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":6584,"byte_end":6590,"line_start":230,"line_end":230,"column_start":50,"column_end":56,"is_primary":true,"text":[{"text":"    pub fn eval(&mut self, nodes: &[AstNode]) -> Result<Value, RuntimeError> {","highlight_start":50,"highlight_end":56}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:230:50\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m230\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn eval(&mut self, nodes: &[AstNode]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                                  \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":6745,"byte_end":6747,"line_start":235,"line_end":235,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(result)","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:235:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m235\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(result)\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":6849,"byte_end":6855,"line_start":239,"line_end":239,"column_start":52,"column_end":58,"is_primary":true,"text":[{"text":"    pub fn eval_node(&mut self, node: &AstNode) -> Result<Value, RuntimeError> {","highlight_start":52,"highlight_end":58}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:239:52\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m239\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn eval_node(&mut self, node: &AstNode) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":6966,"byte_end":6968,"line_start":242,"line_end":242,"column_start":35,"column_end":37,"is_primary":true,"text":[{"text":"            AstNode::Number(n) => Ok(Value::Number(*n)),","highlight_start":35,"highlight_end":37}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:242:35\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m242\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             AstNode::Number(n) => Ok(Value::Number(*n)),\n    \u001b[1m\u001b[96m|\u001b[0m                                   \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":7021,"byte_end":7023,"line_start":243,"line_end":243,"column_start":33,"column_end":35,"is_primary":true,"text":[{"text":"            AstNode::Text(s) => Ok(Value::Text(s.clone())),","highlight_start":33,"highlight_end":35}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:243:33\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m243\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             AstNode::Text(s) => Ok(Value::Text(s.clone())),\n    \u001b[1m\u001b[96m|\u001b[0m                                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":7082,"byte_end":7084,"line_start":244,"line_end":244,"column_start":34,"column_end":36,"is_primary":true,"text":[{"text":"            AstNode::Truth(b) => Ok(Value::Truth(*b)),","highlight_start":34,"highlight_end":36}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:244:34\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m244\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             AstNode::Truth(b) => Ok(Value::Truth(*b)),\n    \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":7136,"byte_end":7138,"line_start":245,"line_end":245,"column_start":33,"column_end":35,"is_primary":true,"text":[{"text":"            AstNode::Nothing => Ok(Value::Nothing),","highlight_start":33,"highlight_end":35}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:245:33\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m245\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             AstNode::Nothing => Ok(Value::Nothing),\n    \u001b[1m\u001b[96m|\u001b[0m                                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":7499,"byte_end":7501,"line_start":256,"line_end":256,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(Value::List(values))","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:256:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m256\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(Value::List(values))\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":7846,"byte_end":7848,"line_start":266,"line_end":266,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(Value::Map(map))","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:266:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m266\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(Value::Map(map))\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":8129,"byte_end":8131,"line_start":275,"line_end":275,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(val)","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:275:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m275\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(val)\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":8376,"byte_end":8378,"line_start":282,"line_end":282,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(val)","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:282:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m282\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(val)\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":8606,"byte_end":8608,"line_start":289,"line_end":289,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(val)","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:289:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m289\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(val)\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":8935,"byte_end":8939,"line_start":297,"line_end":297,"column_start":31,"column_end":35,"is_primary":true,"text":[{"text":"                } else if let Some(else_body) = else_branch {","highlight_start":31,"highlight_end":35}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:297:31\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m297\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 } else if let Some(else_body) = else_branch {\n    \u001b[1m\u001b[96m|\u001b[0m                               \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":9053,"byte_end":9055,"line_start":300,"line_end":300,"column_start":21,"column_end":23,"is_primary":true,"text":[{"text":"                    Ok(Value::Nothing)","highlight_start":21,"highlight_end":23}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:300:21\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m300\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     Ok(Value::Nothing)\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":9696,"byte_end":9699,"line_start":315,"line_end":315,"column_start":41,"column_end":44,"is_primary":true,"text":[{"text":"                            _ => return Err(RuntimeError::TypeError {","highlight_start":41,"highlight_end":44}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:315:41\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m315\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   _ => return Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m                                   \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":10075,"byte_end":10078,"line_start":322,"line_end":322,"column_start":41,"column_end":44,"is_primary":true,"text":[{"text":"                            _ => return Err(RuntimeError::TypeError {","highlight_start":41,"highlight_end":44}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:322:41\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m322\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   _ => return Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m                                   \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":10523,"byte_end":10526,"line_start":332,"line_end":332,"column_start":33,"column_end":36,"is_primary":true,"text":[{"text":"                    _ => return Err(RuntimeError::NotIterable(iter_val.type_name().to_string())),","highlight_start":33,"highlight_end":36}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:332:33\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m332\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     _ => return Err(RuntimeError::NotIterable(iter_val.type_name().to_string())),\n    \u001b[1m\u001b[96m|\u001b[0m                                 \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":10945,"byte_end":10947,"line_start":342,"line_end":342,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(result)","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:342:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m342\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(result)\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":11388,"byte_end":11390,"line_start":355,"line_end":355,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(result)","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:355:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m355\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(result)\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":11805,"byte_end":11807,"line_start":366,"line_end":366,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(chant)","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:366:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m366\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(chant)\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":12768,"byte_end":12774,"line_start":392,"line_end":392,"column_start":31,"column_end":37,"is_primary":true,"text":[{"text":"                let arg_vals: Result<Vec<Value>, RuntimeError> =","highlight_start":31,"highlight_end":37}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:392:31\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m392\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 let arg_vals: Result<Vec<Value>, RuntimeError> =\n    \u001b[1m\u001b[96m|\u001b[0m                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":13108,"byte_end":13111,"line_start":399,"line_end":399,"column_start":36,"column_end":39,"is_primary":true,"text":[{"text":"                            return Err(RuntimeError::ArityMismatch {","highlight_start":36,"highlight_end":39}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:399:36\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m399\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   return Err(RuntimeError::ArityMismatch {\n    \u001b[1m\u001b[96m|\u001b[0m                              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":14282,"byte_end":14286,"line_start":427,"line_end":427,"column_start":32,"column_end":36,"is_primary":true,"text":[{"text":"                        if let Some(expected) = native_fn.arity {","highlight_start":32,"highlight_end":36}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:427:32\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m427\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         if let Some(expected) = native_fn.arity {\n    \u001b[1m\u001b[96m|\u001b[0m                                \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":14416,"byte_end":14419,"line_start":429,"line_end":429,"column_start":40,"column_end":43,"is_primary":true,"text":[{"text":"                                return Err(RuntimeError::ArityMismatch {","highlight_start":40,"highlight_end":43}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:429:40\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m429\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   return Err(RuntimeError::ArityMismatch {\n    \u001b[1m\u001b[96m|\u001b[0m                              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":14793,"byte_end":14796,"line_start":439,"line_end":439,"column_start":26,"column_end":29,"is_primary":true,"text":[{"text":"                    _ => Err(RuntimeError::NotCallable(func.type_name().to_string())),","highlight_start":26,"highlight_end":29}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:439:26\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m439\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     _ => Err(RuntimeError::NotCallable(func.type_name().to_string())),\n    \u001b[1m\u001b[96m|\u001b[0m                          \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":15445,"byte_end":15448,"line_start":455,"line_end":455,"column_start":26,"column_end":29,"is_primary":true,"text":[{"text":"                    _ => Err(RuntimeError::TypeError {","highlight_start":26,"highlight_end":29}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:455:26\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m455\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     _ => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m                          \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":16063,"byte_end":16065,"line_start":471,"line_end":471,"column_start":29,"column_end":31,"is_primary":true,"text":[{"text":"                            Ok(list[index].clone())","highlight_start":29,"highlight_end":31}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:471:29\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m471\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   Ok(list[index].clone())\n    \u001b[1m\u001b[96m|\u001b[0m                       \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":16148,"byte_end":16151,"line_start":473,"line_end":473,"column_start":29,"column_end":32,"is_primary":true,"text":[{"text":"                            Err(RuntimeError::IndexOutOfBounds {","highlight_start":29,"highlight_end":32}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:473:29\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m473\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   Err(RuntimeError::IndexOutOfBounds {\n    \u001b[1m\u001b[96m|\u001b[0m                       \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":16759,"byte_end":16762,"line_start":487,"line_end":487,"column_start":35,"column_end":38,"is_primary":true,"text":[{"text":"                    (obj, idx) => Err(RuntimeError::TypeError {","highlight_start":35,"highlight_end":38}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:487:35\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m487\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     (obj, idx) => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m                                   \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":17206,"byte_end":17208,"line_start":498,"line_end":498,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(Value::Range {","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:498:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m498\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(Value::Range {\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":17814,"byte_end":17817,"line_start":517,"line_end":517,"column_start":17,"column_end":20,"is_primary":true,"text":[{"text":"                Err(RuntimeError::Custom(\"Pattern matching not yet implemented\".to_string()))","highlight_start":17,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:517:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m517\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(RuntimeError::Custom(\"Pattern matching not yet implemented\".to_string()))\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":17967,"byte_end":17970,"line_start":520,"line_end":520,"column_start":17,"column_end":20,"is_primary":true,"text":[{"text":"                Err(RuntimeError::Custom(\"Error handling not yet implemented\".to_string()))","highlight_start":17,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:520:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m520\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(RuntimeError::Custom(\"Error handling not yet implemented\".to_string()))\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":18118,"byte_end":18121,"line_start":523,"line_end":523,"column_start":17,"column_end":20,"is_primary":true,"text":[{"text":"                Err(RuntimeError::Custom(\"Capability requests not yet implemented\".to_string()))","highlight_start":17,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:523:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m523\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(RuntimeError::Custom(\"Capability requests not yet implemented\".to_string()))\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":18271,"byte_end":18274,"line_start":526,"line_end":526,"column_start":17,"column_end":20,"is_primary":true,"text":[{"text":"                Err(RuntimeError::Custom(\"Pipelines not yet implemented\".to_string()))","highlight_start":17,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:526:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m526\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(RuntimeError::Custom(\"Pipelines not yet implemented\".to_string()))\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":18414,"byte_end":18417,"line_start":529,"line_end":529,"column_start":17,"column_end":20,"is_primary":true,"text":[{"text":"                Err(RuntimeError::Custom(\"World-Tree queries not yet implemented\".to_string()))","highlight_start":17,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:529:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m529\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(RuntimeError::Custom(\"World-Tree queries not yet implemented\".to_string()))\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":18679,"byte_end":18685,"line_start":540,"line_end":540,"column_start":10,"column_end":16,"is_primary":true,"text":[{"text":"    ) -> Result<Value, RuntimeError> {","highlight_start":10,"highlight_end":16}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:540:10\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m540\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     ) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m          \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":18842,"byte_end":18844,"line_start":543,"line_end":543,"column_start":74,"column_end":76,"is_primary":true,"text":[{"text":"            (Value::Number(l), BinaryOperator::Add, Value::Number(r)) => Ok(Value::Number(l + r)),","highlight_start":74,"highlight_end":76}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:543:74\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m543\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             (Value::Number(l), BinaryOperator::Add, Value::Number(r)) => Ok(Value::Number(l + r)),\n    \u001b[1m\u001b[96m|\u001b[0m                                                                          \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":18941,"byte_end":18943,"line_start":544,"line_end":544,"column_start":74,"column_end":76,"is_primary":true,"text":[{"text":"            (Value::Number(l), BinaryOperator::Sub, Value::Number(r)) => Ok(Value::Number(l - r)),","highlight_start":74,"highlight_end":76}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:544:74\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m544\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             (Value::Number(l), BinaryOperator::Sub, Value::Number(r)) => Ok(Value::Number(l - r)),\n    \u001b[1m\u001b[96m|\u001b[0m                                                                          \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":19040,"byte_end":19042,"line_start":545,"line_end":545,"column_start":74,"column_end":76,"is_primary":true,"text":[{"text":"            (Value::Number(l), BinaryOperator::Mul, Value::Number(r)) => Ok(Value::Number(l * r)),","highlight_start":74,"highlight_end":76}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:545:74\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m545\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             (Value::Number(l), BinaryOperator::Mul, Value::Number(r)) => Ok(Value::Number(l * r)),\n    \u001b[1m\u001b[96m|\u001b[0m                                                                          \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":19192,"byte_end":19195,"line_start":548,"line_end":548,"column_start":21,"column_end":24,"is_primary":true,"text":[{"text":"                    Err(RuntimeError::DivisionByZero)","highlight_start":21,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:548:21\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m548\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     Err(RuntimeError::DivisionByZero)\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":19271,"byte_end":19273,"line_start":550,"line_end":550,"column_start":21,"column_end":23,"is_primary":true,"text":[{"text":"                    Ok(Value::Number(l / r))","highlight_start":21,"highlight_end":23}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:550:21\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m550\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     Ok(Value::Number(l / r))\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":19454,"byte_end":19457,"line_start":555,"line_end":555,"column_start":21,"column_end":24,"is_primary":true,"text":[{"text":"                    Err(RuntimeError::DivisionByZero)","highlight_start":21,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:555:21\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m555\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     Err(RuntimeError::DivisionByZero)\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":19533,"byte_end":19535,"line_start":557,"line_end":557,"column_start":21,"column_end":23,"is_primary":true,"text":[{"text":"                    Ok(Value::Number(l % r))","highlight_start":21,"highlight_end":23}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:557:21\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m557\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     Ok(Value::Number(l % r))\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":19794,"byte_end":19796,"line_start":565,"line_end":565,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(Value::Text(result))","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:565:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m565\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(Value::Text(result))\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":19936,"byte_end":19938,"line_start":569,"line_end":569,"column_start":78,"column_end":80,"is_primary":true,"text":[{"text":"            (Value::Number(l), BinaryOperator::Greater, Value::Number(r)) => Ok(Value::Truth(l > r)),","highlight_start":78,"highlight_end":80}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:569:78\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m569\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             (Value::Number(l), BinaryOperator::Greater, Value::Number(r)) => Ok(Value::Truth(l > r)),\n    \u001b[1m\u001b[96m|\u001b[0m                                                                              \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":20035,"byte_end":20037,"line_start":570,"line_end":570,"column_start":75,"column_end":77,"is_primary":true,"text":[{"text":"            (Value::Number(l), BinaryOperator::Less, Value::Number(r)) => Ok(Value::Truth(l < r)),","highlight_start":75,"highlight_end":77}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:570:75\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m570\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             (Value::Number(l), BinaryOperator::Less, Value::Number(r)) => Ok(Value::Truth(l < r)),\n    \u001b[1m\u001b[96m|\u001b[0m                                                                           \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":20139,"byte_end":20141,"line_start":571,"line_end":571,"column_start":80,"column_end":82,"is_primary":true,"text":[{"text":"            (Value::Number(l), BinaryOperator::GreaterEq, Value::Number(r)) => Ok(Value::Truth(l >= r)),","highlight_start":80,"highlight_end":82}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:571:80\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m571\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             (Value::Number(l), BinaryOperator::GreaterEq, Value::Number(r)) => Ok(Value::Truth(l >= r)),\n    \u001b[1m\u001b[96m|\u001b[0m                                                                                \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":20241,"byte_end":20243,"line_start":572,"line_end":572,"column_start":77,"column_end":79,"is_primary":true,"text":[{"text":"            (Value::Number(l), BinaryOperator::LessEq, Value::Number(r)) => Ok(Value::Truth(l <= r)),","highlight_start":77,"highlight_end":79}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:572:77\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m572\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             (Value::Number(l), BinaryOperator::LessEq, Value::Number(r)) => Ok(Value::Truth(l <= r)),\n    \u001b[1m\u001b[96m|\u001b[0m                                                                             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":20359,"byte_end":20361,"line_start":575,"line_end":575,"column_start":46,"column_end":48,"is_primary":true,"text":[{"text":"            (l, BinaryOperator::Equal, r) => Ok(Value::Truth(l == r)),","highlight_start":46,"highlight_end":48}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:575:46\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m575\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             (l, BinaryOperator::Equal, r) => Ok(Value::Truth(l == r)),\n    \u001b[1m\u001b[96m|\u001b[0m                                              \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":20433,"byte_end":20435,"line_start":576,"line_end":576,"column_start":49,"column_end":51,"is_primary":true,"text":[{"text":"            (l, BinaryOperator::NotEqual, r) => Ok(Value::Truth(l != r)),","highlight_start":49,"highlight_end":51}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:576:49\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m576\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             (l, BinaryOperator::NotEqual, r) => Ok(Value::Truth(l != r)),\n    \u001b[1m\u001b[96m|\u001b[0m                                                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":20526,"byte_end":20528,"line_start":579,"line_end":579,"column_start":44,"column_end":46,"is_primary":true,"text":[{"text":"            (l, BinaryOperator::And, r) => Ok(Value::Truth(l.is_truthy() && r.is_truthy())),","highlight_start":44,"highlight_end":46}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:579:44\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m579\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             (l, BinaryOperator::And, r) => Ok(Value::Truth(l.is_truthy() && r.is_truthy())),\n    \u001b[1m\u001b[96m|\u001b[0m                                            \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":20618,"byte_end":20620,"line_start":580,"line_end":580,"column_start":43,"column_end":45,"is_primary":true,"text":[{"text":"            (l, BinaryOperator::Or, r) => Ok(Value::Truth(l.is_truthy() || r.is_truthy())),","highlight_start":43,"highlight_end":45}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:580:43\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m580\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             (l, BinaryOperator::Or, r) => Ok(Value::Truth(l.is_truthy() || r.is_truthy())),\n    \u001b[1m\u001b[96m|\u001b[0m                                           \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":20715,"byte_end":20718,"line_start":583,"line_end":583,"column_start":18,"column_end":21,"is_primary":true,"text":[{"text":"            _ => Err(RuntimeError::TypeError {","highlight_start":18,"highlight_end":21}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:583:18\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m583\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             _ => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m                  \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":20986,"byte_end":20992,"line_start":591,"line_end":591,"column_start":68,"column_end":74,"is_primary":true,"text":[{"text":"    fn eval_unary_op(&self, op: UnaryOperator, operand: &Value) -> Result<Value, RuntimeError> {","highlight_start":68,"highlight_end":74}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:591:68\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m591\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn eval_unary_op(&self, op: UnaryOperator, operand: &Value) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":21087,"byte_end":21089,"line_start":593,"line_end":593,"column_start":42,"column_end":44,"is_primary":true,"text":[{"text":"            (UnaryOperator::Not, val) => Ok(Value::Truth(!val.is_truthy())),","highlight_start":42,"highlight_end":44}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:593:42\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m593\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             (UnaryOperator::Not, val) => Ok(Value::Truth(!val.is_truthy())),\n    \u001b[1m\u001b[96m|\u001b[0m                                          \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":21180,"byte_end":21182,"line_start":594,"line_end":594,"column_start":58,"column_end":60,"is_primary":true,"text":[{"text":"            (UnaryOperator::Negate, Value::Number(n)) => Ok(Value::Number(-n)),","highlight_start":58,"highlight_end":60}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:594:58\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m594\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             (UnaryOperator::Negate, Value::Number(n)) => Ok(Value::Number(-n)),\n    \u001b[1m\u001b[96m|\u001b[0m                                                          \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":21247,"byte_end":21250,"line_start":595,"line_end":595,"column_start":45,"column_end":48,"is_primary":true,"text":[{"text":"            (UnaryOperator::Negate, val) => Err(RuntimeError::TypeError {","highlight_start":45,"highlight_end":48}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":375,"byte_end":375,"line_start":12,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:595:45\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m595\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             (UnaryOperator::Negate, val) => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m                                             \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m12\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":21551,"byte_end":21557,"line_start":609,"line_end":609,"column_start":38,"column_end":44,"is_primary":true,"text":[{"text":"    fn eval_program(source: &str) -> Result<Value, RuntimeError> {","highlight_start":38,"highlight_end":44}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":21439,"byte_end":21439,"line_start":605,"line_end":605,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":21439,"byte_end":21439,"line_start":605,"line_end":605,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\eval.rs","byte_start":21439,"byte_end":21439,"line_start":605,"line_end":605,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\eval.rs:609:38\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m609\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn eval_program(source: &str) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m605\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m605\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m605\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Option` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":6256,"byte_end":6262,"line_start":215,"line_end":215,"column_start":38,"column_end":44,"is_primary":true,"text":[{"text":"    fn get_var(&self, name: &str) -> Option<i32> {","highlight_start":38,"highlight_end":44}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this enum","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":678,"byte_end":678,"line_start":22,"line_end":22,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Option` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:215:38\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m215\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn get_var(&self, name: &str) -> Option<i32> {\n    \u001b[1m\u001b[96m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this enum\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m22\u001b[0m \u001b[92m+ use core::option::Option;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":6541,"byte_end":6547,"line_start":223,"line_end":223,"column_start":53,"column_end":59,"is_primary":true,"text":[{"text":"    pub fn compile(&mut self, nodes: &[AstNode]) -> Result<Vec<Instruction>, String> {","highlight_start":53,"highlight_end":59}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":678,"byte_end":678,"line_start":22,"line_end":22,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":678,"byte_end":678,"line_start":22,"line_end":22,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":678,"byte_end":678,"line_start":22,"line_end":22,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:223:53\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m223\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn compile(&mut self, nodes: &[AstNode]) -> Result<Vec<Instruction>, String> {\n    \u001b[1m\u001b[96m|\u001b[0m                                                     \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m22\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m22\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m22\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused variable: `error`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"heartwood\\src\\drivers\\ata.rs","byte_start":4724,"byte_end":4729,"line_start":138,"line_end":138,"column_start":25,"column_end":30,"is_primary":true,"text":[{"text":"                    let error = inb(bus + ATA_REG_ERROR);","highlight_start":25,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"heartwood\\src\\drivers\\ata.rs","byte_start":4724,"byte_end":4729,"line_start":138,"line_end":138,"column_start":25,"column_end":30,"is_primary":true,"text":[{"text":"                    let error = inb(bus + ATA_REG_ERROR);","highlight_start":25,"highlight_end":30}],"label":null,"suggested_replacement":"_error","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `error`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mheartwood\\src\\drivers\\ata.rs:138:25\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m138\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     let error = inb(bus + ATA_REG_ERROR);\n    \u001b[1m\u001b[96m|\u001b[0m                         \u001b[1m\u001b[93m^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_error`\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":7215,"byte_end":7217,"line_start":239,"line_end":239,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(self.instructions.clone())","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":678,"byte_end":678,"line_start":22,"line_end":22,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:239:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m239\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(self.instructions.clone())\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m22\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":7341,"byte_end":7347,"line_start":243,"line_end":243,"column_start":52,"column_end":58,"is_primary":true,"text":[{"text":"    fn gen_statement(&mut self, node: &AstNode) -> Result<(), String> {","highlight_start":52,"highlight_end":58}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":678,"byte_end":678,"line_start":22,"line_end":22,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":678,"byte_end":678,"line_start":22,"line_end":22,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":678,"byte_end":678,"line_start":22,"line_end":22,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:243:52\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m243\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn gen_statement(&mut self, node: &AstNode) -> Result<(), String> {\n    \u001b[1m\u001b[96m|\u001b[0m                                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m22\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m22\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m22\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":7851,"byte_end":7853,"line_start":256,"line_end":256,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(())","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":678,"byte_end":678,"line_start":22,"line_end":22,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:256:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m256\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(())\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m22\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":8366,"byte_end":8368,"line_start":271,"line_end":271,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(())","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":678,"byte_end":678,"line_start":22,"line_end":22,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:271:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m271\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(())\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m22\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":8483,"byte_end":8485,"line_start":276,"line_end":276,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(())","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":678,"byte_end":678,"line_start":22,"line_end":22,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:276:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m276\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(())\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m22\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":8522,"byte_end":8525,"line_start":279,"line_end":279,"column_start":18,"column_end":21,"is_primary":true,"text":[{"text":"            _ => Err(format!(\"Code generation not implemented for: {:?}\", node))","highlight_start":18,"highlight_end":21}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":678,"byte_end":678,"line_start":22,"line_end":22,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:279:18\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m279\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             _ => Err(format!(\"Code generation not implemented for: {:?}\", node))\n    \u001b[1m\u001b[96m|\u001b[0m                  \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m22\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":8705,"byte_end":8711,"line_start":284,"line_end":284,"column_start":47,"column_end":53,"is_primary":true,"text":[{"text":"    fn gen_expr(&mut self, node: &AstNode) -> Result<(), String> {","highlight_start":47,"highlight_end":53}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":678,"byte_end":678,"line_start":22,"line_end":22,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":678,"byte_end":678,"line_start":22,"line_end":22,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":678,"byte_end":678,"line_start":22,"line_end":22,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:284:47\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m284\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn gen_expr(&mut self, node: &AstNode) -> Result<(), String> {\n    \u001b[1m\u001b[96m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m22\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m22\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m22\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":9012,"byte_end":9014,"line_start":292,"line_end":292,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(())","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":678,"byte_end":678,"line_start":22,"line_end":22,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:292:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m292\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(())\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m22\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":9433,"byte_end":9435,"line_start":303,"line_end":303,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(())","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":678,"byte_end":678,"line_start":22,"line_end":22,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:303:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m303\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(())\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m22\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":11581,"byte_end":11584,"line_start":354,"line_end":354,"column_start":33,"column_end":36,"is_primary":true,"text":[{"text":"                    _ => return Err(format!(\"Operator not implemented: {:?}\", op)),","highlight_start":33,"highlight_end":36}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":678,"byte_end":678,"line_start":22,"line_end":22,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:354:33\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m354\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     _ => return Err(format!(\"Operator not implemented: {:?}\", op)),\n    \u001b[1m\u001b[96m|\u001b[0m                                 \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m22\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":11668,"byte_end":11670,"line_start":357,"line_end":357,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(())","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":678,"byte_end":678,"line_start":22,"line_end":22,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:357:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m357\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(())\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m22\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":12537,"byte_end":12539,"line_start":379,"line_end":379,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(())","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":678,"byte_end":678,"line_start":22,"line_end":22,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:379:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m379\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(())\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m22\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":12576,"byte_end":12579,"line_start":382,"line_end":382,"column_start":18,"column_end":21,"is_primary":true,"text":[{"text":"            _ => Err(format!(\"Expression codegen not implemented: {:?}\", node))","highlight_start":18,"highlight_end":21}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":678,"byte_end":678,"line_start":22,"line_end":22,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:382:18\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m382\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             _ => Err(format!(\"Expression codegen not implemented: {:?}\", node))\n    \u001b[1m\u001b[96m|\u001b[0m                  \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m22\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":13123,"byte_end":13129,"line_start":404,"line_end":404,"column_start":45,"column_end":51,"is_primary":true,"text":[{"text":"pub fn compile_to_asm(nodes: &[AstNode]) -> Result<String, String> {","highlight_start":45,"highlight_end":51}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":678,"byte_end":678,"line_start":22,"line_end":22,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":678,"byte_end":678,"line_start":22,"line_end":22,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":678,"byte_end":678,"line_start":22,"line_end":22,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:404:45\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m404\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn compile_to_asm(nodes: &[AstNode]) -> Result<String, String> {\n    \u001b[1m\u001b[96m|\u001b[0m                                             \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m22\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m22\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m22\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":13219,"byte_end":13221,"line_start":407,"line_end":407,"column_start":5,"column_end":7,"is_primary":true,"text":[{"text":"    Ok(codegen.to_assembly())","highlight_start":5,"highlight_end":7}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":678,"byte_end":678,"line_start":22,"line_end":22,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:407:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m407\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Ok(codegen.to_assembly())\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m22\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":723,"byte_end":729,"line_start":20,"line_end":20,"column_start":37,"column_end":43,"is_primary":true,"text":[{"text":"pub type NativeFn = fn(&[Value]) -> Result<Value, RuntimeError>;","highlight_start":37,"highlight_end":43}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:20:37\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m20\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub type NativeFn = fn(&[Value]) -> Result<Value, RuntimeError>;\n   \u001b[1m\u001b[96m|\u001b[0m                                     \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Option` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":916,"byte_end":922,"line_start":27,"line_end":27,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"    pub arity: Option<usize>,  // None = variadic","highlight_start":16,"highlight_end":22}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this enum","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Option` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:27:16\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m27\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub arity: Option<usize>,  // None = variadic\n   \u001b[1m\u001b[96m|\u001b[0m                \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this enum\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Option` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":1010,"byte_end":1016,"line_start":31,"line_end":31,"column_start":35,"column_end":41,"is_primary":true,"text":[{"text":"    pub fn new(name: &str, arity: Option<usize>, func: NativeFn) -> Self {","highlight_start":35,"highlight_end":41}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this enum","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Option` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:31:35\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m31\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn new(name: &str, arity: Option<usize>, func: NativeFn) -> Self {\n   \u001b[1m\u001b[96m|\u001b[0m                                   \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this enum\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find trait `PartialEq` in this scope","code":{"code":"E0405","explanation":"The code refers to a trait that is not in scope.\n\nErroneous code example:\n\n```compile_fail,E0405\nstruct Foo;\n\nimpl SomeTrait for Foo {} // error: trait `SomeTrait` is not in scope\n```\n\nPlease verify that the name of the trait wasn't misspelled and ensure that it\nwas imported. Example:\n\n```\n# #[cfg(for_demonstration_only)]\n// solution 1:\nuse some_file::SomeTrait;\n\n// solution 2:\ntrait SomeTrait {\n    // some functions\n}\n\nstruct Foo;\n\nimpl SomeTrait for Foo { // ok!\n    // implements functions\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":1443,"byte_end":1452,"line_start":49,"line_end":49,"column_start":6,"column_end":15,"is_primary":true,"text":[{"text":"impl PartialEq for NativeFunction {","highlight_start":6,"highlight_end":15}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this trait","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::cmp::PartialEq;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0405]\u001b[0m\u001b[1m\u001b[97m: cannot find trait `PartialEq` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:49:6\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m49\u001b[0m \u001b[1m\u001b[96m|\u001b[0m impl PartialEq for NativeFunction {\n   \u001b[1m\u001b[96m|\u001b[0m      \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this trait\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::cmp::PartialEq;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":1717,"byte_end":1721,"line_start":59,"line_end":59,"column_start":39,"column_end":43,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"length\", Some(1), string_length),","highlight_start":39,"highlight_end":43}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:59:39\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m59\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"length\", Some(1), string_length),\n   \u001b[1m\u001b[96m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":1779,"byte_end":1783,"line_start":60,"line_end":60,"column_start":38,"column_end":42,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"slice\", Some(3), string_slice),","highlight_start":38,"highlight_end":42}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:60:38\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m60\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"slice\", Some(3), string_slice),\n   \u001b[1m\u001b[96m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":1841,"byte_end":1845,"line_start":61,"line_end":61,"column_start":39,"column_end":43,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"concat\", Some(2), string_concat),","highlight_start":39,"highlight_end":43}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:61:39\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m61\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"concat\", Some(2), string_concat),\n   \u001b[1m\u001b[96m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":1903,"byte_end":1907,"line_start":62,"line_end":62,"column_start":38,"column_end":42,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"upper\", Some(1), string_upper),","highlight_start":38,"highlight_end":42}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:62:38\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m62\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"upper\", Some(1), string_upper),\n   \u001b[1m\u001b[96m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":1964,"byte_end":1968,"line_start":63,"line_end":63,"column_start":38,"column_end":42,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"lower\", Some(1), string_lower),","highlight_start":38,"highlight_end":42}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:63:38\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m63\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"lower\", Some(1), string_lower),\n   \u001b[1m\u001b[96m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":2025,"byte_end":2029,"line_start":64,"line_end":64,"column_start":38,"column_end":42,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"split\", Some(2), string_split),","highlight_start":38,"highlight_end":42}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:64:38\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m64\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"split\", Some(2), string_split),\n   \u001b[1m\u001b[96m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":2085,"byte_end":2089,"line_start":65,"line_end":65,"column_start":37,"column_end":41,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"join\", Some(2), string_join),","highlight_start":37,"highlight_end":41}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:65:37\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m65\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"join\", Some(2), string_join),\n   \u001b[1m\u001b[96m|\u001b[0m                                     \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":2144,"byte_end":2148,"line_start":66,"line_end":66,"column_start":37,"column_end":41,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"trim\", Some(1), string_trim),","highlight_start":37,"highlight_end":41}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:66:37\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m66\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"trim\", Some(1), string_trim),\n   \u001b[1m\u001b[96m|\u001b[0m                                     \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":2210,"byte_end":2214,"line_start":67,"line_end":67,"column_start":44,"column_end":48,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"starts_with\", Some(2), string_starts_with),","highlight_start":44,"highlight_end":48}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:67:44\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m67\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"starts_with\", Some(2), string_starts_with),\n   \u001b[1m\u001b[96m|\u001b[0m                                            \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":2281,"byte_end":2285,"line_start":68,"line_end":68,"column_start":42,"column_end":46,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"ends_with\", Some(2), string_ends_with),","highlight_start":42,"highlight_end":46}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:68:42\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m68\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"ends_with\", Some(2), string_ends_with),\n   \u001b[1m\u001b[96m|\u001b[0m                                          \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":2349,"byte_end":2353,"line_start":69,"line_end":69,"column_start":41,"column_end":45,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"contains\", Some(2), string_contains),","highlight_start":41,"highlight_end":45}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:69:41\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m69\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"contains\", Some(2), string_contains),\n   \u001b[1m\u001b[96m|\u001b[0m                                         \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":2446,"byte_end":2450,"line_start":72,"line_end":72,"column_start":36,"column_end":40,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"abs\", Some(1), math_abs),","highlight_start":36,"highlight_end":40}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:72:36\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m72\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"abs\", Some(1), math_abs),\n   \u001b[1m\u001b[96m|\u001b[0m                                    \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":2502,"byte_end":2506,"line_start":73,"line_end":73,"column_start":37,"column_end":41,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"sqrt\", Some(1), math_sqrt),","highlight_start":37,"highlight_end":41}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:73:37\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m73\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"sqrt\", Some(1), math_sqrt),\n   \u001b[1m\u001b[96m|\u001b[0m                                     \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":2558,"byte_end":2562,"line_start":74,"line_end":74,"column_start":36,"column_end":40,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"pow\", Some(2), math_pow),","highlight_start":36,"highlight_end":40}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:74:36\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m74\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"pow\", Some(2), math_pow),\n   \u001b[1m\u001b[96m|\u001b[0m                                    \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":2613,"byte_end":2617,"line_start":75,"line_end":75,"column_start":36,"column_end":40,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"min\", Some(2), math_min),","highlight_start":36,"highlight_end":40}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:75:36\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m75\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"min\", Some(2), math_min),\n   \u001b[1m\u001b[96m|\u001b[0m                                    \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":2668,"byte_end":2672,"line_start":76,"line_end":76,"column_start":36,"column_end":40,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"max\", Some(2), math_max),","highlight_start":36,"highlight_end":40}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:76:36\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m76\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"max\", Some(2), math_max),\n   \u001b[1m\u001b[96m|\u001b[0m                                    \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":2725,"byte_end":2729,"line_start":77,"line_end":77,"column_start":38,"column_end":42,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"floor\", Some(1), math_floor),","highlight_start":38,"highlight_end":42}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:77:38\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m77\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"floor\", Some(1), math_floor),\n   \u001b[1m\u001b[96m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":2783,"byte_end":2787,"line_start":78,"line_end":78,"column_start":37,"column_end":41,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"ceil\", Some(1), math_ceil),","highlight_start":37,"highlight_end":41}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:78:37\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m78\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"ceil\", Some(1), math_ceil),\n   \u001b[1m\u001b[96m|\u001b[0m                                     \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":2841,"byte_end":2845,"line_start":79,"line_end":79,"column_start":38,"column_end":42,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"round\", Some(1), math_round),","highlight_start":38,"highlight_end":42}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:79:38\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m79\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"round\", Some(1), math_round),\n   \u001b[1m\u001b[96m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":2941,"byte_end":2945,"line_start":82,"line_end":82,"column_start":44,"column_end":48,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"list_length\", Some(1), list_length),","highlight_start":44,"highlight_end":48}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:82:44\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m82\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"list_length\", Some(1), list_length),\n   \u001b[1m\u001b[96m|\u001b[0m                                            \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":3005,"byte_end":3009,"line_start":83,"line_end":83,"column_start":42,"column_end":46,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"list_push\", Some(2), list_push),","highlight_start":42,"highlight_end":46}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:83:42\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m83\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"list_push\", Some(2), list_push),\n   \u001b[1m\u001b[96m|\u001b[0m                                          \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":3066,"byte_end":3070,"line_start":84,"line_end":84,"column_start":41,"column_end":45,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"list_pop\", Some(1), list_pop),","highlight_start":41,"highlight_end":45}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:84:41\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m84\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"list_pop\", Some(1), list_pop),\n   \u001b[1m\u001b[96m|\u001b[0m                                         \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":3130,"byte_end":3134,"line_start":85,"line_end":85,"column_start":45,"column_end":49,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"list_reverse\", Some(1), list_reverse),","highlight_start":45,"highlight_end":49}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:85:45\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m85\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"list_reverse\", Some(1), list_reverse),\n   \u001b[1m\u001b[96m|\u001b[0m                                             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":3196,"byte_end":3200,"line_start":86,"line_end":86,"column_start":43,"column_end":47,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"list_first\", Some(1), list_first),","highlight_start":43,"highlight_end":47}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:86:43\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m86\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"list_first\", Some(1), list_first),\n   \u001b[1m\u001b[96m|\u001b[0m                                           \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":3259,"byte_end":3263,"line_start":87,"line_end":87,"column_start":42,"column_end":46,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"list_last\", Some(1), list_last),","highlight_start":42,"highlight_end":46}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:87:42\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m87\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"list_last\", Some(1), list_last),\n   \u001b[1m\u001b[96m|\u001b[0m                                          \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":3354,"byte_end":3358,"line_start":90,"line_end":90,"column_start":41,"column_end":45,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"map_keys\", Some(1), map_keys),","highlight_start":41,"highlight_end":45}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:90:41\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m90\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"map_keys\", Some(1), map_keys),\n   \u001b[1m\u001b[96m|\u001b[0m                                         \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":3416,"byte_end":3420,"line_start":91,"line_end":91,"column_start":43,"column_end":47,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"map_values\", Some(1), map_values),","highlight_start":43,"highlight_end":47}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:91:43\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m91\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"map_values\", Some(1), map_values),\n   \u001b[1m\u001b[96m|\u001b[0m                                           \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":3477,"byte_end":3481,"line_start":92,"line_end":92,"column_start":40,"column_end":44,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"map_has\", Some(2), map_has),","highlight_start":40,"highlight_end":44}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:92:40\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m92\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"map_has\", Some(2), map_has),\n   \u001b[1m\u001b[96m|\u001b[0m                                        \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":3536,"byte_end":3540,"line_start":93,"line_end":93,"column_start":41,"column_end":45,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"map_size\", Some(1), map_size),","highlight_start":41,"highlight_end":45}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:93:41\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m93\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"map_size\", Some(1), map_size),\n   \u001b[1m\u001b[96m|\u001b[0m                                         \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":3631,"byte_end":3635,"line_start":96,"line_end":96,"column_start":40,"column_end":44,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"to_text\", Some(1), to_text),","highlight_start":40,"highlight_end":44}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:96:40\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m96\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"to_text\", Some(1), to_text),\n   \u001b[1m\u001b[96m|\u001b[0m                                        \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":3691,"byte_end":3695,"line_start":97,"line_end":97,"column_start":42,"column_end":46,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"to_number\", Some(1), to_number),","highlight_start":42,"highlight_end":46}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:97:42\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m97\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"to_number\", Some(1), to_number),\n   \u001b[1m\u001b[96m|\u001b[0m                                          \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":3752,"byte_end":3756,"line_start":98,"line_end":98,"column_start":41,"column_end":45,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"to_truth\", Some(1), to_truth),","highlight_start":41,"highlight_end":45}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:98:41\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m98\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"to_truth\", Some(1), to_truth),\n   \u001b[1m\u001b[96m|\u001b[0m                                         \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":3811,"byte_end":3815,"line_start":99,"line_end":99,"column_start":40,"column_end":44,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"type_of\", Some(1), type_of),","highlight_start":40,"highlight_end":44}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:99:40\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m99\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"type_of\", Some(1), type_of),\n   \u001b[1m\u001b[96m|\u001b[0m                                        \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find value `None` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":3901,"byte_end":3905,"line_start":102,"line_end":102,"column_start":38,"column_end":42,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"print\", None, io_print),","highlight_start":38,"highlight_end":42}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these unit variants","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::elf::ElfClass::None;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::elf::ElfData::None;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::elf::ElfMachine::None;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::elf::ElfType::None;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::None;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find value `None` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:102:38\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m102\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"print\", None, io_print),\n    \u001b[1m\u001b[96m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these unit variants\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use crate::elf::ElfClass::None;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use crate::elf::ElfData::None;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use crate::elf::ElfMachine::None;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use crate::elf::ElfType::None;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0mand 1 other candidate\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find value `None` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":3957,"byte_end":3961,"line_start":103,"line_end":103,"column_start":40,"column_end":44,"is_primary":true,"text":[{"text":"        NativeFunction::new(\"println\", None, io_println),","highlight_start":40,"highlight_end":44}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these unit variants","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::elf::ElfClass::None;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::elf::ElfData::None;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::elf::ElfMachine::None;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::elf::ElfType::None;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::None;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find value `None` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:103:40\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m103\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         NativeFunction::new(\"println\", None, io_println),\n    \u001b[1m\u001b[96m|\u001b[0m                                        \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these unit variants\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use crate::elf::ElfClass::None;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use crate::elf::ElfData::None;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use crate::elf::ElfMachine::None;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use crate::elf::ElfType::None;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0mand 1 other candidate\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":4202,"byte_end":4208,"line_start":111,"line_end":111,"column_start":37,"column_end":43,"is_primary":true,"text":[{"text":"fn string_length(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":37,"highlight_end":43}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:111:37\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m111\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn string_length(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                     \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":4279,"byte_end":4281,"line_start":113,"line_end":113,"column_start":27,"column_end":29,"is_primary":true,"text":[{"text":"        Value::Text(s) => Ok(Value::Number(s.len() as f64)),","highlight_start":27,"highlight_end":29}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:113:27\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m113\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Value::Text(s) => Ok(Value::Number(s.len() as f64)),\n    \u001b[1m\u001b[96m|\u001b[0m                           \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":4327,"byte_end":4330,"line_start":114,"line_end":114,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        v => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:114:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m114\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         v => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":4499,"byte_end":4505,"line_start":121,"line_end":121,"column_start":36,"column_end":42,"is_primary":true,"text":[{"text":"fn string_slice(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":36,"highlight_end":42}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:121:36\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m121\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn string_slice(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":4811,"byte_end":4814,"line_start":128,"line_end":128,"column_start":24,"column_end":27,"is_primary":true,"text":[{"text":"                return Err(RuntimeError::IndexOutOfBounds {","highlight_start":24,"highlight_end":27}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:128:24\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m128\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 return Err(RuntimeError::IndexOutOfBounds {\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":4998,"byte_end":5000,"line_start":134,"line_end":134,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"            Ok(Value::Text(s[start..end].to_string()))","highlight_start":13,"highlight_end":15}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:134:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m134\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(Value::Text(s[start..end].to_string()))\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":5064,"byte_end":5067,"line_start":136,"line_end":136,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        _ => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:136:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m136\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         _ => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":5312,"byte_end":5318,"line_start":143,"line_end":143,"column_start":37,"column_end":43,"is_primary":true,"text":[{"text":"fn string_concat(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":37,"highlight_end":43}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:143:37\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m143\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn string_concat(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                     \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":5509,"byte_end":5511,"line_start":148,"line_end":148,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"            Ok(Value::Text(result))","highlight_start":13,"highlight_end":15}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:148:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m148\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(Value::Text(result))\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":5556,"byte_end":5559,"line_start":150,"line_end":150,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        _ => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:150:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m150\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         _ => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":5768,"byte_end":5774,"line_start":157,"line_end":157,"column_start":36,"column_end":42,"is_primary":true,"text":[{"text":"fn string_upper(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":36,"highlight_end":42}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:157:36\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m157\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn string_upper(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":6003,"byte_end":6005,"line_start":164,"line_end":164,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"            Ok(Value::Text(result))","highlight_start":13,"highlight_end":15}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:164:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m164\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(Value::Text(result))\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":6050,"byte_end":6053,"line_start":166,"line_end":166,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        v => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:166:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m166\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         v => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":6222,"byte_end":6228,"line_start":173,"line_end":173,"column_start":36,"column_end":42,"is_primary":true,"text":[{"text":"fn string_lower(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":36,"highlight_end":42}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:173:36\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m173\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn string_lower(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":6457,"byte_end":6459,"line_start":180,"line_end":180,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"            Ok(Value::Text(result))","highlight_start":13,"highlight_end":15}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:180:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m180\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(Value::Text(result))\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":6504,"byte_end":6507,"line_start":182,"line_end":182,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        v => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:182:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m182\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         v => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":6676,"byte_end":6682,"line_start":189,"line_end":189,"column_start":36,"column_end":42,"is_primary":true,"text":[{"text":"fn string_split(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":36,"highlight_end":42}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:189:36\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m189\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn string_split(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":6956,"byte_end":6958,"line_start":195,"line_end":195,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"            Ok(Value::List(parts))","highlight_start":13,"highlight_end":15}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:195:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m195\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(Value::List(parts))\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":7002,"byte_end":7005,"line_start":197,"line_end":197,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        _ => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:197:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m197\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         _ => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":7213,"byte_end":7219,"line_start":204,"line_end":204,"column_start":35,"column_end":41,"is_primary":true,"text":[{"text":"fn string_join(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":35,"highlight_end":41}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:204:35\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m204\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn string_join(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                   \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":7359,"byte_end":7365,"line_start":207,"line_end":207,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"            let strings: Result<Vec<String>, RuntimeError> = items.iter()","highlight_start":26,"highlight_end":32}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:207:26\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m207\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             let strings: Result<Vec<String>, RuntimeError> = items.iter()\n    \u001b[1m\u001b[96m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":7481,"byte_end":7483,"line_start":209,"line_end":209,"column_start":39,"column_end":41,"is_primary":true,"text":[{"text":"                    Value::Text(s) => Ok(s.clone()),","highlight_start":39,"highlight_end":41}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:209:39\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m209\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     Value::Text(s) => Ok(s.clone()),\n    \u001b[1m\u001b[96m|\u001b[0m                                       \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":7521,"byte_end":7524,"line_start":210,"line_end":210,"column_start":26,"column_end":29,"is_primary":true,"text":[{"text":"                    v => Err(RuntimeError::TypeError {","highlight_start":26,"highlight_end":29}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:210:26\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m210\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     v => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m                          \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":8023,"byte_end":8025,"line_start":225,"line_end":225,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"            Ok(Value::Text(result))","highlight_start":13,"highlight_end":15}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:225:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m225\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(Value::Text(result))\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":8070,"byte_end":8073,"line_start":227,"line_end":227,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        _ => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:227:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m227\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         _ => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":8281,"byte_end":8287,"line_start":234,"line_end":234,"column_start":35,"column_end":41,"is_primary":true,"text":[{"text":"fn string_trim(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":35,"highlight_end":41}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:234:35\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m234\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn string_trim(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                   \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":8358,"byte_end":8360,"line_start":236,"line_end":236,"column_start":27,"column_end":29,"is_primary":true,"text":[{"text":"        Value::Text(s) => Ok(Value::Text(s.trim().to_string())),","highlight_start":27,"highlight_end":29}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:236:27\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m236\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Value::Text(s) => Ok(Value::Text(s.trim().to_string())),\n    \u001b[1m\u001b[96m|\u001b[0m                           \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":8410,"byte_end":8413,"line_start":237,"line_end":237,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        v => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:237:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m237\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         v => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":8588,"byte_end":8594,"line_start":244,"line_end":244,"column_start":42,"column_end":48,"is_primary":true,"text":[{"text":"fn string_starts_with(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":42,"highlight_end":48}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:244:42\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m244\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn string_starts_with(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                          \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":8714,"byte_end":8716,"line_start":247,"line_end":247,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"            Ok(Value::Truth(s.starts_with(prefix.as_str())))","highlight_start":13,"highlight_end":15}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:247:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m247\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(Value::Truth(s.starts_with(prefix.as_str())))\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":8786,"byte_end":8789,"line_start":249,"line_end":249,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        _ => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:249:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m249\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         _ => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":9002,"byte_end":9008,"line_start":256,"line_end":256,"column_start":40,"column_end":46,"is_primary":true,"text":[{"text":"fn string_ends_with(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":40,"highlight_end":46}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:256:40\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m256\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn string_ends_with(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                        \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":9128,"byte_end":9130,"line_start":259,"line_end":259,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"            Ok(Value::Truth(s.ends_with(suffix.as_str())))","highlight_start":13,"highlight_end":15}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:259:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m259\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(Value::Truth(s.ends_with(suffix.as_str())))\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":9198,"byte_end":9201,"line_start":261,"line_end":261,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        _ => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:261:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m261\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         _ => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":9413,"byte_end":9419,"line_start":268,"line_end":268,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"fn string_contains(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":39,"highlight_end":45}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:268:39\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m268\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn string_contains(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":9542,"byte_end":9544,"line_start":271,"line_end":271,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"            Ok(Value::Truth(s.contains(substring.as_str())))","highlight_start":13,"highlight_end":15}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:271:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m271\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(Value::Truth(s.contains(substring.as_str())))\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":9614,"byte_end":9617,"line_start":273,"line_end":273,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        _ => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:273:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m273\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         _ => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":10001,"byte_end":10007,"line_start":284,"line_end":284,"column_start":32,"column_end":38,"is_primary":true,"text":[{"text":"fn math_abs(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":32,"highlight_end":38}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:284:32\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m284\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn math_abs(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":10080,"byte_end":10082,"line_start":286,"line_end":286,"column_start":29,"column_end":31,"is_primary":true,"text":[{"text":"        Value::Number(n) => Ok(Value::Number(n.abs())),","highlight_start":29,"highlight_end":31}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:286:29\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m286\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Value::Number(n) => Ok(Value::Number(n.abs())),\n    \u001b[1m\u001b[96m|\u001b[0m                             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":10121,"byte_end":10124,"line_start":287,"line_end":287,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        v => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:287:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m287\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         v => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":10292,"byte_end":10298,"line_start":294,"line_end":294,"column_start":33,"column_end":39,"is_primary":true,"text":[{"text":"fn math_sqrt(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":33,"highlight_end":39}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:294:33\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m294\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn math_sqrt(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                 \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":10415,"byte_end":10418,"line_start":298,"line_end":298,"column_start":17,"column_end":20,"is_primary":true,"text":[{"text":"                Err(RuntimeError::Custom(\"Cannot take square root of negative number\".to_string()))","highlight_start":17,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:298:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m298\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(RuntimeError::Custom(\"Cannot take square root of negative number\".to_string()))\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":10536,"byte_end":10538,"line_start":300,"line_end":300,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"                Ok(Value::Number(libm::sqrt(*n)))","highlight_start":17,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:300:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m300\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Ok(Value::Number(libm::sqrt(*n)))\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":10607,"byte_end":10610,"line_start":303,"line_end":303,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        v => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:303:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m303\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         v => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":10777,"byte_end":10783,"line_start":310,"line_end":310,"column_start":32,"column_end":38,"is_primary":true,"text":[{"text":"fn math_pow(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":32,"highlight_end":38}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:310:32\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m310\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn math_pow(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":10907,"byte_end":10909,"line_start":313,"line_end":313,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"            Ok(Value::Number(libm::pow(*base, *exp)))","highlight_start":13,"highlight_end":15}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:313:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m313\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(Value::Number(libm::pow(*base, *exp)))\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":10972,"byte_end":10975,"line_start":315,"line_end":315,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        _ => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:315:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m315\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         _ => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":11184,"byte_end":11190,"line_start":322,"line_end":322,"column_start":32,"column_end":38,"is_primary":true,"text":[{"text":"fn math_min(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":32,"highlight_end":38}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:322:32\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m322\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn math_min(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":11309,"byte_end":11311,"line_start":325,"line_end":325,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"            Ok(Value::Number(if a < b { *a } else { *b }))","highlight_start":13,"highlight_end":15}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:325:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m325\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(Value::Number(if a < b { *a } else { *b }))\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":11379,"byte_end":11382,"line_start":327,"line_end":327,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        _ => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:327:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m327\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         _ => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":11591,"byte_end":11597,"line_start":334,"line_end":334,"column_start":32,"column_end":38,"is_primary":true,"text":[{"text":"fn math_max(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":32,"highlight_end":38}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:334:32\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m334\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn math_max(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":11716,"byte_end":11718,"line_start":337,"line_end":337,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"            Ok(Value::Number(if a > b { *a } else { *b }))","highlight_start":13,"highlight_end":15}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:337:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m337\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(Value::Number(if a > b { *a } else { *b }))\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":11786,"byte_end":11789,"line_start":339,"line_end":339,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        _ => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:339:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m339\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         _ => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":12000,"byte_end":12006,"line_start":346,"line_end":346,"column_start":34,"column_end":40,"is_primary":true,"text":[{"text":"fn math_floor(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":34,"highlight_end":40}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:346:34\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m346\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn math_floor(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":12079,"byte_end":12081,"line_start":348,"line_end":348,"column_start":29,"column_end":31,"is_primary":true,"text":[{"text":"        Value::Number(n) => Ok(Value::Number(libm::floor(*n))),","highlight_start":29,"highlight_end":31}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:348:29\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m348\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Value::Number(n) => Ok(Value::Number(libm::floor(*n))),\n    \u001b[1m\u001b[96m|\u001b[0m                             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":12128,"byte_end":12131,"line_start":349,"line_end":349,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        v => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:349:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m349\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         v => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":12299,"byte_end":12305,"line_start":356,"line_end":356,"column_start":33,"column_end":39,"is_primary":true,"text":[{"text":"fn math_ceil(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":33,"highlight_end":39}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:356:33\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m356\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn math_ceil(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                 \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":12378,"byte_end":12380,"line_start":358,"line_end":358,"column_start":29,"column_end":31,"is_primary":true,"text":[{"text":"        Value::Number(n) => Ok(Value::Number(libm::ceil(*n))),","highlight_start":29,"highlight_end":31}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:358:29\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m358\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Value::Number(n) => Ok(Value::Number(libm::ceil(*n))),\n    \u001b[1m\u001b[96m|\u001b[0m                             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":12426,"byte_end":12429,"line_start":359,"line_end":359,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        v => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:359:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m359\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         v => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":12598,"byte_end":12604,"line_start":366,"line_end":366,"column_start":34,"column_end":40,"is_primary":true,"text":[{"text":"fn math_round(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":34,"highlight_end":40}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:366:34\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m366\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn math_round(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":12677,"byte_end":12679,"line_start":368,"line_end":368,"column_start":29,"column_end":31,"is_primary":true,"text":[{"text":"        Value::Number(n) => Ok(Value::Number(libm::round(*n))),","highlight_start":29,"highlight_end":31}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:368:29\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m368\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Value::Number(n) => Ok(Value::Number(libm::round(*n))),\n    \u001b[1m\u001b[96m|\u001b[0m                             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":12726,"byte_end":12729,"line_start":369,"line_end":369,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        v => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:369:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m369\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         v => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":13078,"byte_end":13084,"line_start":380,"line_end":380,"column_start":35,"column_end":41,"is_primary":true,"text":[{"text":"fn list_length(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":35,"highlight_end":41}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:380:35\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m380\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn list_length(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                   \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":13155,"byte_end":13157,"line_start":382,"line_end":382,"column_start":27,"column_end":29,"is_primary":true,"text":[{"text":"        Value::List(l) => Ok(Value::Number(l.len() as f64)),","highlight_start":27,"highlight_end":29}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:382:27\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m382\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Value::List(l) => Ok(Value::Number(l.len() as f64)),\n    \u001b[1m\u001b[96m|\u001b[0m                           \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":13203,"byte_end":13206,"line_start":383,"line_end":383,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        v => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:383:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m383\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         v => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":13372,"byte_end":13378,"line_start":390,"line_end":390,"column_start":33,"column_end":39,"is_primary":true,"text":[{"text":"fn list_push(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":33,"highlight_end":39}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:390:33\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m390\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn list_push(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                 \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":13549,"byte_end":13551,"line_start":395,"line_end":395,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"            Ok(Value::List(new_list))","highlight_start":13,"highlight_end":15}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:395:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m395\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(Value::List(new_list))\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":13598,"byte_end":13601,"line_start":397,"line_end":397,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        v => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:397:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m397\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         v => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0369, E0463.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mSome errors have detailed explanations: E0369, E0463.\u001b[0m\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/heartwood#0.1.0","manifest_path":"F:\\OS\\heartwood\\Cargo.toml","target":{"kind":["staticlib","rlib"],"crate_types":["staticlib","rlib"],"name":"heartwood","src_path":"F:\\OS\\heartwood\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0369`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mFor more information about an error, try `rustc --explain E0369`.\u001b[0m\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":13766,"byte_end":13772,"line_start":404,"line_end":404,"column_start":32,"column_end":38,"is_primary":true,"text":[{"text":"fn list_pop(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":32,"highlight_end":38}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:404:32\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m404\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn list_pop(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":13898,"byte_end":13901,"line_start":408,"line_end":408,"column_start":24,"column_end":27,"is_primary":true,"text":[{"text":"                return Err(RuntimeError::Custom(\"Cannot pop from empty list\".to_string()));","highlight_start":24,"highlight_end":27}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:408:24\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m408\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 return Err(RuntimeError::Custom(\"Cannot pop from empty list\".to_string()));\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":14063,"byte_end":14065,"line_start":412,"line_end":412,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"            Ok(Value::List(new_list))","highlight_start":13,"highlight_end":15}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:412:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m412\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(Value::List(new_list))\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":14112,"byte_end":14115,"line_start":414,"line_end":414,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        v => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:414:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m414\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         v => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":14284,"byte_end":14290,"line_start":421,"line_end":421,"column_start":36,"column_end":42,"is_primary":true,"text":[{"text":"fn list_reverse(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":36,"highlight_end":42}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:421:36\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m421\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn list_reverse(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                    \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":14449,"byte_end":14451,"line_start":426,"line_end":426,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"            Ok(Value::List(new_list))","highlight_start":13,"highlight_end":15}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:426:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m426\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(Value::List(new_list))\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":14498,"byte_end":14501,"line_start":428,"line_end":428,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        v => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:428:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m428\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         v => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":14668,"byte_end":14674,"line_start":435,"line_end":435,"column_start":34,"column_end":40,"is_primary":true,"text":[{"text":"fn list_first(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":34,"highlight_end":40}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:435:34\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m435\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn list_first(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":14800,"byte_end":14803,"line_start":439,"line_end":439,"column_start":24,"column_end":27,"is_primary":true,"text":[{"text":"                return Err(RuntimeError::Custom(\"Cannot get first element of empty list\".to_string()));","highlight_start":24,"highlight_end":27}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:439:24\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m439\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 return Err(RuntimeError::Custom(\"Cannot get first element of empty list\".to_string()));\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":14907,"byte_end":14909,"line_start":441,"line_end":441,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"            Ok(l[0].clone())","highlight_start":13,"highlight_end":15}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:441:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m441\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(l[0].clone())\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":14947,"byte_end":14950,"line_start":443,"line_end":443,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        v => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:443:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m443\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         v => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":15116,"byte_end":15122,"line_start":450,"line_end":450,"column_start":33,"column_end":39,"is_primary":true,"text":[{"text":"fn list_last(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":33,"highlight_end":39}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:450:33\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m450\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn list_last(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                 \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":15248,"byte_end":15251,"line_start":454,"line_end":454,"column_start":24,"column_end":27,"is_primary":true,"text":[{"text":"                return Err(RuntimeError::Custom(\"Cannot get last element of empty list\".to_string()));","highlight_start":24,"highlight_end":27}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:454:24\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m454\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 return Err(RuntimeError::Custom(\"Cannot get last element of empty list\".to_string()));\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":15354,"byte_end":15356,"line_start":456,"line_end":456,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"            Ok(l[l.len() - 1].clone())","highlight_start":13,"highlight_end":15}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:456:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m456\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(l[l.len() - 1].clone())\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":15404,"byte_end":15407,"line_start":458,"line_end":458,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        v => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:458:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m458\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         v => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":15750,"byte_end":15756,"line_start":469,"line_end":469,"column_start":32,"column_end":38,"is_primary":true,"text":[{"text":"fn map_keys(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":32,"highlight_end":38}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:469:32\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m469\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn map_keys(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":15961,"byte_end":15963,"line_start":475,"line_end":475,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"            Ok(Value::List(keys))","highlight_start":13,"highlight_end":15}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:475:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m475\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(Value::List(keys))\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":16006,"byte_end":16009,"line_start":477,"line_end":477,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        v => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:477:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m477\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         v => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":16175,"byte_end":16181,"line_start":484,"line_end":484,"column_start":34,"column_end":40,"is_primary":true,"text":[{"text":"fn map_values(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":34,"highlight_end":40}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:484:34\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m484\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn map_values(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":16367,"byte_end":16369,"line_start":490,"line_end":490,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"            Ok(Value::List(values))","highlight_start":13,"highlight_end":15}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:490:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m490\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(Value::List(values))\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":16414,"byte_end":16417,"line_start":492,"line_end":492,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        v => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:492:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m492\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         v => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":16580,"byte_end":16586,"line_start":499,"line_end":499,"column_start":31,"column_end":37,"is_primary":true,"text":[{"text":"fn map_has(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":31,"highlight_end":37}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:499:31\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m499\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn map_has(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":16702,"byte_end":16704,"line_start":502,"line_end":502,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"            Ok(Value::Truth(m.contains_key(key)))","highlight_start":13,"highlight_end":15}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:502:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m502\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(Value::Truth(m.contains_key(key)))\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":16763,"byte_end":16766,"line_start":504,"line_end":504,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        _ => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:504:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m504\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         _ => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":16970,"byte_end":16976,"line_start":511,"line_end":511,"column_start":32,"column_end":38,"is_primary":true,"text":[{"text":"fn map_size(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":32,"highlight_end":38}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:511:32\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m511\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn map_size(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":17046,"byte_end":17048,"line_start":513,"line_end":513,"column_start":26,"column_end":28,"is_primary":true,"text":[{"text":"        Value::Map(m) => Ok(Value::Number(m.len() as f64)),","highlight_start":26,"highlight_end":28}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:513:26\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m513\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Value::Map(m) => Ok(Value::Number(m.len() as f64)),\n    \u001b[1m\u001b[96m|\u001b[0m                          \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":17094,"byte_end":17097,"line_start":514,"line_end":514,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        v => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:514:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m514\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         v => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":17450,"byte_end":17456,"line_start":525,"line_end":525,"column_start":31,"column_end":37,"is_primary":true,"text":[{"text":"fn to_text(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":31,"highlight_end":37}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:525:31\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m525\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn to_text(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":18093,"byte_end":18095,"line_start":538,"line_end":538,"column_start":5,"column_end":7,"is_primary":true,"text":[{"text":"    Ok(Value::Text(text))","highlight_start":5,"highlight_end":7}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:538:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m538\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Ok(Value::Text(text))\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":18150,"byte_end":18156,"line_start":541,"line_end":541,"column_start":33,"column_end":39,"is_primary":true,"text":[{"text":"fn to_number(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":33,"highlight_end":39}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:541:33\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m541\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn to_number(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                 \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":18229,"byte_end":18231,"line_start":543,"line_end":543,"column_start":29,"column_end":31,"is_primary":true,"text":[{"text":"        Value::Number(n) => Ok(Value::Number(*n)),","highlight_start":29,"highlight_end":31}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:543:29\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m543\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Value::Number(n) => Ok(Value::Number(*n)),\n    \u001b[1m\u001b[96m|\u001b[0m                             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":18478,"byte_end":18480,"line_start":549,"line_end":549,"column_start":28,"column_end":30,"is_primary":true,"text":[{"text":"        Value::Truth(b) => Ok(Value::Number(if *b { 1.0 } else { 0.0 })),","highlight_start":28,"highlight_end":30}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:549:28\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m549\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Value::Truth(b) => Ok(Value::Number(if *b { 1.0 } else { 0.0 })),\n    \u001b[1m\u001b[96m|\u001b[0m                            \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":18538,"byte_end":18541,"line_start":550,"line_end":550,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"        v => Err(RuntimeError::TypeError {","highlight_start":14,"highlight_end":17}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:550:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m550\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         v => Err(RuntimeError::TypeError {\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":18724,"byte_end":18730,"line_start":557,"line_end":557,"column_start":32,"column_end":38,"is_primary":true,"text":[{"text":"fn to_truth(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":32,"highlight_end":38}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:557:32\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m557\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn to_truth(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":18758,"byte_end":18760,"line_start":558,"line_end":558,"column_start":5,"column_end":7,"is_primary":true,"text":[{"text":"    Ok(Value::Truth(args[0].is_truthy()))","highlight_start":5,"highlight_end":7}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:558:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m558\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Ok(Value::Truth(args[0].is_truthy()))\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":18829,"byte_end":18835,"line_start":561,"line_end":561,"column_start":31,"column_end":37,"is_primary":true,"text":[{"text":"fn type_of(args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":31,"highlight_end":37}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:561:31\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m561\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn type_of(args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":18863,"byte_end":18865,"line_start":562,"line_end":562,"column_start":5,"column_end":7,"is_primary":true,"text":[{"text":"    Ok(Value::Text(args[0].type_name().to_string()))","highlight_start":5,"highlight_end":7}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:562:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m562\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Ok(Value::Text(args[0].type_name().to_string()))\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":19336,"byte_end":19342,"line_start":573,"line_end":573,"column_start":33,"column_end":39,"is_primary":true,"text":[{"text":"fn io_print(_args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":33,"highlight_end":39}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:573:33\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m573\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn io_print(_args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                 \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":19370,"byte_end":19373,"line_start":574,"line_end":574,"column_start":5,"column_end":8,"is_primary":true,"text":[{"text":"    Err(RuntimeError::Custom(","highlight_start":5,"highlight_end":8}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:574:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m574\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Err(RuntimeError::Custom(\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":19535,"byte_end":19541,"line_start":579,"line_end":579,"column_start":35,"column_end":41,"is_primary":true,"text":[{"text":"fn io_println(_args: &[Value]) -> Result<Value, RuntimeError> {","highlight_start":35,"highlight_end":41}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:579:35\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m579\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn io_println(_args: &[Value]) -> Result<Value, RuntimeError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                   \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":19569,"byte_end":19572,"line_start":580,"line_end":580,"column_start":5,"column_end":8,"is_primary":true,"text":[{"text":"    Err(RuntimeError::Custom(","highlight_start":5,"highlight_end":8}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\runtime.rs","byte_start":496,"byte_end":496,"line_start":13,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\runtime.rs:580:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m580\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Err(RuntimeError::Custom(\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m13\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Option` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":3862,"byte_end":3868,"line_start":132,"line_end":132,"column_start":13,"column_end":19,"is_primary":true,"text":[{"text":"    parent: Option<usize>,  // Index of parent scope","highlight_start":13,"highlight_end":19}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this enum","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Option` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:132:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m132\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     parent: Option<usize>,  // Index of parent scope\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this enum\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::option::Option;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Option` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":3938,"byte_end":3944,"line_start":136,"line_end":136,"column_start":20,"column_end":26,"is_primary":true,"text":[{"text":"    fn new(parent: Option<usize>) -> Self {","highlight_start":20,"highlight_end":26}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this enum","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Option` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:136:20\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m136\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn new(parent: Option<usize>) -> Self {\n    \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this enum\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::option::Option;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Option` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":4310,"byte_end":4316,"line_start":152,"line_end":152,"column_start":37,"column_end":43,"is_primary":true,"text":[{"text":"    fn lookup(&self, name: &str) -> Option<&Symbol> {","highlight_start":37,"highlight_end":43}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this enum","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Option` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:152:37\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m152\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn lookup(&self, name: &str) -> Option<&Symbol> {\n    \u001b[1m\u001b[96m|\u001b[0m                                     \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this enum\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::option::Option;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find value `None` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":4576,"byte_end":4580,"line_start":165,"line_end":165,"column_start":39,"column_end":43,"is_primary":true,"text":[{"text":"        let global_scope = Scope::new(None);","highlight_start":39,"highlight_end":43}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these unit variants","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::elf::ElfClass::None;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::elf::ElfData::None;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::elf::ElfMachine::None;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::elf::ElfType::None;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::None;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find value `None` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:165:39\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m165\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let global_scope = Scope::new(None);\n    \u001b[1m\u001b[96m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these unit variants\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use crate::elf::ElfClass::None;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use crate::elf::ElfData::None;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use crate::elf::ElfMachine::None;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use crate::elf::ElfType::None;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0mand 1 other candidate\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":4788,"byte_end":4792,"line_start":174,"line_end":174,"column_start":36,"column_end":40,"is_primary":true,"text":[{"text":"        let new_scope = Scope::new(Some(self.current_scope));","highlight_start":36,"highlight_end":40}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:174:36\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m174\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let new_scope = Scope::new(Some(self.current_scope));\n    \u001b[1m\u001b[96m|\u001b[0m                                    \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":4987,"byte_end":4991,"line_start":181,"line_end":181,"column_start":16,"column_end":20,"is_primary":true,"text":[{"text":"        if let Some(parent) = self.scopes[self.current_scope].parent {","highlight_start":16,"highlight_end":20}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:181:16\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m181\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if let Some(parent) = self.scopes[self.current_scope].parent {\n    \u001b[1m\u001b[96m|\u001b[0m                \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":5218,"byte_end":5224,"line_start":187,"line_end":187,"column_start":73,"column_end":79,"is_primary":true,"text":[{"text":"    pub fn define(&mut self, name: String, typ: Type, mutable: bool) -> Result<(), SemanticError> {","highlight_start":73,"highlight_end":79}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:187:73\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m187\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn define(&mut self, name: String, typ: Type, mutable: bool) -> Result<(), SemanticError> {\n    \u001b[1m\u001b[96m|\u001b[0m                                                                         \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":5382,"byte_end":5385,"line_start":190,"line_end":190,"column_start":20,"column_end":23,"is_primary":true,"text":[{"text":"            return Err(SemanticError::DuplicateDefinition(name));","highlight_start":20,"highlight_end":23}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:190:20\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m190\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             return Err(SemanticError::DuplicateDefinition(name));\n    \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":5516,"byte_end":5518,"line_start":194,"line_end":194,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"        Ok(())","highlight_start":9,"highlight_end":11}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:194:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m194\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(())\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Option` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":5629,"byte_end":5635,"line_start":198,"line_end":198,"column_start":41,"column_end":47,"is_primary":true,"text":[{"text":"    pub fn lookup(&self, name: &str) -> Option<&Symbol> {","highlight_start":41,"highlight_end":47}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this enum","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Option` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:198:41\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m198\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn lookup(&self, name: &str) -> Option<&Symbol> {\n    \u001b[1m\u001b[96m|\u001b[0m                                         \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this enum\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::option::Option;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":5729,"byte_end":5733,"line_start":201,"line_end":201,"column_start":20,"column_end":24,"is_primary":true,"text":[{"text":"            if let Some(symbol) = self.scopes[scope_idx].lookup(name) {","highlight_start":20,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:201:20\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m201\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             if let Some(symbol) = self.scopes[scope_idx].lookup(name) {\n    \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Some` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":5805,"byte_end":5809,"line_start":202,"line_end":202,"column_start":24,"column_end":28,"is_primary":true,"text":[{"text":"                return Some(symbol);","highlight_start":24,"highlight_end":28}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:202:24\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m202\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 return Some(symbol);\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":5887,"byte_end":5891,"line_start":206,"line_end":206,"column_start":20,"column_end":24,"is_primary":true,"text":[{"text":"            if let Some(parent) = self.scopes[scope_idx].parent {","highlight_start":20,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:206:20\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m206\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             if let Some(parent) = self.scopes[scope_idx].parent {\n    \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find value `None` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":6014,"byte_end":6018,"line_start":209,"line_end":209,"column_start":24,"column_end":28,"is_primary":true,"text":[{"text":"                return None;","highlight_start":24,"highlight_end":28}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these unit variants","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::elf::ElfClass::None;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::elf::ElfData::None;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::elf::ElfMachine::None;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::elf::ElfType::None;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::None;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find value `None` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:209:24\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m209\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 return None;\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these unit variants\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use crate::elf::ElfClass::None;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use crate::elf::ElfData::None;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use crate::elf::ElfMachine::None;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use crate::elf::ElfType::None;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0mand 1 other candidate\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":9196,"byte_end":9202,"line_start":329,"line_end":329,"column_start":53,"column_end":59,"is_primary":true,"text":[{"text":"    pub fn analyze(&mut self, nodes: &[AstNode]) -> Result<(), Vec<SemanticError>> {","highlight_start":53,"highlight_end":59}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:329:53\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m329\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn analyze(&mut self, nodes: &[AstNode]) -> Result<(), Vec<SemanticError>> {\n    \u001b[1m\u001b[96m|\u001b[0m                                                     \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Ok` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":9353,"byte_end":9355,"line_start":335,"line_end":335,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"            Ok(())","highlight_start":13,"highlight_end":15}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Ok;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Ok` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:335:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m335\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(())\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::result::Result::Ok;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `Err` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":9389,"byte_end":9392,"line_start":337,"line_end":337,"column_start":13,"column_end":16,"is_primary":true,"text":[{"text":"            Err(self.errors.clone())","highlight_start":13,"highlight_end":16}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find function, tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:337:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m337\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Err(self.errors.clone())\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":9855,"byte_end":9859,"line_start":352,"line_end":352,"column_start":24,"column_end":28,"is_primary":true,"text":[{"text":"                if let Some(symbol) = self.symbol_table.lookup(name) {","highlight_start":24,"highlight_end":28}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:352:24\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m352\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 if let Some(symbol) = self.symbol_table.lookup(name) {\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Err` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":10287,"byte_end":10290,"line_start":363,"line_end":363,"column_start":24,"column_end":27,"is_primary":true,"text":[{"text":"                if let Err(e) = self.symbol_table.define(name.clone(), value_type, false) {","highlight_start":24,"highlight_end":27}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:363:24\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m363\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 if let Err(e) = self.symbol_table.define(name.clone(), value_type, false) {\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Err` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":10594,"byte_end":10597,"line_start":371,"line_end":371,"column_start":24,"column_end":27,"is_primary":true,"text":[{"text":"                if let Err(e) = self.symbol_table.define(name.clone(), value_type, true) {","highlight_start":24,"highlight_end":27}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:371:24\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m371\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 if let Err(e) = self.symbol_table.define(name.clone(), value_type, true) {\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":10998,"byte_end":11002,"line_start":381,"line_end":381,"column_start":24,"column_end":28,"is_primary":true,"text":[{"text":"                if let Some((expected_type, is_mutable)) = symbol_info {","highlight_start":24,"highlight_end":28}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:381:24\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m381\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 if let Some((expected_type, is_mutable)) = symbol_info {\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Err` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":12166,"byte_end":12169,"line_start":406,"line_end":406,"column_start":24,"column_end":27,"is_primary":true,"text":[{"text":"                if let Err(e) = self.symbol_table.define(name.clone(), func_type, false) {","highlight_start":24,"highlight_end":27}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result::Err;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Err` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:406:24\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m406\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 if let Err(e) = self.symbol_table.define(name.clone(), func_type, false) {\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::result::Result::Err;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `Some` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":13610,"byte_end":13614,"line_start":449,"line_end":449,"column_start":24,"column_end":28,"is_primary":true,"text":[{"text":"                if let Some(else_stmts) = else_branch {","highlight_start":24,"highlight_end":28}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple variant","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::option::Option::Some;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0531]\u001b[0m\u001b[1m\u001b[97m: cannot find tuple struct or tuple variant `Some` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:449:24\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m449\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 if let Some(else_stmts) = else_branch {\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple variant\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::option::Option::Some;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"cannot find type `Result` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":25385,"byte_end":25391,"line_start":748,"line_end":748,"column_start":38,"column_end":44,"is_primary":true,"text":[{"text":"pub fn analyze(nodes: &[AstNode]) -> Result<(), Vec<SemanticError>> {","highlight_start":38,"highlight_end":44}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use core::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"groves\\glimmer_weave\\src\\semantic.rs","byte_start":623,"byte_end":623,"line_start":14,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use alloc::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Result` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\semantic.rs:748:38\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m748\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn analyze(nodes: &[AstNode]) -> Result<(), Vec<SemanticError>> {\n    \u001b[1m\u001b[96m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use core::result::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m14\u001b[0m \u001b[92m+ use alloc::fmt::Result;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused import: `super::*`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":8189,"byte_end":8197,"line_start":324,"line_end":324,"column_start":9,"column_end":17,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":9,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\token.rs","byte_start":8185,"byte_end":8198,"line_start":324,"line_end":324,"column_start":5,"column_end":18,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":5,"highlight_end":18}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused import: `super::*`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\token.rs:324:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m324\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     use super::*;\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused import: `AstNode::*`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":13602,"byte_end":13612,"line_start":425,"line_end":425,"column_start":13,"column_end":23,"is_primary":true,"text":[{"text":"        use AstNode::*;","highlight_start":13,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":13598,"byte_end":13613,"line_start":425,"line_end":425,"column_start":9,"column_end":24,"is_primary":true,"text":[{"text":"        use AstNode::*;","highlight_start":9,"highlight_end":24}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused import: `AstNode::*`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:425:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m425\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         use AstNode::*;\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[93m^^^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused import: `BinaryOperator::*`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":13626,"byte_end":13643,"line_start":426,"line_end":426,"column_start":13,"column_end":30,"is_primary":true,"text":[{"text":"        use BinaryOperator::*;","highlight_start":13,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\codegen.rs","byte_start":13622,"byte_end":13644,"line_start":426,"line_end":426,"column_start":9,"column_end":31,"is_primary":true,"text":[{"text":"        use BinaryOperator::*;","highlight_start":9,"highlight_end":31}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused import: `BinaryOperator::*`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\codegen.rs:426:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m426\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         use BinaryOperator::*;\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[93m^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"unused imports: `String` and `ToString`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":1436,"byte_end":1442,"line_start":35,"line_end":35,"column_start":21,"column_end":27,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":21,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":1444,"byte_end":1452,"line_start":35,"line_end":35,"column_start":29,"column_end":37,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":29,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"groves\\glimmer_weave\\src\\elf.rs","byte_start":1416,"byte_end":1455,"line_start":35,"line_end":36,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::string::{String, ToString};","highlight_start":1,"highlight_end":39},{"text":"use alloc::vec::Vec;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused imports: `String` and `ToString`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mgroves\\glimmer_weave\\src\\elf.rs:35:21\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m35\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use alloc::string::{String, ToString};\n   \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[93m^^^^^^\u001b[0m  \u001b[1m\u001b[93m^^^^^^^^\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"`#[panic_handler]` function required, but not found","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: `#[panic_handler]` function required, but not found\u001b[0m\n\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0405, E0412, E0425, E0463, E0531.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mSome errors have detailed explanations: E0405, E0412, E0425, E0463, E0531.\u001b[0m\n"}}
{"reason":"compiler-message","package_id":"path+file:///F:/OS/groves/glimmer_weave#0.1.0","manifest_path":"F:\\OS\\groves\\glimmer_weave\\Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"glimmer_weave","src_path":"F:\\OS\\groves\\glimmer_weave\\src\\lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0405`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mFor more information about an error, try `rustc --explain E0405`.\u001b[0m\n"}}
{"reason":"build-finished","success":false}
